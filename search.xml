<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>29. 持久数据的可靠性</title>
      <link href="/2024/07/11/OS/class29/"/>
      <url>/2024/07/11/OS/class29/</url>
      
        <content type="html"><![CDATA[<h2 id="实现可靠的磁盘">实现可靠的磁盘</h2><h3 id="持久数据的-“持久”">持久数据的 “持久”</h3><blockquote><p>如果我们的数据 “就地消失”</p></blockquote><ul><li>通讯软件无法使用</li><li>支付软件无法使用</li></ul><h3 id="没有-“一个”-绝对可靠的存储设备">没有 “一个” 绝对可靠的存储设备</h3><blockquote><p>临时失效</p></blockquote><ul><li>Kernel panic (bug); 断电</li></ul><blockquote><p>部分失效</p></blockquote><ul><li>ECC 纠错失败; fail slow</li></ul><blockquote><p>永久失效</p></blockquote><ul><li>小概率事件：硬盘物理损坏 (大量重复 = 必然发生)</li><li>极小概率事件：战争爆发/三体人进攻地球/世界毁灭</li></ul><h3 id="RAID-存储设备的虚拟化">RAID: 存储设备的虚拟化</h3><blockquote><p>性能和可靠性，我们能不能全都要呢？</p></blockquote><ul><li>Redundant Array of Inexpensive (Independent) Disks (RAID)</li><li>把多个 (不可靠的) 磁盘虚拟成一块非常可靠且性能极高的虚拟磁盘<ul><li><a href="https://dl.acm.org/doi/10.1145/971701.50214">A case for redundant arrays of inexpensive disks (RAID)</a>(SIGMOD’88)</li></ul></li></ul><blockquote><p>一个 “反向” 的虚拟化</p></blockquote><ul><li>类比：进程/虚存/文件把 “一个设备” 虚拟成多份</li></ul><h3 id="RAID-Design-Space">RAID: Design Space</h3><blockquote><p>RAID (虚拟化) = 虚拟块号到 (磁盘, 块号) 的 “映射”</p></blockquote><ul><li>虚拟磁盘块可以存储在任何物理磁盘上<ul><li>物理磁盘读写可以并行；存储<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">&gt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>份即可实现容错</li></ul></li></ul><blockquote><p>RAID-0：更大的容量、更快的速度</p></blockquote><ul><li>读速度 x 2；写速度 x 2</li><li>Quiz: 交错排列还是一分为二?</li></ul><blockquote><p>RAID-1：镜像 (容错)</p></blockquote><ul><li>保持两块盘完全一样</li><li>读速度 x 2；写速度保持一致</li></ul><h3 id="容错的代价">容错的代价</h3><blockquote><p>浪费了一块盘的容量……</p></blockquote><ul><li>如果我们有 100 块盘</li><li>但假设不会有两块盘同时 fail-stop？</li></ul><blockquote><p>能不能只用 1-bit 的冗余，恢复出一个丢失的 bit？</p></blockquote><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>a</mi><mo>⊕</mo><mi>b</mi><mo>⊕</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">x=a⊕b⊕c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>x</mi><mo>⊕</mo><mi>b</mi><mo>⊕</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a=x⊕b⊕c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mi>a</mi><mo>⊕</mo><mi>x</mi><mo>⊕</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">b=a⊕x⊕c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mi>a</mi><mo>⊕</mo><mi>b</mi><mo>⊕</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">c=a⊕b⊕x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></li></ul></li><li>100 块盘里，99 块盘都是数据！<ul><li>Caveat: random write 性能</li></ul></li></ul><h3 id="RAID-5-Rotating-Parity">RAID-5: Rotating Parity</h3><blockquote><p>使 Parity 均匀分布在各个磁盘</p></blockquote><p><img src="https://cdn-img-el3.pages.dev/os/c29-1-1.webp" alt="c29-1-1.webp"></p><h3 id="RAID-讨论">RAID: 讨论</h3><blockquote><p>更快、更可靠、近乎免费的大容量磁盘</p></blockquote><ul><li>从此再无 “高可靠性磁盘”<ul><li>现在我们只需要RAID</li></ul></li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c29-1-2.webp" alt="c29-1-2.webp"></p><h3 id="RAID-自身的可靠性">RAID: 自身的可靠性</h3><blockquote><p>磁盘 Fail-stop</p></blockquote><ul><li>软件可以感知</li><li>自动启用备盘并复制数据<ul><li>期间性能下降</li></ul></li></ul><blockquote><p>RAID 物理磁盘不能完美同步</p></blockquote><ul><li>断电 → 数据不一致</li><li>如何解决？</li></ul><h3 id="计算机系统的又一个黄金时代">计算机系统的又一个黄金时代</h3><blockquote><p>“三驾马车” 开启 “大数据” 时代</p></blockquote><ul><li><a href="https://dl.acm.org/doi/10.1145/1165389.945450">GFS (Google file system)</a> (SOSP’03), <a href="https://dl.acm.org/doi/10.5555/1251254.1251264">MapReduce</a> (OSDI’04), <a href="https://www.usenix.org/legacy/event/osdi06/tech/chang/chang.pdf">BigTable</a> (OSDI’06)</li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c29-1-3.webp" alt="c29-1-3.webp"></p><center>这是一个分布式的RAID</center><h3 id="数据中心存储：一个-“分布式的-RAID”">数据中心存储：一个 “分布式的 RAID”</h3><blockquote><p>Everything is Virtual</p></blockquote><p><img src="https://cdn-img-el3.pages.dev/os/c29-1-4.webp" alt="c29-1-4.webp"></p><ul><li>阿里云 Elastic Block Storage (<a href="https://www.usenix.org/system/files/fast24-zhang-weidong.pdf">EBS</a>, FAST’24 🏅)<ul><li>现在理解为什么云厂商能躺着挣 💰 了</li><li>算上 3X replica，amplification 还<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">&lt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li></ul></li></ul><h3 id="数据中心存储的挑战">数据中心存储的挑战</h3><blockquote><p>Data corruption</p></blockquote><ul><li>磁盘看起来正常，但一<a href="https://www.usenix.org/conference/fast-08/analysis-data-corruption-storage-stack">部分数据坏了</a></li></ul><blockquote><p>Fail-slow</p></blockquote><p><img src="https://cdn-img-el3.pages.dev/os/c29-1-5.webp" alt="c29-1-5.webp"></p><ul><li>Firmware bug; device error; wear-out; configuration; environment; … 磁盘上的 “<a href="https://www.usenix.org/system/files/login/articles/login_summer18_06_gunawi.pdf">性能问题</a>”</li></ul><h2 id="实现可靠的文件系统">实现可靠的文件系统</h2><h3 id="崩溃一致性-Crash-Consistency">崩溃一致性 (Crash Consistency)</h3><blockquote><p>Crash Consistency: Move the file system from one consistent state (e.g., before the file got appended to) to another atomically (e.g., after the inode, bitmap, and new data block have been written to disk).</p></blockquote><p><img src="https://cdn-img-el3.pages.dev/os/c29-2-1.webp" alt="c29-2-1.webp"></p><p>(你们平时编程时假设不会发生的事，操作系统都要给你兜底)</p><h3 id="Recap-文件系统的实现">Recap: 文件系统的实现</h3><blockquote><p>磁盘上的数据结构</p></blockquote><p><img src="https://cdn-img-el3.pages.dev/os/c29-2-2.webp" alt="c29-2-2.webp"></p><ul><li>为吞吐量优化<ul><li>配合 “按块读写”，而不是 “Random Access”</li></ul></li><li>数据结构更关注局部性<ul><li>临近的信息紧凑地排列在一起</li></ul></li></ul><h3 id="实现崩溃一致性">实现崩溃一致性</h3><blockquote><p>磁盘：提供的接口</p></blockquote><ul><li>bwrite</li><li>bread<ul><li>并不提供多块读写 “all or nothing” 的支持</li><li>甚至为了性能，没有顺序保证<ul><li>bwrite 可能被乱序</li></ul></li></ul></li><li>bflush 等待已写入的数据落盘<ul><li>即便是 vSSD，也没有实现 crash consistency</li></ul></li></ul><h3 id="File-System-Checking-FSCK">File System Checking (FSCK)</h3><blockquote><p>根据磁盘上已有的信息，恢复出 “最可能” 的数据结构</p></blockquote><p><img src="https://cdn-img-el3.pages.dev/os/c29-2-3.webp" alt="c29-2-3.webp"></p><ul><li><a href="https://dl.acm.org/doi/10.5555/1855741.1855751">SQCK: A declarative file system checker</a> (OSDI’08)</li><li><a href="https://dl.acm.org/doi/10.1145/3281031">然而</a> (FAST’18): “widely used file systems (EXT4, XFS, BtrFS, and F2FS) may leave the file system in an uncorrectable state if the repair procedure is interrupted unexpectedly”</li></ul><h3 id="实现崩溃一致性-2">实现崩溃一致性</h3><blockquote><p>我们需要一个更可靠的方法</p></blockquote><ul><li>只要磁盘不坏，断电就不会有数据损坏</li></ul><blockquote><p>难实现的根本原因</p></blockquote><ul><li>存储设备不提供多次写入的原子性<ul><li>bwrite(inode)</li><li>bwrite(d-bitmap)</li><li>bwrite(data)</li></ul></li></ul><h3 id="重新理解-“数据结构”">重新理解 “数据结构”</h3><blockquote><p>视角 1: 存储实际数据结构 (链表、二叉树、……)</p></blockquote><ul><li>文件系统的 “直观” 表示</li><li>crash unsafe</li></ul><blockquote><p>视角 2: Append-only 记录所有历史操作</p></blockquote><ul><li>“重做” 所有操作得到数据结构的当前状态</li><li>容易实现崩溃一致性</li></ul><blockquote><p>Jouraling = 1 + 2</p></blockquote><ul><li>先用 append-only 记录日志，等待落盘，再更新数据结构</li></ul><h3 id="实现-Atomic-Append">实现 Atomic Append</h3><blockquote><p>用 bread, bwrite 和 bflush 实现 append()</p></blockquote><p><img src="https://cdn-img-el3.pages.dev/os/c29-2-4.webp" alt="c29-2-4.webp"></p><ol><li>定位到 journal 的末尾 (bread)</li><li>bwrite TXBegin 和所有数据结构操作</li><li>bflush 等待数据落盘</li><li>bwrite TXEnd</li><li>bflush 等待数据落盘</li><li>将数据结构操作写入实际数据结构区域</li><li>等待数据落盘后，删除 (标记) 日志</li></ol><h3 id="Journaling-优化">Journaling: 优化</h3><blockquote><p>现在磁盘需要写入双份的数据</p></blockquote><ul><li>批处理 (xv6; jbd)<ul><li>多次系统调用的 Tx 合并成一个，减少 log 的大小</li><li>jbd: 定期 write back</li></ul></li><li>Checksum (ext4)<ul><li>不再标记 TxBegin/TxEnd</li><li>直接标记 Tx 的长度和 checksum</li></ul></li><li>Metadata journaling (ext4 default)<ul><li>数据占磁盘写入的绝大部分<ul><li>只对 inode 和 bitmap 做 journaling 可以提高性能</li></ul></li><li>保证文件系统的目录结构是一致的；但数据可能丢失</li></ul></li></ul><h3 id="Metadata-Journaling">Metadata Journaling</h3><blockquote><p>从应用视角来看，文件系统的行为可能很怪异</p></blockquote><ul><li>各类系统软件 (git, sqlite, gdbm, …) 不幸中招<ul><li>A<a href="https://www.bing.com/search?q=All+file+systems+are+not+created+equal%3A+On+the+complexity+of+crafting+crash-consistent+applications&amp;form=APMCS1&amp;PC=APMC&amp;mkt=zh-CN">ll file systems are not created equal: On the complexity of crafting crash-consistent applications</a> (OSDI’14)</li><li>(os-workbench 里的小秘密)</li></ul></li><li><a href="https://zhuanlan.zhihu.com/p/25188921">更多的应用程序可能发生 data loss</a><ul><li>我们的工作: GNU coreutils, gmake, gzip, … 也有问题</li><li><a href="https://dl.acm.org/doi/10.1145/2950290.2950327">Crash consistency validation made easy</a> (FSE’16)</li></ul></li></ul><blockquote><p>更为一劳永逸的方案：<a href="https://dl.acm.org/doi/10.1145/1629575.1629591">TxOS</a></p></blockquote><ul><li>xbegin/xend/xabort 系统调用实现跨 syscall 的  “all-or-nothing”<ul><li>应用场景：数据更新、软件更新、check-use……</li></ul></li></ul><p><em>存储系统支撑了当今的互联网工业——每个 SSD 都是 “套娃” 的计算机系统；它们又组成了大规模存储网络，构成了我们今天的数字世界。实现低成本、高性能、高可靠的存储并不是一个十分简单的问题，这也是计算机产业让我们感到激动的原因。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>28. 文件系统</title>
      <link href="/2024/07/10/OS/class28/"/>
      <url>/2024/07/10/OS/class28/</url>
      
        <content type="html"><![CDATA[<h2 id="文件系统">文件系统</h2><blockquote><p>文件 = struct file_operations</p></blockquote><ul><li>数据文件：hello.c, a.out, …<ul><li>虚拟的磁盘</li><li>vector<char></li></ul></li><li>设备驱动<ul><li>null, nuke0, …</li></ul></li><li>虚拟文件<ul><li>进程的地址空间, …</li></ul></li></ul><blockquote><p>新需求：怎么管理系统中众多的文件？</p></blockquote><ul><li>find_file_by_name?</li></ul><h3 id="管理文件">管理文件</h3><blockquote><p>文件那么多，怎么找到想要的？</p></blockquote><ul><li>信息的局部性：将虚拟磁盘 (文件) 组织成层次结构</li></ul><h3 id="思路：信息的局部性">思路：信息的局部性</h3><blockquote><p>树状层次结构</p></blockquote><ul><li>逻辑相关的数据存放在相近的目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── 学习资料</span><br><span class="line">    ├── .学习资料(隐藏)</span><br><span class="line">    ├── 问题求解1</span><br><span class="line">    ├── 问题求解2</span><br><span class="line">    ├── 问题求解3</span><br><span class="line">    ├── 问题求解4</span><br><span class="line">    └── 操作系统</span><br></pre></td></tr></table></figure><h3 id="麻烦的是-“非数据”-的文件">麻烦的是 “非数据” 的文件</h3><blockquote><p>UNIX/Linux: Everything is a File</p></blockquote><ul><li>一切都在 “/” 中 (例子：中文语言包, fstab)</li></ul><blockquote><p>Windows 的设计</p></blockquote><ul><li>一个驱动器一棵树：A:, B:, C:, …</li><li>其他命名空间：Windows Driver Model, Registry<ul><li>(也可以 “everything is a file”)</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hDevice = CreateFile(</span><br><span class="line">    <span class="string">&quot;\\\\.\\PhysicalDrive0&quot;</span>,</span><br><span class="line">    GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">    FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class="line">    <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="UNIX-的设计：目录树的拼接">UNIX 的设计：目录树的拼接</h3><blockquote><p>mount: 将一个目录解析为另一个文件系统的根</p></blockquote><p><code>mount(source, target, filesystemtype, mountflags, data);</code></p><ul><li>再看 “最小 Linux”<ul><li>初始时只有 /dev/console 和几个文件</li><li>/proc, /sys, 甚至 /tmp 都没有<ul><li>答案：它们都是 mount 系统调用创建出来的</li></ul></li></ul></li><li>UNIX 一贯的设计哲学：灵活<ul><li>Linux 安装时的 “mount point”<ul><li>/, /home, /var 可以是独立的磁盘设备</li></ul></li></ul></li></ul><h3 id="Quiz">Quiz</h3><blockquote><p>如何挂载一个 filesystem.img?</p></blockquote><ul><li>一个微妙的循环<ul><li>文件 = 磁盘上的虚拟磁盘</li><li>挂载文件 = 在虚拟磁盘上虚拟出的虚拟磁盘</li></ul></li><li>镜像</li></ul><h3 id="Linux-的处理方式">Linux 的处理方式</h3><blockquote><p>创建一个 loopback (回环) 设备</p></blockquote><ul><li>设备驱动把设备的 read/write 翻译成文件的 read/write</li><li>drivers/block/loop.c<ul><li>实现了 loop_mq_ops (不是 file_operations)</li></ul></li></ul><blockquote><p>观察挂载文件的 strace</p></blockquote><ul><li>lsblk 查看系统中的 block devices (strace)</li><li>strace 观察挂载的流程<ul><li>ioctl(3, LOOP_CTL_GET_FREE)</li><li>ioctl(4, LOOP_SET_FD, 3)</li></ul></li></ul><h3 id="Filesystem-Hierarchy-Standard">Filesystem Hierarchy Standard</h3><blockquote><p>我们看到的目录结构</p></blockquote><ul><li>FHS enables software and user to predict the location of installed files and directories.<ul><li>例子：macOS 是 UNIX 的内核 (BSD), 但不遵循 Linux FHS</li></ul></li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c28-1-1.webp" alt="c28-1-1.webp"></p><h3 id="文件系统-API-目录管理">文件系统 API: 目录管理</h3><blockquote><p>mkdir</p></blockquote><ul><li>创建目录</li></ul><blockquote><p>rmdir</p></blockquote><ul><li>删除一个空目录</li><li>没有 “递归删除” 的系统调用<ul><li>rm -rf 会遍历目录，逐个删除 (试试 strace)</li></ul></li></ul><blockquote><p>getdents</p></blockquote><ul><li>返回 count 个目录项 (ls, find, tree 都使用这个)<ul><li>更友好的方式：globbing</li></ul></li></ul><h3 id="硬-hard-链接">硬 (hard) 链接</h3><blockquote><p>需求：系统中可能有同一个运行库的多个版本</p></blockquote><ul><li><a href="http://libc-2.27.so">libc-2.27.so</a>, <a href="http://libc-2.26.so">libc-2.26.so</a>, …</li><li>还需要一个 “当前版本的 libc”<ul><li>程序需要链接 “libc.so.6”，能否避免文件的一份拷贝？</li></ul></li></ul><blockquote><p>(硬) 链接：允许一个文件被多个目录引用</p></blockquote><ul><li>文件系统实现的特性 (ls -i 查看)<ul><li>不能链接目录、不能跨文件系统</li><li>删除文件的系统调用称为 “unlink” (refcount–)</li></ul></li></ul><h3 id="软-symbolic-链接">软 (symbolic) 链接</h3><blockquote><p>软链接：在文件里存储一个 “跳转提示”</p></blockquote><ul><li>软链接也是一个文件<ul><li>当引用这个文件时，去找另一个文件</li><li>另一个文件的绝对/相对路径以文本形式存储在文件里</li><li>可以跨文件系统、可以链接目录、……</li></ul></li></ul><blockquote><p>几乎没有任何限制</p></blockquote><ul><li>类似 “快捷方式”<ul><li>链接指向的位置不存在也没关系</li><li>(也许下次就存在了)</li></ul></li></ul><h2 id="文件系统：实现">文件系统：实现</h2><h3 id="文件系统实现">文件系统实现</h3><blockquote><p>文件的实现</p></blockquote><ul><li>文件 = “虚拟” 磁盘</li><li>API: read, write, ftruncate, …</li></ul><blockquote><p>目录的实现</p></blockquote><ul><li>目录 = 文件/目录的集合</li><li>API: mkdir, rmdir, readdir, link, unlink, …</li></ul><blockquote><p>mount 的实现</p></blockquote><ul><li>最好由操作系统统一管理 (而不是由具体的文件系统实现)</li></ul><h3 id="数据结构">数据结构</h3><blockquote><p>借助 RAM 自由布局目录和文件</p></blockquote><ul><li>文件系统就是一个 Abstract DataType (ADT)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FSObject</span> &#123;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">File</span>: FSObject &#123;</span><br><span class="line">  std::vector&lt;<span class="type">char</span>&gt; content; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span>: FSObject &#123;</span><br><span class="line">  std::map&lt;std::string, FSObject*&gt; children; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="操作系统">操作系统</h3><blockquote><p>对不起，没有 Random Access Memory</p></blockquote><ul><li>我们只有 block device</li><li>两个 API<ul><li><code>bread(int bid, struct block *b);</code></li><li><code>bwrite(int bid, struct block *b);</code></li></ul></li></ul><blockquote><p>实现：</p></blockquote><ul><li>read, write, ftruncate, …</li><li>mkdir, rmdir, readdir, link, unlink, …<ul><li>用 bread/bwrite 模拟 RAM → 严重的读/写放大</li><li>我们需要更适合磁盘的数据结构</li></ul></li></ul><h3 id="我们的敌人和朋友">我们的敌人和朋友</h3><blockquote><p>敌人：读/写放大</p></blockquote><ul><li>被迫读写连续的一块数据</li></ul><blockquote><p>朋友：局部性 + 缓存</p></blockquote><ul><li>适当地排布数据，使得临近的数据有 “一同访问” 的倾向</li><li>数据暂时停留在内存，延迟写回</li></ul><h2 id="FAT-和-UNIX-文件系统">FAT 和 UNIX 文件系统</h2><h3 id="让时间回到-1980-年">让时间回到 1980 年</h3><blockquote><p>5.25&quot; 软盘：单面 180 KiB</p></blockquote><ul><li>360 个 512B 扇区 (sectors)</li><li>在这样的设备上实现文件系统，应该选用怎样的数据结构？</li></ul><h3 id="需求分析">需求分析</h3><blockquote><p>相当小的文件系统</p></blockquote><ul><li>目录中一般只有几个、十几个文件</li><li>文件以小文件为主 (几个 block 以内)</li></ul><blockquote><p>文件的实现方式</p></blockquote><ul><li>struct block * 的链表<ul><li>任何复杂的高级数据结构都显得浪费</li></ul></li></ul><blockquote><p>目录的实现方式</p></blockquote><ul><li>目录就是一个普通的文件 (虚拟磁盘；“目录文件”)</li><li>操作系统会对文件的内容作为目录的解读<ul><li>文件内容就是一个 struct dentry[];</li></ul></li></ul><h3 id="用链表存储数据：两种设计">用链表存储数据：两种设计</h3><ol><li>在每个数据块后放置指针</li></ol><ul><li>优点：实现简单、无须单独开辟存储空间</li><li>缺点：数据的大小不是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>; 单纯的 lseek 需要读整块数据</li></ul><ol start="2"><li>将指针集中存放在文件系统的某个区域</li></ol><ul><li>优点：局部性好；lseek 更快</li><li>缺点：集中存放的数据损坏将导致数据丢失</li></ul><blockquote><p>哪种方式的缺陷是致命、难以解决的？</p></blockquote><h3 id="集中保存所有指针">集中保存所有指针</h3><blockquote><p>集中存储的指针容易损坏？存$n $份就行！</p></blockquote><ul><li>FAT-12/16/32 (FAT entry，即 “next 指针” 的大小)</li></ul><h3 id="“File-Allocation-Table”-文件系统">“File Allocation Table” 文件系统</h3><blockquote><p>RTFM 得到必要的细节</p></blockquote><ul><li>诸如 tutorial、博客都不可靠</li><li>还会丢失很多重要的细节</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (CountofClusters &lt; <span class="number">4085</span>) &#123;</span><br><span class="line">  <span class="comment">// Volume is FAT12 (2 MiB for 512B cluster)</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (CountofCluster &lt; <span class="number">65525</span>) &#123;</span><br><span class="line">  <span class="comment">// Volume is FAT16 (32 MiB for 512B cluster)</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Volume is FAT32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FAT-链接存储的文件">FAT: 链接存储的文件</h3><blockquote><p>“FAT” 的 “next” 数组</p></blockquote><ul><li>0: free; 2… MAX: allocated;</li><li>ffffff7: bad cluster; ffffff8-ffffffe, -1: end-of-file</li></ul><h3 id="目录树实现：目录文件">目录树实现：目录文件</h3><blockquote><p>以普通文件的方式存储 “目录” 这个数据结构</p></blockquote><ul><li>FAT: 目录 = 32-byte 定长目录项的集合</li><li>操作系统在解析时把标记为目录的目录项 “当做” 目录即可<ul><li>可以用连续的若干个目录项存储 “长文件名”</li></ul></li><li>思考题：为什么不把元数据 (大小、文件名、……) 保存在<code>vector&lt;struct block *&gt;</code> file 的头部？</li></ul><h3 id="Talk-is-Cheap-Show-Me-the-Code">Talk is Cheap, Show Me the Code!</h3><blockquote><p>首先，观察 “快速格式化” (mkfs.fat) 是如何工作的</p></blockquote><ul><li>老朋友：strace</li></ul><blockquote><p>然后，把整个磁盘镜像 mmap 进内存</p></blockquote><ul><li>照抄手册，遍历目录树 (fat-tree demo)，试试镜像</li></ul><blockquote><p>另一个有趣的问题：文件系统恢复</p></blockquote><ul><li>快速格式化 = FAT 表丢失<ul><li>所有的文件内容 (包括目录文件) 都还在</li><li>只是在数据结构眼里看起来都是 “free block”</li></ul></li><li>猜出文件系统的参数 (SecPerClus, BytsPerSec, …)，恢复 next 关系</li></ul><h3 id="FAT-性能与可靠性">FAT: 性能与可靠性</h3><blockquote><p>性能</p></blockquote><ul><li><code>＋</code> 小文件简直太合适了</li><li><code>－</code> 但大文件的随机访问就不行了<ul><li>4 GB 的文件跳到末尾 (4 KB cluster) 有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup><mn>0</mn></mrow><annotation encoding="application/x-tex">2^20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">0</span></span></span></span>次 next 操作</li><li>缓存能部分解决这个问题</li></ul></li><li>在 FAT 时代，磁盘连续访问性能更佳<ul><li>使用时间久的磁盘会产生碎片 (fragmentation)</li><li>malloc 也会产生碎片，不过对性能影响不太大</li></ul></li></ul><blockquote><p>可靠性</p></blockquote><ul><li>维护若干个 FAT 的副本防止元数据损坏 (额外的开销)</li></ul><h3 id="想要一个更好的文件系统？">想要一个更好的文件系统？</h3><blockquote><p>不能 “尽善尽美”，但可以在 “实际 workload” 下尽可能好</p></blockquote><table><thead><tr><th>Summary</th><th>Findings</th></tr></thead><tbody><tr><td>Most files are small</td><td>Roughly 2K is the most common size</td></tr><tr><td>Average file size is growing</td><td>Almost 200K is the average</td></tr><tr><td>Most bytes are stored in large files</td><td>A few big files use most of the space</td></tr><tr><td>File systems contains lots of files</td><td>Almost 100K on average</td></tr><tr><td>File systems are roughly half full</td><td>Even as disks grow, file systems remain ~50% full</td></tr><tr><td>Directories are typically small</td><td>Many have few entries; most have 20 or fewer</td></tr></tbody></table><h3 id="ext2-UNIX-文件系统">ext2/UNIX 文件系统</h3><blockquote><p>按对象方式集中存储文件/目录元数据</p></blockquote><ul><li>增强局部性 (更易于缓存)</li><li>支持链接</li></ul><blockquote><p>为大小文件区分 fast/slow path</p></blockquote><ul><li>小的时候应该用数组<ul><li>连链表遍历都省了</li></ul></li><li>大的时候应该用树 (B-Tree; Radix-Tree; …)<ul><li>快速的随机访问</li></ul></li></ul><h3 id="ext2-磁盘镜像格式">ext2: 磁盘镜像格式</h3><p>对磁盘进行分组</p><p><img src="https://cdn-img-el3.pages.dev/os/c28-3-1.webp" alt="c28-3-1.webp"></p><blockquote><p>“superblock”：文件系统元数据</p></blockquote><ul><li>文件 (inode) 数量</li><li>block group 信息<ul><li>ext2.h 里有你需要知道的一切</li></ul></li></ul><h3 id="ext2-目录文件">ext2 目录文件</h3><blockquote><p>与 FAT 本质相同：在文件上建立目录的数据结构</p></blockquote><ul><li>注意到 inode 统一存储<ul><li>目录文件中存储文件名到 inode 编号的 key-value mapping</li></ul></li></ul><h3 id="ext2-性能与可靠性">ext2: 性能与可靠性</h3><blockquote><p>局部性与缓存</p></blockquote><ul><li>bitmap, inode 都有 “集中存储” 的局部性</li><li>通过内存缓存减少读/写放大</li></ul><blockquote><p>大文件的随机读写性能提升明显<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(O(1))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">))</span></span></span></span></p></blockquote><ul><li>支持链接 (一定程度减少空间浪费)</li><li>inode 在磁盘上连续存储，便于缓存/预取</li><li>依然有碎片的问题</li></ul><blockquote><p>但可靠性依然是个很大的问题</p></blockquote><ul><li>存储 inode 的数据块损坏是很严重的</li></ul><p><em>把文件系统理解成一个 “数据结构”，就不难分析其中的重点和实现要点——我们总是把数据按照局部性组织起来，无论是 FAT 还是 bitmap/inode 的设计，都利用了这一点。另一个重要的设计是 “目录也是文件”——文件系统实现将目录文件中的数据作出解读，从而解析出其中的目录结构。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>27. 文件和设备驱动</title>
      <link href="/2024/07/09/OS/class27/"/>
      <url>/2024/07/09/OS/class27/</url>
      
        <content type="html"><![CDATA[<h2 id="文件和文件描述符">文件和文件描述符</h2><h3 id="Everything-is-a-File">Everything is a File</h3><blockquote><p>访问操作系统中的对象</p></blockquote><ul><li>文件：有 “名字” 的对象</li><li>字节流 (终端) 或字节序列 (普通文件；包括 /proc/*)</li></ul><blockquote><p>文件描述符</p></blockquote><ul><li>指向操作系统对象的 “指针”<ul><li>通过指针可以访问 “everything”</li></ul></li><li>对象的访问都需要指针<ul><li>open, close, read/write (解引用), lseek (指针内赋值/运算), dup (指针间赋值)</li></ul></li></ul><h3 id="应用程序：访问文件">应用程序：访问文件</h3><blockquote><p>通过系统调用</p></blockquote><ul><li>open, read, write, mmap, …</li><li>(当然可以；我们实现过很多这样的程序了)</li></ul><blockquote><p>真的是这样吗？</p></blockquote><ul><li>求证：strace readelf -h /bin/ls</li><li>还有更多有趣的例子<ul><li>LC_ALL=zh_CN.UTF-8 strace readelf -h a.txt</li><li>“不是 ELF 文件 - 它开头的 magic 字节错”？<ul><li>(需要 language-pack-zh-hans)</li><li>计算机世界没有魔法！</li></ul></li></ul></li></ul><h3 id="更多的细节-1">更多的细节 (1)</h3><blockquote><p>文件是 “虚拟磁盘”</p></blockquote><ul><li>把磁盘的一部分映射到地址空间，再自然不过了<br><code>mmap(addr, length, prot, flags, fd, offset);</code></li></ul><blockquote><p>一些细节问题</p></blockquote><ul><li>映射的长度超过文件大小会发生什么？<ul><li>启发：langchain (self-validation) 是趋势</li><li>RTFM 看来还是有用的 (“Errors”): SIGBUS<ul><li>ftruncate 可以改变文件大小</li></ul></li></ul></li></ul><h3 id="更多的细节-2">更多的细节 (2)</h3><blockquote><p>文件访问的 offset</p></blockquote><ul><li>文件的读写自带 “游标”<ul><li>省去了进程保存文件读/写的位置</li></ul></li></ul><blockquote><p>Offset 管理</p></blockquote><ul><li>read/write: 会自动维护 offset</li><li>lseek: 修改 offset 位置<ul><li>对比：mmap file，实现 append 是个噩梦</li></ul></li></ul><h3 id="更多的细节-3">更多的细节 (3)</h3><blockquote><p>mmap, lseek, ftruncate 互相交互的情况</p></blockquote><ul><li>假设初始时文件大小为 2MB<ul><li>lseek to 3 MiB (SEEK_SET)<ul><li>这时候能写入吗？</li></ul></li><li>ftruncate to 1 MiB<ul><li>这时候 offset 在哪里？</li></ul></li></ul></li></ul><blockquote><p>水面下的冰山</p></blockquote><ul><li>当多个机制互相作用时，系统就变得复杂</li></ul><h3 id="更多的细节-4">更多的细节 (4)</h3><blockquote><p>文件描述符在 fork 时会被子进程继承</p></blockquote><ul><li>父子进程共用 offset？</li><li>父子进程拥有独立 offset？</li></ul><blockquote><p>请你做一次操作系统的设计者</p></blockquote><ul><li>哪一种方案更合理？</li></ul><h3 id="偏移量管理：行为">偏移量管理：行为</h3><blockquote><p>操作系统的每一个 API 都可能和其他 API 有交互</p></blockquote><ol><li>open 时，获得一个独立的 offset</li><li>dup 时，两个文件描述符共享 offset</li><li>fork 时，父子进程共享 offset</li><li>execve 时文件描述符不变</li><li>O_APPEND 打开，偏移量永远在最后 (无论是否 fork)<ul><li>modification of the file offset and the write operation are performed as a single atomic step</li></ul></li></ol><blockquote><p>A fork() in the road</p></blockquote><ul><li>(在当时) 好的设计可能成为系统演化过程中的包袱</li></ul><h2 id="实现文件">实现文件</h2><h3 id="Everything-is-a-File-2">Everything is a File</h3><blockquote><p>文件描述符可以访问 “一切”</p></blockquote><ul><li>操作系统内核是如何实现的？</li><li>如你所料：一个 switch-case</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(f-&gt;type == FD_PIPE)&#123;</span><br><span class="line">  r = piperead(f-&gt;pipe, addr, n);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;major &lt; <span class="number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].read)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  r = devsw[f-&gt;major].read(<span class="number">1</span>, addr, n);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_INODE)&#123;</span><br><span class="line">  ilock(f-&gt;ip);</span><br><span class="line">  <span class="keyword">if</span>((r = readi(f-&gt;ip, <span class="number">1</span>, addr, f-&gt;off, n)) &gt; <span class="number">0</span>)</span><br><span class="line">    f-&gt;off += r;</span><br><span class="line">  iunlock(f-&gt;ip);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  panic(<span class="string">&quot;fileread&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如果是-proc-pid-maps">如果是 /proc/[pid]/maps?</h3><blockquote><p>syscall 时，我们有 current</p></blockquote><ul><li>current 指向了 memory areas 的数据结构<ul><li>&lt; 6.1: rbtree</li><li>≥ 6.1: maple tree (B-tree)</li></ul></li><li>要记得上锁</li><li>上锁就可能出性能问题<ul><li><a href="https://lwn.net/Articles/962373/">per-vma locks in userfaultfd</a></li></ul></li></ul><blockquote><p>文件 = 实现了文件操作的 “Anything”</p></blockquote><h2 id="设备驱动程序">设备驱动程序</h2><h3 id="回顾：I-O-设备">回顾：I/O 设备</h3><blockquote><p>一个能与 CPU 交换数据的接口/控制器</p></blockquote><ul><li>寄存器被映射到地址空间</li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c27-3-1.webp" alt="c27-3-1.webp"></p><blockquote><p>操作系统：Everything is a file</p></blockquote><ul><li>只需要一个 struct file_operations 的实现</li></ul><h3 id="设备驱动程序-2">设备驱动程序</h3><blockquote><p>一个 struct file_operations 的实现</p></blockquote><ul><li>把系统调用 “翻译” 成与设备能听懂的数据<ul><li>就是一段普通的内核代码</li></ul></li></ul><blockquote><p>例子</p></blockquote><ul><li>devfs 中的 “虚拟” 文件<ul><li>/dev/pts/[x] - pseudo terminal</li><li>/dev/zero, /dev/null (<a href="https://elixir.bootlin.com/linux/v6.9.3/source/drivers/char/mem.c">实现</a>), /dev/random, …</li></ul></li><li>procfs 中的 “虚拟文件”<ul><li>只要实现读/写操作即可</li><li>例子：<a href="https://elixir.bootlin.com/linux/v6.9.3/source/fs/proc/stat.c">/proc/stat 的实现</a></li></ul></li></ul><h3 id="驱动-Nuclear-Launcher">驱动 Nuclear Launcher</h3><blockquote><p>我们也可以实现一个</p></blockquote><ul><li>把对 /dev/nuke0 “路由” 我们的 file_operations</li><li>向 GPIO 的 memory-mapped address 写入正确的电平</li></ul><h3 id="配置设备">配置设备</h3><blockquote><p>设备不仅仅是数据，还有配置</p></blockquote><ul><li>打印机的卡纸、清洁、自动装订……<ul><li>一台几十万的打印机可不是那么简单</li></ul></li><li>键盘的跑马灯、重复速度、宏编程……</li><li>磁盘的健康状况、缓存控制……</li></ul><blockquote><p>两种实现方法</p></blockquote><ul><li>控制作为数据流的一部分 (ANSI Escape Code)</li><li>提供一个新的接口 (request-response)</li></ul><h3 id="ioctl">ioctl</h3><blockquote><p>The ioctl() system call manipulates the underlying device parameters of special files. In particular, many operating characteristics of character special files (e.g., terminals) may be controlled with ioctl() requests. The argument fd must be an open file descriptor.</p></blockquote><blockquote><p>“非数据” 的设备功能几乎全部依赖 ioctl</p></blockquote><ul><li>“Arguments, returns, and semantics of ioctl() vary according to the device driver in question”</li></ul><blockquote><p>堆叠的冗余代码</p></blockquote><ul><li>设备的复杂性是无法降低的<ul><li>“就是有那么多功能”</li><li>UNIX 的负担：复杂的 “hidden specifications”<ul><li>另一个负担：procfs</li></ul></li></ul></li></ul><blockquote><p>例子</p></blockquote><ul><li>终端：为什么 libc 能 “智能” 实现 buffer mode？</li><li>网卡，GPU，……</li><li>KVM Device</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>26. 输入输出设备</title>
      <link href="/2024/07/08/OS/class26/"/>
      <url>/2024/07/08/OS/class26/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机系统的最后一块拼图">计算机系统的最后一块拼图</h2><h3 id="孤独的-CPU">孤独的 CPU</h3><blockquote><p>CPU 只是 “无情的指令执行机器”</p></blockquote><ul><li>取指令、译码、执行</li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c26-1-1.webp" alt="c26-1-1.webp"></p><p>Altair-8800 (1975), with Intel 8080A; 256B 板卡 RAM<br>(你需要在面板上拨动开关输入执行指令的起始地址)</p><h3 id="实现输入-输出">实现输入/输出</h3><blockquote><p>例子：发射核弹</p></blockquote><ul><li>使计算机能感知外部状态 (眼睛、耳朵)、对外实施动作 (手)</li></ul><blockquote><p>GPIO (General Purpose Input/Output)</p></blockquote><ul><li>极简的模型：Memory-mapped I/O 直接读取/写入电平信号</li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c26-1-2.webp" alt="c26-1-2.webp"></p><h3 id="GPIO-一根可以读写数据的线">GPIO: 一根可以读写数据的线</h3><p><img src="https://cdn-img-el3.pages.dev/os/c26-1-3.gif" alt="c26-1-3.gif"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">led = LED(<span class="number">2</span>)</span><br><span class="line">led.on(); time.sleep(<span class="number">0.03</span>); led.off()</span><br></pre></td></tr></table></figure><ul><li>真正的核弹发射器也是类似的原理……</li></ul><h3 id="I-O-设备：“计算”-和-“物理世界”-之间的桥梁">I/O 设备：“计算” 和 “物理世界” 之间的桥梁</h3><blockquote><p>I/O 设备 = 一个能与 CPU 交换数据的接口/控制器</p></blockquote><ul><li>就是 “几组约定好功能的线” (寄存器)<ul><li>通过握手信号从线上读出/写入数据</li></ul></li><li>给寄存器 “赋予” 一个内存地址 (Address Decoder)<ul><li>CPU 可以直接使用指令 (in/out/MMIO) 和设备交换数据</li></ul></li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c26-1-4.webp" alt="c26-1-4.webp"></p><h3 id="例子-1-串口-UART">例子 (1): 串口 (UART)</h3><blockquote><p>“COM1” (Communication 1)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COM1 0x3f8</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">uart_init</span><span class="params">()</span> &#123;</span><br><span class="line">  outb(COM1 + <span class="number">2</span>, <span class="number">0</span>);   <span class="comment">// 控制器相关细节</span></span><br><span class="line">  outb(COM1 + <span class="number">3</span>, <span class="number">0x80</span>);</span><br><span class="line">  outb(COM1 + <span class="number">0</span>, <span class="number">115200</span> / <span class="number">9600</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">uart_tx</span><span class="params">(AM_UART_TX_T *send)</span> &#123;</span><br><span class="line">  outb(COM1, send-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">uart_rx</span><span class="params">(AM_UART_RX_T *recv)</span> &#123;</span><br><span class="line">  recv-&gt;data = (inb(COM1 + <span class="number">5</span>) &amp; <span class="number">0x1</span>) ? inb(COM1) : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子-2-键盘控制器">例子 (2): 键盘控制器</h3><blockquote><p>IBM PC/AT 8042 PS/2 (Keyboard) Controller</p></blockquote><ul><li>Port 0x60 (data), 0x64 (status/command)</li><li>command = 0xED → LED 灯控</li><li>command = 0xF3 → 设置重复速度和重复延迟<ul><li>PS/2 接口的 6 根线分别是什么作用？</li></ul></li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c26-1-5.webp" alt="c26-1-5.webp"></p><h3 id="例子-3-磁盘控制器">例子 (3): 磁盘控制器</h3><blockquote><p>ATA (Advanced Technology Attachment)</p></blockquote><ul><li>IDE 接口磁盘 (40pin data 很 “肥” 的数据线 + 4pin 电源)<ul><li>primary: 0x1f0 - 0x1f7; secondary: 0x170 - 0x177</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">readsect</span><span class="params">(<span class="type">void</span> *dst, <span class="type">int</span> sect)</span> &#123;</span><br><span class="line">  waitdisk();</span><br><span class="line">  out_byte(<span class="number">0x1f2</span>, <span class="number">1</span>);          <span class="comment">// sector count (1)</span></span><br><span class="line">  out_byte(<span class="number">0x1f3</span>, sect);       <span class="comment">// sector</span></span><br><span class="line">  out_byte(<span class="number">0x1f4</span>, sect &gt;&gt; <span class="number">8</span>);  <span class="comment">// cylinder (low)</span></span><br><span class="line">  out_byte(<span class="number">0x1f5</span>, sect &gt;&gt; <span class="number">16</span>); <span class="comment">// cylinder (high)</span></span><br><span class="line">  out_byte(<span class="number">0x1f6</span>, (sect &gt;&gt; <span class="number">24</span>) | <span class="number">0xe0</span>); <span class="comment">// drive</span></span><br><span class="line">  out_byte(<span class="number">0x1f7</span>, <span class="number">0x20</span>);       <span class="comment">// command (write)</span></span><br><span class="line">  waitdisk();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SECTSIZE / <span class="number">4</span>; i ++)</span><br><span class="line">    ((<span class="type">uint32_t</span> *)dst)[i] = in_long(<span class="number">0x1f0</span>); <span class="comment">// data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="持久化存储：复杂性的分解">持久化存储：复杂性的分解</h3><blockquote><p>1-Bit 的存储</p></blockquote><ul><li>磁、坑、电……</li><li>无论如何存储，设备都使用 “处理器能理解” 的接口</li></ul><blockquote><p>Serial ATA 接口</p></blockquote><ul><li>“几根导线”，可以工作在 IDE Mode/AHCI Mode</li></ul><h3 id="打印机是个怎样的设备？">打印机是个怎样的设备？</h3><p><img src="https://cdn-img-el3.pages.dev/os/c26-1-6.webp" alt="c26-1-6.webp"></p><ul><li>打印机将字节流描述的文字/图形打印到纸张上</li></ul><h3 id="PostScript-和打印机">PostScript 和打印机</h3><blockquote><p>PostScript 一种描述页面布局的 DSL (Page DL)</p></blockquote><ul><li>类似于汇编语言 (由 “编译器”，如 latex，生成)<ul><li>PDF 是 PostScript 的 superset</li></ul></li></ul><blockquote><p>打印机 (没错，实现自己的打印机没有那么困难)</p></blockquote><ul><li>将汇编语言翻译成机械部件动作的设备<ul><li>PCL, PostScript, 甚至直接支持 PDF</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ESC&gt;*t300R          // Set resolution to 300 DPI</span><br><span class="line">&lt;ESC&gt;*r1A            // Start raster graphics</span><br><span class="line">&lt;ESC&gt;*b100W          // Set width of raster data (100 bytes)</span><br><span class="line">&lt;ESC&gt;*b0M            // Set compression mode (0 = uncompressed)</span><br><span class="line">&lt;ESC&gt;*b100V          // Send 100 bytes of raster data</span><br><span class="line">&lt;binary raster data&gt; // Actual image data</span><br><span class="line">&lt;ESC&gt;*rB             // End raster graphics</span><br></pre></td></tr></table></figure><h2 id="管理更多的-I-O-设备">管理更多的 I/O 设备</h2><h3 id="1-我们不想造一台-“设备定死”-的计算机">(1) 我们不想造一台 “设备定死” 的计算机</h3><blockquote><p>接入更多 (甚至未知) 的 I/O 设备</p></blockquote><ul><li>想卖大价钱的 “大型机”：IBM, DEC, …</li><li>车库里造出来的 “微型机”：名垂青史的梦想家<ul><li>IBM PC/AT: ISA (Industry Standard Architecture) 总线</li><li>Apple II: 50-pin slot connector (Apple II Bus)</li></ul></li></ul><h3 id="总线：一个特殊的-I-O-设备">总线：一个特殊的 I/O 设备</h3><blockquote><p>提供设备的 “虚拟化”：注册和转发</p></blockquote><ul><li>把收到的地址 (总线地址) 和数据转发到相应的设备上</li><li>例子: port I/O 的端口就是总线上的地址<ul><li>IBM PC 的 CPU 其实只看到这一个 I/O 设备</li></ul></li></ul><blockquote><p>这样 CPU 只需要直连一个总线就行了！</p></blockquote><ul><li>今天 PCI 总线肩负了这个任务<ul><li>总线可以桥接其他总线 (例如 PCI → USB)</li></ul></li><li>lspci -tv 和 lsusb -tv: 查看系统中总线上的设备<ul><li>概念简单，实际非常复杂……<ul><li>电气特性、burst 传输、中断、Plug and Play</li></ul></li></ul></li></ul><h3 id="总线：名场面">总线：名场面</h3><p><a href="https://jyywiki.cn/OS/img/win98-scanner.mp4">视频地址</a></p><h3 id="2-CPU：只有一根中断线">(2) CPU：只有一根中断线</h3><p><img src="https://cdn-img-el3.pages.dev/os/c26-2-1.webp" alt="c26-2-1.webp"></p><h3 id="我们需要一个-“仲裁器”">我们需要一个 “仲裁器”</h3><blockquote><p>收集各个设备中断，并选择一个发送给 CPU</p></blockquote><ul><li>并且完成对设备的应答</li></ul><blockquote><p>例子</p></blockquote><ul><li>Intel 8259 PIC<ul><li>programmable interrupt controller</li><li>可以设置中断屏蔽、中断触发等 ……</li></ul></li><li>APIC (Advanced PIC)<ul><li>local APIC: 中断向量表, IPI, 时钟, ……</li><li>I/O APIC: 其他 I/O 设备</li></ul></li></ul><h3 id="3-解放-CPU-算力">(3) 解放 CPU 算力</h3><blockquote><p>操作系统：写入 1 GB 的数据到磁盘</p></blockquote><ul><li>即便磁盘已经准备好，依然需要非常浪费时间的循环</li><li>out 指令写入的是设备缓冲区，需要去总线上绕一圈<ul><li>cache disable; store 其实很慢的</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> GB / <span class="number">4</span>; i++) &#123;</span><br><span class="line">    outl(PORT, ((u32 *)buf)[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果是多处理器系统？</p></blockquote><ul><li>那就把 write_disk 线程扔到另一个 CPU</li></ul><h3 id="Direct-Memory-Access-DMA">Direct Memory Access (DMA)</h3><blockquote><p>加一个通用处理器太浪费，不如加一个简单的</p></blockquote><ul><li>DMA: 只能执行 memcpy(ATA0, buf, length); 的处理器</li><li>支持的几种类型的 memcpy<ul><li>memory → memory</li><li>memory → device (register)</li><li>device (register) → memory<ul><li>实际实现：直接把 DMA 控制器连接在总线和内存上</li><li>Intel 8237A</li></ul></li></ul></li></ul><blockquote><p>今天：PCI 总线支持 DMA</p></blockquote><ul><li>sudo cat /proc/iomem</li></ul><h2 id="填补-CPU-的算力空白">填补 CPU 的算力空白</h2><h3 id="一个有趣的事实">一个有趣的事实</h3><blockquote><p>计算机系统里充满了 “CPU”</p></blockquote><ul><li>CPU: 大核 + 小核 + 超小核</li><li>DMA: 执行 memcpy() 的 CPU</li><li>打印机：解析执行 PCL/PostScript 的 CPU</li><li>网卡：分拣以太网 packet (frame) 的 CPU<ul><li>它们都受到 CPU 的统一调配</li></ul></li></ul><blockquote><p>有需求，就会有更多的 “CPU”！</p></blockquote><h3 id="人类的本质需求：娱乐">人类的本质需求：娱乐</h3><blockquote><p>NES: 售出超过 60, 000, 000 台 (PS2, NDS 都破 1.5 亿了)</p></blockquote><ul><li>在 MOS 6502 @ 1.79Mhz (IPC = 0.43) 上实现 60 FPS<ul><li>每一帧必须在 ~10K 条指令内完成</li><li>但屏幕共有 256 x 240 = 61K 像素 (256 色)……</li></ul></li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c26-3-1.png" alt="c26-3-1.png"></p><h3 id="一个简单的答案：加个-CPU">一个简单的答案：加个 CPU</h3><blockquote><p>类比：DMA 是个 “降级” 的 CPU</p></blockquote><ul><li>只能执行 (半) 固定程序；但是电路更简单、执行速度更快、内置并行</li></ul><blockquote><p>在系统里加一个专门画图的 CPU?</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; W; x++)</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt;= H; y++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">      <span class="keyword">if</span> (intersects(sprites[i], x, y)) &#123;</span><br><span class="line">        fb[x][y] = sprites[i].pixel(x, y);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><ul><li>不再需要那么多通用寄存器，循环可以直接用计数器实现</li></ul><h3 id="NES-Picture-Processing-Unit-PPU">NES Picture Processing Unit (PPU)</h3><p>Sprite Spec: 位置 + 1-bit Priority; 1-bit Fip (H/V)</p><p><img src="https://cdn-img-el3.pages.dev/os/c26-3-2.png" alt="c26-3-2.png"></p><h3 id="榨干-PPU-的每一点性能">榨干 PPU 的每一点性能</h3><blockquote><p>前景 + 背景 = 给定机能下的极限图形效果</p></blockquote><ul><li><a href="https://www.zhihu.com/question/38528261">前景：《魂斗罗》中角色为什么要「萝莉式屈腿俯卧」？</a></li><li>背景：“卷轴” 操作</li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c26-3-1.gif" alt="c26-3-1.gif"></p><h3 id="以假乱真的贴图-3D">以假乱真的贴图 3D</h3><blockquote><p>GameBoy Advance</p></blockquote><ul><li>4 层背景; 128 个剪贴 objects; 32 个 affine objects<ul><li>CPU 给出描述；GPU 绘制 (执行 “一个程序” 的 CPU)</li></ul></li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c26-3-1.webp" alt="c26-3-1.webp"></p><h3 id="真正的-3D-图形">真正的 3D 图形</h3><blockquote><p>构建一个三角形的世界</p></blockquote><ul><li>给每个面涂上颜色 (<a href="https://www.bilibili.com/video/BV1sN4y1p7dG/">基本原理</a>)</li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c26-3-2.webp" alt="c26-3-2.webp"></p><center>Tomb Raider (1996)</center><h3 id="走向-“更真实”-的-3D">走向 “更真实” 的 3D</h3><p><img src="https://cdn-img-el3.pages.dev/os/c26-3-3.webp" alt="c26-3-3.webp"></p><blockquote><p>全靠 “PS”</p></blockquote><ul><li>虚假的真实感：Screen Space Ambient Occlusion</li><li>真实的真实感：Ray Tracing</li></ul><h3 id="Gefore-256-DDR-1999">Gefore 256 DDR (1999)</h3><p>支持硬件 Transform &amp; Lighting (更通用的计算)</p><p><img src="https://cdn-img-el3.pages.dev/os/c26-3-4.webp" alt="c26-3-4.webp"></p><h3 id="走向异构计算">走向异构计算</h3><blockquote><p>让更 “合适” 的 CPU 做他们更擅长的事</p></blockquote><ul><li>“固定” 的循环：不止是游戏图形</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; W; x++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt;= H; y++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (intersects(sprites[i], x, y)) &#123;</span><br><span class="line">                fb[x][y] = sprites[i].pixel(x, y);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><ul><li>mandelbrot.c (科学计算)</li><li>gpt.c (机器学习)<ul><li>神似，但更 “复杂” (需要更通用的计算)</li></ul></li><li>……</li></ul><h3 id="现代-GPU-一个通用计算设备">现代 GPU: 一个通用计算设备</h3><blockquote><p>类比：打印机</p></blockquote><ul><li>执行 PCL 代码 v.s. 执行 PTX 代码</li></ul><blockquote><p>一个完整的众核多处理器系统</p></blockquote><ul><li>拥有自己的内存 (显存)</li><li>可以把一段显存作为 FrameBuffer<ul><li>Vulkan: “Swap Chain”</li><li>显示控制器可以把一段像素 “直接输出” 到接口 (VGA, DisplayPort, HDMI) 上 (可以理解成显卡上的一个 DMA)<ul><li>正确的时序输出正确的信号 = 显示器能正确显示</li></ul></li></ul></li></ul><p><em>输入/输出设备是 “与处理器交换数据” 接口——因此，我们的设备可以实现得任意复杂，甚至是一个完整的计算机系统。从我们今天的打印机、SSD、GPU，都遵循了这个模式，在 CPU 的统一管理和调度下各自完成各自的功能。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>25.1-Bit 的存储</title>
      <link href="/2024/07/03/OS/class25/"/>
      <url>/2024/07/03/OS/class25/</url>
      
        <content type="html"><![CDATA[<h2 id="状态机和状态">状态机和状态</h2><blockquote><p>从计算模型到计算机系统</p></blockquote><ul><li>我们需要 “造出” 状态图、纸带……</li><li>核心：“纸、铅笔、橡皮”</li></ul><h3 id="在物理世界中实现状态">在物理世界中实现状态</h3><blockquote><p>实现 Random Access</p></blockquote><ul><li>磁铁 (1960s)</li><li>SRAM: Flip-flop</li><li>DRAM: 电容</li></ul><h3 id="在物理世界中实现持久化">在物理世界中实现持久化</h3><blockquote><p>Persistence: “A firm or obstinate continuance in a course of action in spite of difficulty or opposition.”</p></blockquote><ul><li>我们希望更大、更多的数据能 “留下来” (并且被操作系统有效地管理起来)</li></ul><blockquote><p>持久存储器的抽象</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint8_t</span> block[<span class="number">4096</span>]; <span class="comment">// 4KB</span></span><br><span class="line">block persist_memory[<span class="number">244140625</span>]; <span class="comment">// 1TB</span></span><br></pre></td></tr></table></figure><ul><li>一个巨大的 bit/byte array<ul><li>允许按 block 读写</li></ul></li></ul><h2 id="磁存储">磁存储</h2><h3 id="“持久化”-可能没有想象的那么困难">“持久化” 可能没有想象的那么困难</h3><blockquote><p>一个 “能反复改写的状态”</p></blockquote><ul><li>当然，要能寻址 + 用电路改写</li></ul><h3 id="电磁感应：物理和数字世界的桥梁">电磁感应：物理和数字世界的桥梁</h3><blockquote><p>1D 存储设备：把 Bits “卷起来” (磁带：1928)</p></blockquote><ul><li>纸带 (今天是塑料) 上均匀粘上铁磁性颗粒</li><li>只需要一个机械部件 (转动) 定位<ul><li>读取：放大感应电流</li><li>写入：电磁头 (电磁铁) 改变磁畴磁化方向</li></ul></li></ul><h3 id="磁带：作为存储设备的分析">磁带：作为存储设备的分析</h3><blockquote><p>成本与风险</p></blockquote><table><thead><tr><th>价格</th><th>容量</th><th>可靠性</th></tr></thead><tbody><tr><td>低 - 廉价材料</td><td>高</td><td>存在机械部件、存在丢失风险</td></tr></tbody></table><blockquote><p>读写性能</p></blockquote><table><thead><tr><th>顺序读写</th><th>随机读写</th></tr></thead><tbody><tr><td>勉强 (需要等待定位)</td><td>几乎完全不行</td></tr></tbody></table><blockquote><p>今天的应用场景</p></blockquote><ul><li>冷数据的存档和备份</li></ul><h3 id="磁鼓-Magnetic-Drum-1932">磁鼓 (Magnetic Drum, 1932)</h3><blockquote><p>1D → 1.5D (1D x 𝑛)</p></blockquote><ul><li>用旋转的二维平面存储数据 (无法内卷，容量变小)</li><li>读写延迟不会超过旋转周期 (随机读写速度大幅提升)</li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c25-2-1.webp" alt="c25-2-1.webp"></p><h3 id="疯狂内卷：磁盘-Hard-Disk-1956">疯狂内卷：磁盘 (Hard Disk, 1956)</h3><blockquote><p>1.5D → 2.5D (2D x n)</p></blockquote><ul><li>在二维平面上放置许多磁带</li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c25-2-2.webp" alt="c25-2-2.webp"></p><h3 id="磁盘：克服各种工程挑战">磁盘：克服各种工程挑战</h3><p><img src="https://cdn-img-el3.pages.dev/os/c25-2-3.webp" alt="c25-2-3.webp"></p><p><img src="https://cdn-img-el3.pages.dev/os/c25-2-4.webp" alt="c25-2-4.webp"></p><h3 id="磁盘：作为存储设备的分析">磁盘：作为存储设备的分析</h3><blockquote><p>成本与风险</p></blockquote><table><thead><tr><th>价格</th><th>容量</th><th>可靠性</th></tr></thead><tbody><tr><td>低 - 高密度低成本</td><td>高 - 2.5D，上万磁道</td><td>存在机械部件</td></tr></tbody></table><blockquote><p>读写性能</p></blockquote><table><thead><tr><th>顺序读写</th><th>随机读写</th></tr></thead><tbody><tr><td>较高</td><td>勉强 (需要等待定位)</td></tr></tbody></table><blockquote><p>今天的应用场景</p></blockquote><ul><li>计算机系统的主力数据存储<ul><li>我们的服务器：4 x 4TB HDD (RAID0)</li></ul></li></ul><h3 id="磁盘：性能调优">磁盘：性能调优</h3><blockquote><p>为了读/写一个扇区</p></blockquote><ul><li>读写头需要到对应的磁道<ul><li>7200rpm → 120rps → “寻道” 时间 8.3ms</li></ul></li><li>转轴将盘片旋转到读写头的位置<ul><li>读写头移动时间通常也需要几个 ms</li></ul></li></ul><blockquote><p>通过缓存/调度等缓解</p></blockquote><ul><li>例如著名的 “电梯” 调度算法<ul><li>成为了历史的尘埃</li></ul></li><li>Advanced Host Controller Interface (AHCI); Native Command Queuing (NCQ)</li></ul><h3 id="软盘-Floppy-Disk-1971">软盘 (Floppy Disk, 1971)</h3><blockquote><p>把读写头和盘片分开——实现数据移动</p></blockquote><ul><li>计算机上的软盘驱动器 (drive) + 可移动的盘片<ul><li>8&quot; (1971), 5.25&quot; (1975), 3.5&quot; (1981)<ul><li>最初的软盘成本很低，就是个纸壳子</li><li>3.5 英寸软盘为了提高可靠性，已经是 “硬” 的了</li></ul></li></ul></li></ul><h3 id="软盘：作为存储设备的分析">软盘：作为存储设备的分析</h3><blockquote><p>成本与风险</p></blockquote><table><thead><tr><th>价格</th><th>容量</th><th>可靠性</th></tr></thead><tbody><tr><td>低 - 低成本材料</td><td>高 - 裸露介质，密度受限</td><td>低</td></tr></tbody></table><blockquote><p>读写性能</p></blockquote><table><thead><tr><th>顺序读写</th><th>随机读写</th></tr></thead><tbody><tr><td>低</td><td>低</td></tr></tbody></table><blockquote><p>今天的应用场景</p></blockquote><ul><li>存盘按钮</li></ul><h2 id="坑存储">坑存储</h2><h3 id="坑：天然容易-“阅读”-的数据存储">坑：天然容易 “阅读” 的数据存储</h3><blockquote><p>跨越千年的持久化存储方法</p></blockquote><p><img src="https://cdn-img-el3.pages.dev/os/c25-3-1.webp" alt="c25-3-1.webp"></p><h3 id="Compact-Disk-CD-1980">Compact Disk (CD, 1980)</h3><blockquote><p>在反射平面 (1) 上挖上粗糙的坑 (0)</p></blockquote><ul><li>激光扫过表面，就能读出坑的信息来<ul><li>飞利浦 (碟片) 和索尼 (数字音频) 发明</li><li>~700 MiB，在当时是非常巨大的容量</li></ul></li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c25-3-2.webp" alt="c25-3-2.webp"></p><h3 id="光盘的复制">光盘的复制</h3><p><img src="https://cdn-img-el3.pages.dev/os/c25-3-3.webp" alt="c25-3-3.webp"></p><blockquote><p>挖坑技术的进展</p></blockquote><ul><li>CD (740 MB): 780nm 红外激光</li><li>DVD (4.7 GB): 635nm 红色激光</li><li>Blue Ray (100 GB): 405nm 蓝紫色激光 (仍难逃被淘汰)</li></ul><h3 id="光盘：作为存储设备的分析">光盘：作为存储设备的分析</h3><blockquote><p>成本与风险</p></blockquote><table><thead><tr><th>价格</th><th>容量</th><th>可靠性</th></tr></thead><tbody><tr><td>极低 - “压盘” 复制</td><td>高</td><td>高 - 多种保护层</td></tr></tbody></table><blockquote><p>读写性能</p></blockquote><table><thead><tr><th>顺序读取</th><th>随机读取</th></tr></thead><tbody><tr><td>一般</td><td>低</td></tr></tbody></table><blockquote><p>最大的困难：挖坑容易填坑难</p></blockquote><ul><li>CD/R: 用激光器烧出一次性的坑 + append-only 数据结构</li><li>CD/RW: PCM (Phase-change Material)</li></ul><blockquote><p>今天的应用场景</p></blockquote><ul><li>作为数字收藏</li></ul><h2 id="电存储">电存储</h2><h3 id="Solid-State-Drive-1991">Solid State Drive (1991)</h3><blockquote><p>之前的持久存储介质都有致命的缺陷</p></blockquote><ul><li>磁：机械部件导致 ms 级延迟</li><li>坑 (光): 一旦挖坑，填坑很困难 (CD 是只读的)</li></ul><blockquote><p>密度和速度：光速运行的电路才是终极解决方案</p></blockquote><ul><li>Flash Memory “闪存”</li><li>如何在电路中持久 1-bit？<ul><li>挖个坑</li><li>把电子填进去 = 一个状态</li><li>把电子放跑 = 另一个状态</li></ul></li></ul><h3 id="1-Bit-Flash-Memory">1-Bit Flash Memory</h3><p><img src="https://cdn-img-el3.pages.dev/os/c25-4-1.webp" alt="c25-4-1.webp"></p><h3 id="Flash-Memory-几乎全是优点">Flash Memory: 几乎全是优点</h3><table><thead><tr><th>价格</th><th>容量</th><th>可靠性</th></tr></thead><tbody><tr><td>低 - 大规模集成电路</td><td>极高</td><td>高 - 随便摔</td></tr></tbody></table><table><thead><tr><th>顺序读取</th><th>随机读取</th></tr></thead><tbody><tr><td>极高</td><td>极高</td></tr></tbody></table><blockquote><p>极为离谱的优点：电路的大规模并行</p></blockquote><ul><li>容量越大，速度越快，快到 SATA 接口根本无法承受</li></ul><blockquote><p>但有一个意想不到的致命缺点</p></blockquote><ul><li>和上面的电路有关</li></ul><h3 id="Wear-Out">Wear Out</h3><blockquote><p>放电 (erase) 做不到 100% 放干净</p></blockquote><ul><li>放电数千/数万次以后，就好像是 “充电” 状态了</li><li>Dead cell; “wear out”</li></ul><blockquote><p>有没有感觉有点害怕？</p></blockquote><ul><li>很多文件应该写了上千次了？</li></ul><h3 id="USB-Flash-Disk-1999">USB Flash Disk (1999)</h3><p><img src="https://cdn-img-el3.pages.dev/os/c25-4-2.webp" alt="c25-4-2.webp"></p><blockquote><p>容量大、速度快、相当便宜</p></blockquote><ul><li>很快就取代了软盘，成为了人手 𝑛 个的存储介质<ul><li>Compact Flash (CF, 1994)</li><li>USB Flash Disk (1999, “朗科”)</li></ul></li><li>“可移动” 特性<ul><li>存储个人文档</li><li>内容 (系统) 分发</li></ul></li></ul><h3 id="Flash-Disk-与-NAND-Flash">Flash Disk 与 NAND Flash</h3><blockquote><p>优盘, SD 卡, SSD 都是 NAND Flash</p></blockquote><ul><li>但软件/硬件系统的复杂程度不同，效率/寿命也不同<ul><li>典型的 SSD<ul><li>CPU, on-chip RAM, 缓存, store buffer, 操作系统 …</li><li>寿命: ~1 PiB 数据写入 (~1,000 年寿命)</li></ul></li><li>SD 卡<ul><li>SDHC 标准未规定<ul><li>黑心商家一定会偷工减料</li></ul></li><li>但良心厂家依然有 ARM 芯片</li></ul></li></ul></li></ul><h3 id="优盘和-SSD-的区别">优盘和 SSD 的区别</h3><blockquote><p>软件定义磁盘：SSD 里藏了一个完整的计算机系统</p></blockquote><p><img src="https://cdn-img-el3.pages.dev/os/c25-4-3.webp" alt="c25-4-3.webp"></p><ul><li>FTL: Flash Translation Layer<ul><li>“Wear Leveling”: 用软件使写入变得 “均匀”</li><li>像是 managed runtime (with garbage collection)</li></ul></li></ul><h3 id="Wear-Leveling">Wear Leveling</h3><blockquote><p>再一次，VR 眼镜</p></blockquote><ul><li>Logical block address (LBA) → Physical block address (PBA)</li></ul><blockquote><p>道理简单，实现困难</p></blockquote><ul><li>SSD 的 Page/Block 两层结构<ul><li>Page (读取的最小单位, e.g., 4KB)</li><li>Block (写入的最小单位, e.g., 4MB)</li><li>Read/write amplification (读/写不必要多的内容)</li></ul></li><li>Copy on write</li><li>“VR 眼镜” 本身也需要更新<ul><li>Coding for SSDs</li></ul></li></ul><h3 id="FTL-带来的性能、可靠性、安全性问题">FTL 带来的性能、可靠性、安全性问题</h3><blockquote><p>曾经：修电脑引发的血案？</p></blockquote><ul><li>(快速) 格式化是没用的<ul><li>mmap.mmap(fd, prot=PROT_READ, length=2**40)</li><li>我们有一个 “数据恢复” 实验</li></ul></li></ul><blockquote><p>SSD: 似乎不妙？</p></blockquote><ul><li>Copy-on-write 意味着旧的数据还在！<ul><li>logic block 被覆盖，physical block 依然存储了数据</li></ul></li><li>文件系统加密/Self-Encrypting Drive<ul><li>安全带来的缺点：数据就真的无法恢复了</li></ul></li></ul><h3 id="SSD-的可靠性：另一个故事">SSD 的可靠性：另一个故事</h3><blockquote><p>什么？硬件里的软件？</p></blockquote><ul><li>其实非常复杂：算法, cache; store buffer; …</li></ul><blockquote><p>谁写出来的？那可得有 bug 啊！</p></blockquote><ul><li>让我们好好构造疯狂的 workloads，把它弄挂吧！</li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c25-4-4.webp" alt="c25-4-4.webp"></p><p><em>无论是内存还是持久存储，最终胜出的仍然是电——它的密度和速度是其他介质难以比拟的。但同时我们也看到，NAND Flash 作为持久存储时有着巨大的缺陷——写入寿命。但我们也看到了工业界竟然敢于试制这样跨时代的产品，在十多年的争议中终究成为了今天存储的主角。如果更快的 non-volatile memory 到来又退场，我们的计算机系统是否会发生翻天覆地的变化？</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15. 进程的地址空间</title>
      <link href="/2024/06/27/OS/class15/"/>
      <url>/2024/06/27/OS/class15/</url>
      
        <content type="html"><![CDATA[<h2 id="进程的地址空间">进程的地址空间</h2><h3 id="一个很基本-但也很困难-的问题">一个很基本 (但也很困难) 的问题</h3><blockquote><p>进程的状态机模型</p></blockquote><ul><li>进程状态 = 内存 + 寄存器</li><li>到底什么是 “进程的内存”？</li></ul><blockquote><ol><li>以下程序的 (可能) 输出是什么？</li></ol></blockquote><p><code>printf(&quot;%p\n&quot;, main);</code></p><blockquote><ol start="2"><li>何种指针访问不会引发segmentation fault?</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char *p = random();</span><br><span class="line">*p;  // Load</span><br><span class="line">*p = 1; // Store</span><br></pre></td></tr></table></figure><h3 id="进程的地址空间-2">进程的地址空间</h3><blockquote><p>RTFM: /proc/[pid]/maps (man 5 proc)</p></blockquote><ul><li>进程地址空间中的每一段<ul><li>地址 (范围) 和权限 (rwxsp)</li><li>对应的文件: offset, dev, inode, pathname<ul><li>TFM 里有更详细的解释</li></ul></li></ul></li><li>和 readelf (-l) 里的信息互相验证</li></ul><blockquote><p>更多的提问：我们能 “控制” pmap 的输出吗？</p></blockquote><ul><li>修改堆 (bss) 内存的大小</li><li>在栈上分配大数组……</li></ul><h3 id="管理进程地址空间">管理进程地址空间</h3><blockquote><p>状态机的视角</p></blockquote><ul><li>地址空间 = 带访问权限的内存段<ul><li>不存在 (不可访问)</li><li>不存在 (可读/写/执行)</li></ul></li><li>管理 = 增加/删除/修改一段可访问的内存</li></ul><blockquote><p>你会提供怎样的系统调用？</p></blockquote><h3 id="Memory-Map-系统调用">Memory Map 系统调用</h3><blockquote><p>在状态机状态上增加/删除/修改一段可访问的内存</p></blockquote><ul><li>MAP_ANONYMOUS: 匿名 (申请) 内存</li><li>fd: 把文件 “搬到” 进程地址空间中 (例子：加载器)</li><li>更多的行为请参考手册 (复杂性暴增)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 映射</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">           <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改映射权限</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mprotect</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot)</span>;</span><br></pre></td></tr></table></figure><h3 id="使用-mmap">使用 mmap</h3><blockquote><p>Example 1: 申请大量内存空间</p></blockquote><ul><li>瞬间完成内存分配<ul><li>mmap/munmap 为 malloc/free 提供了机制</li><li>libc 的大 malloc 会直接调用一次 mmap 实现</li></ul></li><li>不妨 strace/gdb 看一下</li></ul><blockquote><p>Example 2: Everything is a file</p></blockquote><ul><li>映射大文件、只访问其中的一小部分</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/dev/sda&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    mm = mmap.mmap(fp.fileno(),</span><br><span class="line">                   prot=mmap.PROT_READ, length=<span class="number">128</span> &lt;&lt; <span class="number">30</span>)</span><br><span class="line">    hexdump.hexdump(mm[:<span class="number">512</span>])</span><br></pre></td></tr></table></figure><h2 id="入侵进程地址空间">入侵进程地址空间</h2><h3 id="Hacking-Address-Spaces">Hacking Address Spaces</h3><blockquote><p>进程 (状态机) 在 “无情执行指令机器” 上执行</p></blockquote><ul><li>状态机是一个封闭世界</li><li>但如果允许一个进程对其他进程的地址空间有访问权？<ul><li>意味着可以任意改变另一个程序的行为</li></ul></li></ul><blockquote><p>一些 “入侵” 进程地址空间的例子</p></blockquote><ul><li>调试器 (gdb)<ul><li>gdb 可以任意观测和修改程序的状态</li></ul></li><li>Profiler (perf)<ul><li>M3 中借助它理解程序的性能瓶颈</li></ul></li></ul><h3 id="物理入侵进程地址空间">物理入侵进程地址空间</h3><blockquote><p>金手指：直接物理劫持内存</p></blockquote><ul><li>听起来很离谱，但 “卡带机” 时代的确可以做到！</li><li>今天我们有 Debug Registers 和 Intel Processor Trace</li><li>帮助系统工具 “合法入侵” 地址空间</li></ul><blockquote><p>Game Genie: 一个 Look-up Table (LUT)</p></blockquote><p><img src="https://cdn-img-el3.pages.dev/os/c15-2-1.webp" alt="c15-2-1.webp"></p><ul><li>简单、优雅：当 CPU 读地址 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 时读到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>，则替换为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><ul><li>Technical Notes (专利, How did it work?)</li></ul></li></ul><blockquote><p>Game Genie as a Firmware</p></blockquote><ul><li>配置好 LUT、加载卡带上的代码 (像是一个 “Boot Loader”)</li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c15-2-2.webp" alt="c15-2-2.webp"></p><h3 id="随着游戏越来越大……">随着游戏越来越大……</h3><blockquote><p>地址空间那么大，哪个才是 “金钱”？</p></blockquote><ul><li>包含动态分配的内存，每次地址都不一样</li><li>思路：Everything is a state machine<ul><li>观察状态机的 trace，就知道哪个是金钱了</li></ul></li></ul><blockquote><p>查找 + Filter</p></blockquote><ul><li>进入游戏时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mo>=</mo><mn>4950</mn></mrow><annotation encoding="application/x-tex">exp=4950</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4950</span></span></span></span><br>打了个怪<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mo>=</mo><mn>5100</mn></mrow><annotation encoding="application/x-tex">exp=5100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5100</span></span></span></span><br>符合<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4950</mn><mo>→</mo><mn>5100</mn></mrow><annotation encoding="application/x-tex">4950→5100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4950</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5100</span></span></span></span>变化的内存地址是很少的<ul><li>好了，出门就是满级了</li></ul></li></ul><h3 id="入侵进程地址空间：金山游侠">入侵进程地址空间：金山游侠</h3><blockquote><p>一招制胜</p></blockquote><ul><li>包含非常贴心的 “游戏内呼叫” 功能 (Hack DirectX)</li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c15-2-3.webp" alt="c15-2-3.webp"></p><ul><li>它就是专为游戏设计的 “调试器”</li></ul><h2 id="给进程发送-GUI-事件">给进程发送 GUI 事件</h2><h3 id="按键精灵">按键精灵</h3><blockquote><p>大量重复固定的任务 (例如 2 秒 17 枪)</p></blockquote><p><img src="https://cdn-img-el3.pages.dev/os/c15-3-1.webp" alt="c15-3-1.webp"></p><h3 id="现按键精灵">现按键精灵</h3><blockquote><p>给进程发送键盘/鼠标事件</p></blockquote><ul><li>做个驱动 (可编程键盘/鼠标)</li><li>利用操作系统/窗口管理器提供的 API<ul><li>xdotool<ul><li>(我们用这玩意测试 vscode 的插件)</li></ul></li><li>ydotool</li><li>evdev (按键显示脚本；主播常用)</li></ul></li></ul><blockquote><p>2024 年的应用：实现 AI Copilot Agent</p></blockquote><ul><li>文本/截图 → AI 分析 → 执行动作</li></ul><h2 id="改变进程对时间的感知">改变进程对时间的感知</h2><h3 id="调整游戏的逻辑更新速度">调整游戏的逻辑更新速度</h3><blockquote><p>比如<a href="https://baike.baidu.com/item/%E5%8F%B0%E6%B9%BE%E5%A4%A9%E5%A0%82%E9%B8%9F%E8%B5%84%E8%AE%AF%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8/8443017">神秘公司</a>神秘游戏慢到难以忍受的跑图和战斗</p></blockquote><ul><li>今天游戏市场已经内卷到新手成长路线不顺滑就会被喷了</li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c15-4-1.webp" alt="c15-4-1.webp"></p><h3 id="变速齿轮">变速齿轮</h3><p><img src="https://cdn-img-el3.pages.dev/os/c15-4-2.webp" alt="c15-4-2.webp"></p><h3 id="变速齿轮：原理">变速齿轮：原理</h3><blockquote><p>程序 = 状态机</p></blockquote><ul><li>“计算指令” 是不能感知时间的<ul><li>spin count 计时会出现 “机器变快，游戏没法玩” 的情况</li><li>syscall 是感知时间的唯一方法</li></ul></li></ul><blockquote><p>“劫持” 和时间相关的syscall/库函数</p></blockquote><ul><li>改变程序对时间的认知</li><li>就像手表调快/慢了一样</li></ul><h3 id="定制游戏外挂">定制游戏外挂</h3><blockquote><p>“劫持代码” 的本质是 debugger 行为</p></blockquote><ul><li>游戏也是程序，也是状态机</li><li>外挂就是 “为这个游戏专门设计的 gdb”</li></ul><blockquote><p>例子：锁定生命值</p></blockquote><ul><li><p>创建，线程 spin modify:<br><code>while (1) hp = 9999;</code></p></li><li><p>但还是可能出现 hp &lt; 0 的判定 (一刀秒)</p></li><li><p>可以 patch 掉判定的代码 (软件动态更新)</p></li></ul><h3 id="代码注入">代码注入</h3><blockquote><p>用一段代码 “勾住” (hook) 函数的执行</p></blockquote><ul><li>然后就可以入侵程序逻辑 (从而为所欲为) 了</li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c15-4-3.gif" alt="c15-4-3.gif"></p><h3 id="关于外挂-代码注入">关于外挂/代码注入</h3><blockquote><p>也可以用来做 “好” 的事情</p></blockquote><ul><li>“软件动态更新”：在不停止系统的时候打热补丁 Live kernel patching<ul><li><p>技术，无论是计算机系统、编程语言还是人工智能，都是给人类带来福祉的——我们甚至可以开发游戏外挂辅助你练习、提高成绩。</p></li><li><p>与此同时，强大的技术总有 “负面” 的用途。用任何技术损害他人的利益，都是一件可耻的事情 (academic integrity)。同样，如果你希望在人生这场 game (博弈) 中走得更远。</p></li></ul></li></ul><p><em>状态机的视角自然地将我们引入 “内存到底是什么” 的问题——它的答案同样也很自然：带有访问权限控制的连续内存段。我们可以通过 mmap、munmap、mprotect 三个系统调用调整状态机的地址空间，包括分配匿名的内存、映射文件内容到内存、修改访问权限等。更有趣的是操作系统有 “能够实现一切应用程序” 的需求，调试器也不在话下——这也给了我们入侵其他进程地址空间的机制。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14. 操作系统上的进程</title>
      <link href="/2024/06/21/OS/class14/"/>
      <url>/2024/06/21/OS/class14/</url>
      
        <content type="html"><![CDATA[<h2 id="第一个进程">第一个进程</h2><h3 id="回顾：进程-状态机">回顾：进程 = 状态机</h3><blockquote><p>编译器：C 状态机 → 汇编状态机的翻译器</p></blockquote><ul><li>特殊的指令/函数：syscall</li><li>我们同样可以建模 (模拟) 进程的执行</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">StateMachine</span><span class="params">()</span>:</span><br><span class="line">    b = sys_read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        sys_write(<span class="string">&#x27;I got a zero.&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sys_write(<span class="string">&#x27;I got a one.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    sys_spawn(StateMachine)</span><br></pre></td></tr></table></figure><h3 id="操作系统的启动">操作系统的启动</h3><blockquote><p>Firmware 阶段</p></blockquote><ul><li>CPU Reset 后，Firmware 代码开始执行</li><li>加载操作系统</li></ul><blockquote><p>操作系统初始化阶段</p></blockquote><ul><li>操作系统扫描系统中的硬件、初始化数据结构……</li><li>加载第一个进程 (状态机)</li></ul><blockquote><p>操作系统执行阶段</p></blockquote><ul><li>状态机在 CPU 上执行</li><li>允许执行 <code>syscall</code> 进入操作系统代码</li></ul><h3 id="进程的创建">进程的创建</h3><blockquote><p>我们能控制这个行为吗？</p></blockquote><ul><li>计算机系统没有魔法</li><li>你能想到的事就能实现</li></ul><blockquote><p>人工智能就能帮你实现</p></blockquote><ul><li>我希望用 QEMU 在给定的 Linux 内核完成初始化后，直接执行我自己编写的一个 hello 二进制文件。我应该怎么做？</li><li>在这个过程中，发散出很多概念 → 知识体系的快速建立</li></ul><p><em>恰恰是 UNIX “干净” 的设计 (完成初始化后将控制权移交给第一个进程) 使得 Linus 可以在可控的工程代价下实现 (相当完善的) POSIX 兼容，从而掀起一场操作系统的革命。时至今日，实现接口级的兼容已经是一件极为困难的工程问题，典型的例子是微软的工程师最终抛弃了 API 行为兼容的 Windows Subsystem for Linux 1.0，进而转向了虚拟机上运行的 Linux 内核。</em></p><p><em>整个 Linux 的 “世界” 都是从这个进程开始，并通过一系列实现进程管理的操作系统 API 创建的。</em></p><h2 id="创建新进程">创建新进程</h2><h3 id="创建状态机">创建状态机</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>现在我们已经有 “一个状态机” 了</p></blockquote><ul><li>只需要 “创建状态机” 的 API 即可</li><li>UNIX 的答案: fork<ul><li>做一份状态机完整的复制 (内存、寄存器现场)</li></ul></li></ul><h3 id="fork-的行为">fork() 的行为</h3><blockquote><p>立即复制状态机</p></blockquote><ul><li>包括所有信息的完整拷贝<ul><li>每一个字节的内存</li><li>打开的文件 (共享)</li><li>……</li><li>复制失败返回 -1<ul><li>errno 会返回错误原因 (man fork)</li></ul></li></ul></li></ul><blockquote><p>如何区分两个状态机？</p></blockquote><ul><li>新创建进程返回 0</li><li>执行 fork 的进程返回子进程的进程号</li></ul><h3 id="Fork-Bomb">Fork Bomb</h3><blockquote><p>新建状态机需要资源</p></blockquote><ul><li>只要不停地创建进程，系统还是会挂掉的</li></ul><h3 id="代码解析-Fork-Bomb">代码解析: Fork Bomb</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">:()&#123;:|:&amp;&#125;;:   # 刚才的一行版本</span><br><span class="line"></span><br><span class="line">:() &#123;         # 格式化一下</span><br><span class="line">  : | : &amp;</span><br><span class="line">&#125;; :</span><br><span class="line"></span><br><span class="line">f() &#123;      <span class="meta"># bash: 允许冒号作为 identifier</span></span><br><span class="line">  f | f &amp;</span><br><span class="line">&#125;</span><br><span class="line">f</span><br></pre></td></tr></table></figure><ul><li>类比原子弹：一个重原子核 (U-235/Pu-239) 被中子击中后分裂成两个较轻的原子核，同时释放出能量和更多的中子<ul><li>“自我增殖”</li></ul></li></ul><blockquote><p>进程总有 “被创建” 的关系</p></blockquote><ul><li>因此总能找到 “父子关系”</li><li>因此有了进程树 (pstree)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">systemd-+-ModemManager--<span class="number">-2</span>*[&#123;ModemManager&#125;]</span><br><span class="line">        |-NetworkManager--<span class="number">-2</span>*[&#123;NetworkManager&#125;]</span><br><span class="line">        |-accounts-daemon--<span class="number">-2</span>*[&#123;accounts-daemon&#125;]</span><br><span class="line">        |-at-spi-bus-laun-+-dbus-daemon</span><br><span class="line">        |                 `<span class="number">-3</span>*[&#123;at-spi-bus-laun&#125;]</span><br><span class="line">        |-at-spi2-registr--<span class="number">-2</span>*[&#123;at-spi2-registr&#125;]</span><br><span class="line">        |-atd</span><br><span class="line">        |-avahi-daemon---avahi-daemon</span><br><span class="line">        |-colord--<span class="number">-2</span>*[&#123;colord&#125;]</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><h2 id="运行可执行文件">运行可执行文件</h2><h3 id="如何运行可执行程序？">如何运行可执行程序？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, </span></span><br><span class="line"><span class="params">           <span class="type">char</span> * <span class="type">const</span> argv[], <span class="type">char</span> * <span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure><blockquote><p>UNIX 的答案: execve (重置状态机)</p></blockquote><ul><li>将当前进程重置成一个可执行文件描述状态机的初始状态</li></ul><blockquote><p>execve 行为</p></blockquote><ul><li>执行名为 filename 的程序</li><li>允许对新状态机设置参数 argv (v) 和环境变量 envp (e)<ul><li>刚好对应了 main() 的参数！</li></ul></li><li>execve 是唯一能够 “执行程序” 的系统调用<ul><li>因此也是一切进程 strace 的第一个系统调用</li></ul></li></ul><h3 id="fork-execve">fork() + execve()</h3><blockquote><p>UNIX 中实现 “创建新状态机” 的方式</p></blockquote><ul><li>Spawn = fork + execve</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fork&quot;</span>); <span class="keyword">goto</span> fail;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Child</span></span><br><span class="line">    execve(...);</span><br><span class="line">    perror(<span class="string">&quot;execve&quot;</span>); <span class="keyword">goto</span> fail;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Parent</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环境变量">环境变量</h3><blockquote><p>“应用程序执行的环境”</p></blockquote><ul><li>使用 env 命令查看<ul><li>PATH: 可执行文件搜索路径</li><li>PWD: 当前路径</li><li>HOME: home 目录</li><li>DISPLAY: 图形输出</li><li>PS1: shell 的提示符</li></ul></li><li>export: 告诉 shell 在创建子进程时设置环境变量<ul><li>小技巧：export ARCH=x86_64-qemu 或 export ARCH=native</li></ul></li></ul><h3 id="环境变量：PATH">环境变量：PATH</h3><blockquote><p>可执行文件搜索路径</p></blockquote><ul><li>还记得 gcc 的 strace 结果吗？</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[pid 28369] execve(<span class="string">&quot;/usr/local/sbin/as&quot;</span>, [<span class="string">&quot;as&quot;</span>, <span class="string">&quot;--64&quot;</span>, ...</span><br><span class="line">[pid 28369] execve(<span class="string">&quot;/usr/local/bin/as&quot;</span>, [<span class="string">&quot;as&quot;</span>, <span class="string">&quot;--64&quot;</span>, ...</span><br><span class="line">[pid 28369] execve(<span class="string">&quot;/usr/sbin/as&quot;</span>, [<span class="string">&quot;as&quot;</span>, <span class="string">&quot;--64&quot;</span>, ...</span><br><span class="line">[pid 28369] execve(<span class="string">&quot;/usr/bin/as&quot;</span>, [<span class="string">&quot;as&quot;</span>, <span class="string">&quot;--64&quot;</span>, ...</span><br></pre></td></tr></table></figure><ul><li>这个搜索顺序恰好是 PATH 里指定的顺序</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ PATH=<span class="string">&quot;&quot;</span> /usr/bin/gcc a.c</span><br><span class="line">gcc: error trying to <span class="built_in">exec</span> <span class="string">&#x27;as&#x27;</span>: execvp: No such file or directory</span><br><span class="line">$ PATH=<span class="string">&quot;/usr/bin/&quot;</span> gcc a.c</span><br></pre></td></tr></table></figure><p><strong>计算机系统里没有魔法。机器永远是对的。</strong></p><h2 id="退出程序">退出程序</h2><h3 id="状态机管理：销毁状态机">状态机管理：销毁状态机</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status); </span><br></pre></td></tr></table></figure><blockquote><p>fork + exec = 自由执行任何程序</p></blockquote><ul><li>还差一个销毁状态机的函数就完整了</li><li>UNIX 的答案: _exit<ul><li>立即摧毁状态机，允许有一个返回值</li></ul></li><li>子进程终止会通知父进程 (后续课程解释)</li></ul><blockquote><p>这个简单……</p></blockquote><ul><li>但问题来了：多线程程序怎么办？</li></ul><h3 id="结束程序执行的三种方法">结束程序执行的三种方法</h3><blockquote><p>exit 的几种写法 (它们是不同)</p></blockquote><ul><li>exit(0)<ul><li>会调用 atexit</li></ul></li><li>_exit(0)<ul><li>执行 “exit_group” 系统调用终止整个进程 (所有线程)</li><li>会调用 atexit 吗？</li></ul></li><li>syscall(SYS_exit, 0)<ul><li>执行 “exit” 系统调用终止当前线程</li><li>会调用 atexit 吗？</li></ul></li></ul><p><em>因为 “程序 = 状态机”，操作系统上进程 (运行的程序) 管理的 API 很自然地就是状态机的管理。在 UNIX/Linux 世界中，以下三个系统调用创建了整个 “进程世界”，不论是我们常用的 IDE 和浏览器，还是编译时在后台调用的 gcc。其中，fork 对当前状态机状态进行完整复制，execve 将当前状态机状态重置为某个可执行文件描述的状态机，exit: 销毁当前状态机。在对这个概念有了绝对正确且绝对严谨的理解后，操作系统也就显得不那么神秘了。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于对js闭包与防抖的理解</title>
      <link href="/2024/06/20/programming/Closure_and_anti-shake/"/>
      <url>/2024/06/20/programming/Closure_and_anti-shake/</url>
      
        <content type="html"><![CDATA[<h2 id="Js内存回收机制">Js内存回收机制</h2><h3 id="什么是内存回收？">什么是内存回收？</h3><p>垃圾回收是指自动释放不再使用的内存。程序在运行时会动态分配内存，但并不是所有被分配的内存都会一直被使用。垃圾回收器的任务就是识别那些不再被使用的内存，并将其释放回系统，以便其他进程可以使用。</p><blockquote><p>标记清除（Mark-Sweep）</p></blockquote><ol><li><p>当函数被调用时，一个新的执行上下文（Execution Context）被创建，变量和参数被创建并加入到这个环境中。这个过程称为变量进入环境。</p></li><li><p>每个执行上下文都有自己的作用域链，它决定了变量和函数的可见性。作用域链从当前上下文开始，向上遍历至全局上下文。</p></li><li><p>变量的生命周期从它被创建开始，直到它离开作用域。在变量的生命周期内，它可以被代码访问和使用。</p></li><li><p>当一个执行上下文被销毁，比如函数执行完毕，这个上下文中的变量就被认为是“离开环境”。此时，这些变量不再被代码所引用。</p></li><li><p>一旦变量离开环境并且没有任何外部引用指向它们，它们就成为垃圾回收器的候选对象。垃圾回收器会定期检查这些无用的对象，并释放它们占用的内存。</p></li><li><p>如果一个变量在离开环境后仍然被某些引用所持有，它就不会被回收。例如，如果一个变量被赋予给一个全局变量或者被一个闭包捕获，那么即使它已经离开了原始作用域，它也不会被回收。</p></li><li><p>如果变量在离开环境后仍然被引用，但这些引用不再被需要，就会发生内存泄漏。这种情况下，即使变量不再使用，它们占用的内存也不会被释放。</p></li><li><p>垃圾回收不是在变量离开环境的瞬间立即发生的。垃圾回收器会根据一定的算法和策略来决定何时进行回收，以减少对程序性能的影响。</p></li></ol><blockquote><p>引用计数 (Reference Counting)</p></blockquote><ol><li><p>引用计数是一种自动内存管理技术，它为每个值（对象）维护一个计数器，记录该值被引用的次数。</p></li><li><p>当一个新变量被声明并赋值为一个引用类型时，该引用类型的引用计数加1。例如，var obj = new Object();此时，obj指向的对象的引用计数为1。</p></li><li><p>当一个变量被赋予新值或被删除时，它原来引用的对象的引用计数减1。例如，var obj2 = new Object(); obj = obj2;此时，原始对象的引用计数减1（如果之前没有其他引用指向它），而obj2指向的对象的引用计数加1。</p></li><li><p>当一个对象的引用计数降到0时，意味着没有任何变量引用这个对象，它所占用的内存可以被垃圾收集器回收。</p></li></ol><h3 id="内存溢出">内存溢出</h3><p>内存溢出一般是指执行程序时，程序会向系统申请一定大小的内存，当系统现在的实际内存少于需要的内存时，就会造成内存溢出，内存溢出造成的结果是先前保存的数据会被覆盖或者后来的数据会没地方存。</p><h3 id="内存泄露">内存泄露</h3><p>内存泄漏是指程序执行时，一些变量没有及时释放，一直占用着内存而这种占用内存的行为就叫做内存泄漏。作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积。</p><h2 id="闭包">闭包</h2><p>闭包在编程中解决了许多问题，主要包括：</p><p><strong>数据封装：</strong> 闭包允许将数据和操作这些数据的函数封装在一起，形成一个独立的模块，避免了全局变量的滥用。</p><p><strong>持久化状态：</strong> 闭包可以保持函数执行后的状态，使得函数可以记住并访问其创建时的环境状态，即使在原始上下文之外被调用。</p><p><strong>私有变量：</strong> 由于JavaScript不支持传统的私有变量概念，闭包可以用来创建私有变量，保护数据不被外部直接访问。</p><p><strong>函数记忆：</strong> 闭包可以用于记忆化技术，即缓存函数的计算结果，避免重复计算，提高性能。</p><p><strong>延迟计算和资源管理：</strong> 闭包可以在需要时才执行计算，实现延迟执行的效果，同时在异步操作完成后进行资源管理。</p><p><strong>柯里化：</strong> 闭包可以用于实现柯里化，即将一个多参数的函数转换成多个单参数的函数，每个单参数函数返回下一个参数的函数。</p><p><strong>高阶函数：</strong> 闭包使得JavaScript可以轻松实现高阶函数，即函数可以接受其他函数作为参数或返回函数。</p><p><strong>事件处理：</strong> 在JavaScript中，闭包常用于事件处理，确保事件处理器可以访问正确的上下文和状态。</p><p><strong>异步编程：</strong> 在JavaScript的异步编程模式中，闭包可以保持回调函数的上下文，确保在异步操作完成后能够访问到正确的变量和状态。</p><p><strong>模块化：</strong> 闭包有助于实现模块化编程，通过将函数和相关状态封装在一起，形成独立的模块，提高代码的可维护性和可重用性。</p><h3 id="闭包的概念">闭包的概念</h3><p>闭包（Closure）是计算机编程中的一个概念，它指的是一个函数能够记住并访问其创建时的环境的状态，即使这个函数在其原始上下文之外被执行。简单来说，闭包允许一个函数访问创建时的作用域中的变量，即使该函数在其原始作用域之外被调用。</p><h3 id="闭包的使用">闭包的使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">args</span>) &#123;</span><br><span class="line">    args++</span><br><span class="line">    <span class="keyword">return</span> args</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(a) <span class="comment">//11</span></span><br><span class="line"><span class="title function_">test</span>(a) <span class="comment">//11</span></span><br><span class="line"><span class="title function_">test</span>(a) <span class="comment">//11</span></span><br></pre></td></tr></table></figure><p>上述代码中，每次调用 <code>test</code> 函数时， <code>args</code> 都是 <code>a</code> 的一个新副本。当 <code>args</code> 在函数内部被修改时，它并不会影响外部的变量 <code>a</code> 。这就是为什么每次调用 <code>test</code> 函数，传入的 <code>a</code> 值都是原始的 <code>10</code> ，函数内部将其增加 <code>1</code> ，然后返回 <code>11</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">        args++;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> closure = <span class="title function_">test</span>(); <span class="comment">// 这里创建了一个闭包</span></span><br><span class="line"><span class="title function_">closure</span>(); <span class="comment">// 11</span></span><br><span class="line"><span class="title function_">closure</span>(); <span class="comment">// 12</span></span><br><span class="line"><span class="title function_">closure</span>(); <span class="comment">// 13</span></span><br><span class="line">closure = <span class="literal">null</span>; <span class="comment">// 释放闭包</span></span><br></pre></td></tr></table></figure><p>上述代码中， <code>test</code> 函数内部定义了一个名为 <code>inner</code> 的函数，这个 <code>inner</code> 函数形成了一个闭包。闭包允许 <code>inner</code> 函数访问并操作 <code>test</code> 函数的局部变量 <code>args</code> 。即使 <code>test</code> 函数执行完毕后， <code>inner</code> 函数仍然可以访问 <code>args</code> 变量，因为它被闭包捕获了。最后，我们通过 <code>closure = null</code> 释放了闭包。</p><h2 id="防抖">防抖</h2><h3 id="防抖的概念">防抖的概念</h3><p>防抖（Debouncing）是一种编程技巧，用于控制函数的执行频率。在JavaScript中，防抖机制特别适用于处理诸如窗口调整大小、滚动、连续的按键输入等<strong>频繁触发</strong>的事件。它是一种限制函数执行频率的技术，确保函数在指定的时间间隔后执行一次，即使在这个间隔内有多次触发。</p><h3 id="防抖的使用">防抖的使用</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    input.<span class="property">oninput</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中，我们通过 <code>oninput</code> 事件监听输入框的输入事件。每当用户在输入框中输入内容时，就会在控制台打印输入的内容，这会导致输入框的输入事件被频繁触发。但是我们需要的内容只是用户输入的最终结果，而不是中间过程。所以需要对这段代码进行优化，也就是做防抖处理。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">    input.<span class="property">oninput</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(timer!==<span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">cleaTimeout</span>(timer)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;,<span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中，我们通过 <code>setTimeout</code> 函数来实现防抖。在每次触发输入事件时，都会判断当前是否已经有一个计时器,如果存在，则清除计时器。然后通过 <code>setTimeout</code> 创建一个新的计时器，在指定的时间间隔内执行一次函数。但是这个代码并不优美，不具备可维护性，所以我们可以使用闭包的手段，让这段代码更健壮。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">input.<span class="property">oninput</span> = <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;, <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (timer !== <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="built_in">clearTimeout</span>(timer);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">fn</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125;, delay);</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，我们就可以将防抖函数封装成一个通用函数，在需要的时候直接调用即可。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
            <tag> 防抖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13. 应对 (并发) Bugs</title>
      <link href="/2024/06/17/OS/class13/"/>
      <url>/2024/06/17/OS/class13/</url>
      
        <content type="html"><![CDATA[<h2 id="1-应对死锁">1 应对死锁</h2><h3 id="1-1-死锁：一类-“简单”-的并发-Bug">1.1 死锁：一类 “简单” 的并发 Bug</h3><blockquote><p>具有明确的 Specification</p></blockquote><ul><li>任何线程在 “基本合理” 的调度下，不能失去进展</li></ul><blockquote><p>甚至有明确的必要条件</p></blockquote><ul><li>Mutual-exclusion - 一个口袋一个球，得到球才能继续</li><li>Wait-for - 得到球的人想要更多的球</li><li>No-preemption - 不能抢别人的持有的球</li><li>Circular-chain - 形成循环等待球的关系</li></ul><blockquote><p>Lock ordering: 避免循环等待</p></blockquote><ul><li>严格按照编号顺序获得所有锁</li></ul><h3 id="1-2-死锁：死局">1.2 死锁：死局</h3><blockquote><p>一面是复杂的系统，另一面是不可靠的人</p></blockquote><ul><li>希望<ul><li>标记 “做一件事” 不被打断</li></ul></li><li>实际<ul><li>“做一件事” 需要拆解成多个步骤</li><li>每个步骤需要上正确 (而且尽可能少) 的锁</li></ul></li></ul><blockquote><p>LockDoc (EuroSys’19)</p></blockquote><ul><li>“Only 53 percent of the variables with a documented locking rule are actually consistently accessed with the required locks held.”</li></ul><h2 id="2-应对死局：绝处逢生">2 应对死局：绝处逢生</h2><h3 id="2-1-应对-“死局”：程序员的自救">2.1 应对 “死局”：程序员的自救</h3><blockquote><p>我们可以在运行时检查一切明确的 Specification！</p></blockquote><ul><li>AA/ABBA 型死锁</li><li>数据竞争</li><li>带符号整数溢出 (undefined behavior)</li><li>Use after free</li><li>……</li></ul><blockquote><p>动态程序分析：状态机执行历史的一个函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>τ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(τ)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mclose">)</span></span></span></span></p></blockquote><ul><li>付出程序执行变慢的代价</li><li>找到更多 bugs</li></ul><h3 id="2-2-运行时-Lock-Ordering-检查">2.2 运行时 Lock Ordering 检查</h3><blockquote><p>一个想法</p></blockquote><ul><li>为每一个 acquire/release 记录 tid 和 lock name</li><li>Assert: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(V, E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> 无成环<ul><li>V: 所有的 lock names</li><li>E: 每当观测到持有 𝑢 时获取 v 就把 (𝑢,𝑣) 加入 𝐸</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T1 ACQ a</span><br><span class="line">T1 ACQ b</span><br><span class="line">T1 REL b</span><br><span class="line">T2 ACQ b</span><br><span class="line">T2 REL b</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="2-3-Linux-Kernel-Lockdep">2.3 Linux Kernel Lockdep</h3><blockquote><p>解决锁的 “命名” 问题</p></blockquote><ul><li>可以是锁的地址</li><li>也可以是锁的初始化位置 (更严格；开销更小)<ul><li>The kernel lock validator</li><li>Since Linux Kernel 2.6.17, also in OpenHarmony v1</li></ul></li></ul><blockquote><p>我们有一个山寨实现！</p></blockquote><h3 id="2-4-应对死局：Sanitizers">2.4 应对死局：Sanitizers</h3><blockquote><p>现代复杂软件系统必备的支撑工具</p></blockquote><ul><li>AddressSanitizer (asan); (paper): 非法内存访问<ul><li>Buffer (heap/stack/global) overflow, use-after-free, use-after-return, double-free, …;</li><li>没有 KASAN, Linux Kernel 的质量/安全性直接崩盘</li></ul></li><li>ThreadSanitizer (tsan): 数据竞争<ul><li>KCSAN: Concurrency bugs should fear the big bad</li><li>data-race detector</li></ul></li><li>MemorySanitizer (msan), UBSanitizer (ubsan), …</li><li>SpecSanitizer: 基于 AI/LLM 的 “specification 检查”</li></ul><p><em>没错，在 “有 specification” 的情况下，开发者一定会想到合适的方法检查它们，以提高软件的质量。很显然，C 语言只提供 “底层机制” 的设计，在管理大型复杂项目时捉襟见肘。Linux Kernel 如果没有 ASAN 和 TSAN 机制，将会变得千疮百孔。</em></p><h2 id="3-应对死线-Deadline-：防御性编程">3 应对死线 (Deadline)：防御性编程</h2><blockquote><p>理论很美好，现实很残酷</p></blockquote><ul><li>我们的框架直接运行在虚拟机上<ul><li>根本没法带这些 sanitizers</li><li>试图移植 = 失败</li></ul></li><li>我们根本不可能 “观测每一次共享内存访问”</li></ul><blockquote><p>Full Sanitizer 很难实现</p></blockquote><ul><li>不如换一种思路</li><li>我们可以 “编程”！</li></ul><blockquote><p>Best-effort is better than no-effort!</p></blockquote><ul><li>不实现 “完整” 的检查 (允许存在误报/漏报)</li><li>但实现简单、非常有用——而且有惊喜<ul><li>我们不是一直都在写 assertions 吗？<ul><li>Peterson 算法：<code>assert(nest == 1);</code></li><li>链表：<code>assert(u-&gt;prev-&gt;next == u);</code></li><li>spinlock: <code>if (holding(&amp;lk)) panic();</code></li></ul></li></ul></li></ul><h3 id="3-1-防御性编程：Buffer-Overrun-检查">3.1 防御性编程：Buffer Overrun 检查</h3><blockquote><p>Canary (金丝雀) 对一氧化碳非常敏感</p></blockquote><ul><li>它们用生命预警矿井下的瓦斯泄露 (since 1911)</li></ul><blockquote><p>Canary: “牺牲” 内存单元，预警 memory error</p></blockquote><ul><li>(程序运行时没有动物受到实质的伤害)</li></ul><h3 id="3-2-Canary-的例子：Stack-Guard">3.2 Canary 的例子：Stack Guard</h3><blockquote><p>栈溢出</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAGIC 0x55555555</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOTTOM (STK_SZ / sizeof(u32) - 1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stack</span> &#123;</span> <span class="type">char</span> data[STK_SZ]; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">canary_init</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">stack</span> *s)</span> &#123;</span><br><span class="line">    u32 *ptr = (u32 *)s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CANARY_SZ; i++)</span><br><span class="line">        ptr[BOTTOM - i] = ptr[i] = MAGIC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">canary_check</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">stack</span> *s)</span> &#123;</span><br><span class="line">    u32 *ptr = (u32 *)s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CANARY_SZ; i++) &#123;</span><br><span class="line">        panic_on(ptr[BOTTOM - i] != MAGIC, <span class="string">&quot;underflow&quot;</span>);</span><br><span class="line">        panic_on(ptr[i] != MAGIC, <span class="string">&quot;overflow&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-另一种-Canary">3.3 另一种 Canary</h3><blockquote><p>检测 “缓冲区溢出”</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 一段连续内存；位于局部变量和返回地址之前</span></span><br><span class="line">    u32 canary = SOME_VALUE;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// 实际函数</span></span><br><span class="line"></span><br><span class="line">    canary ^= SOME_VALUE; <span class="comment">// 如果程序被攻击或出错</span></span><br><span class="line">                          <span class="comment">// canary 就不会归零了</span></span><br><span class="line">    assert(canary == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>MSVC 中 Debug Mode 的 guard/fence/canary</p></blockquote><ul><li>未初始化栈: 0xcccccccc</li><li>未初始化堆: 0xcdcdcdcd</li><li>对象头尾: 0xfdfdfdfd</li><li>已回收内存: 0xdddddddd<ul><li>手持两把锟斤拷，口中疾呼烫烫烫</li><li>脚踏千朵屯屯屯，笑看万物锘锘锘</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i in [<span class="number">0xcc</span>, <span class="number">0xcd</span>, <span class="number">0xdd</span>, <span class="number">0xfd</span>]:</span><br><span class="line">    print((bytes([i]) * <span class="number">80</span>).decode(<span class="string">&#x27;gbk&#x27;</span>))</span><br></pre></td></tr></table></figure><h3 id="3-4-防御性编程：低配版-Lockdep">3.4 防御性编程：低配版 Lockdep</h3><blockquote><p>高配版 lockdep 太复杂？</p></blockquote><ul><li>统计当前的 spin count</li><li>如果超过某个明显不正常的数值 (100, 000, 000) 就报告<ul><li>你感觉到 “hang” 了</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> spin_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (xchg(&amp;lk, ❌) == ❌) &#123;</span><br><span class="line">    <span class="keyword">if</span> (spin_cnt++ &gt; SPIN_LIMIT) &#123;</span><br><span class="line">        panic(<span class="string">&quot;Spin limit exceeded @ %s:%d\n&quot;</span>,</span><br><span class="line">            __FILE__, __LINE__);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配合调试器和线程 backtrace 一秒诊断死锁</li></ul><h3 id="3-5-防御性编程：低配版-AddressSanitizer">3.5 防御性编程：低配版 AddressSanitizer</h3><blockquote><p>L1 内存分配器的 specification</p></blockquote><ul><li>已分配内存 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi mathvariant="normal">ℓ</mi><mn>0</mn></msub><mtext>​</mtext><mo separator="true">,</mo><msub><mi>r</mi><mn>0</mn></msub><mtext>​</mtext><mo stretchy="false">)</mo><mo>∪</mo><mo stretchy="false">[</mo><msub><mi mathvariant="normal">ℓ</mi><mn>1</mn></msub><mtext>​</mtext><mo separator="true">,</mo><msub><mi>r</mi><mn>1</mn></msub><mtext>​</mtext><mo stretchy="false">)</mo><mo>∪</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">S=[ℓ_0​, r_0​)∪[ℓ_1​, r_1​)∪…</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord">ℓ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">​</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">​</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord">ℓ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">​</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">​</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.123em;"></span><span class="minner">…</span></span></span></span></li><li>kalloc(𝑠) 返回的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="normal">ℓ</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[ℓ, r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">ℓ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span> 必须满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="normal">ℓ</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo><mo>∩</mo><mi>S</mi><mo>=</mo><mtext>∅</mtext></mrow><annotation encoding="application/x-tex">[ℓ, r)∩S=∅</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">ℓ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">∅</span></span></span></span></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allocation</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; (i + <span class="number">1</span>) * <span class="keyword">sizeof</span>(u32) &lt;= size; i++) &#123;</span><br><span class="line">    panic_on(((u32 *)ptr)[i] == MAGIC, <span class="string">&quot;double-allocation&quot;</span>);</span><br><span class="line">    arr[i] = MAGIC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// free</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; (i + <span class="number">1</span>) * <span class="keyword">sizeof</span>(u32) &lt;= alloc_size(ptr); i++) &#123;</span><br><span class="line">    panic_on(((u32 *)ptr)[i] == <span class="number">0</span>, <span class="string">&quot;double-free&quot;</span>);</span><br><span class="line">    arr[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="防御性编程：低配版-ThreadSanitizer">防御性编程：低配版 ThreadSanitizer</h3><blockquote><p>回顾：数据竞争的表现</p></blockquote><ul><li>🏃 的结果会影响状态</li><li>我们观测状态影响就可以了！</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Suppose x is lock-protected</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> observe1 = x;</span><br><span class="line">delay();</span><br><span class="line"><span class="type">int</span> observe2 = x;</span><br><span class="line"></span><br><span class="line">assert(observe1 == observe2);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="3-6-防御性编程：SemanticSanitizer">3.6 防御性编程：SemanticSanitizer</h3><blockquote><p>两个看似平常的检查</p></blockquote><ul><li>检查整数是否在某个范围</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_INT(x, cond) \</span></span><br><span class="line"><span class="meta">    (&#123; panic_on(!((x) cond), \</span></span><br><span class="line"><span class="meta">       <span class="string">&quot;int check fail: &quot;</span> \</span></span><br><span class="line"><span class="meta">       #x <span class="string">&quot; &quot;</span> #cond); \</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br></pre></td></tr></table></figure><ul><li>检查指针是否位于堆区</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_HEAP(ptr) \</span></span><br><span class="line"><span class="meta">    (&#123; panic_on(!IN_RANGE((ptr), heap)); &#125;)</span></span><br></pre></td></tr></table></figure><blockquote><p>检查内部数据一致性</p></blockquote><ul><li><code>CHECK_INT(waitlist-&gt;count, &gt;= 0);</code></li><li><code>CHECK_INT(pid, &lt; MAX_PROCS);</code></li><li><code>CHECK_HEAP(ctx-&gt;rip); CHECK_HEAP(ctx-&gt;cr3);</code></li></ul><blockquote><p>代入 “变量语义”</p></blockquote><ul><li><p><code>CHECK_INT(count, &gt;= 0);</code></p></li><li><p><code>CHECK_INT(count, &lt;= 10000);</code></p></li><li><p>预防多种错误，甚至部分承担了 AddressSanitizer 的功能</p><ul><li>Overflow, use-after-free 都可能导致 memory corruption</li></ul></li></ul><blockquote><p>短短几行代码，我们实现了</p></blockquote><ul><li>Stack guard</li><li>Lockdep (simple)</li><li>AddressSanitizer (simple)</li><li>ThreadSanitizer (simple)</li><li>SemanticSanitizer</li></ul><blockquote><p>它们是一个种子</p></blockquote><ul><li>指向 “engineering” 里无限的空间</li><li>也指引我们反思编程语言的机制设计</li></ul><p><em>Bugs (包括并发 bugs) 一直以来困扰着所有软件工程的实践者。我们不仅要应对 specification crisis (定义到底什么是对的)，甚至即便知道 specification，也难以应对现代软件的复杂性。为了部分应对这一点从而实现 “更正确” 的软件，我们把对程序的预期表达在程序中 (race-free, lock ordering, …)，而不是让程序在自然状态下悄悄进入有问题的状态，就是我们目前解决程序调试问题的折中办法。“山寨” sanitizer 给我们带来的启发则是：如果我们能清楚地追溯到问题产生的本源，我们就总是能找到好的应对方法——山寨的 sanitizers 在暗中帮助你实现 fail-fast 的程序，从而减轻你调试问题的负担。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12. 并发 Bugs</title>
      <link href="/2024/06/12/OS/class12/"/>
      <url>/2024/06/12/OS/class12/</url>
      
        <content type="html"><![CDATA[<h2 id="1-致命的并发Bugs">1 致命的并发Bugs</h2><blockquote><p>事件级的并发</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Event(doMouseMove) &#123;</span><br><span class="line">    hoveredItem = Item(&quot;$1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    // 被插入的非预期事件</span><br><span class="line">    Event(clickEvent) &#123;</span><br><span class="line">        hoveredItem = Item(&quot;$99&quot;);  // &lt;- Shared state</span><br><span class="line">        Inventory.append(hoveredItem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Event(doPickUp) &#123;</span><br><span class="line">    InHand = hoveredItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Therac-25 Incident (1985-1987)</p></blockquote><ul><li>事件驱动导致的并发 bug，导致至少 6 人死亡</li></ul><blockquote><p>Diablo I 案例再现</p></blockquote><ul><li>选择 X-Ray (High) Mode<ul><li>机器开始移动 mirror，大约需要 8s 完成…</li><li>切换到 Electron (Low) Mode (OK)</li><li>再迅速切换到 X-Ray (High) Mode</li><li>Assertion fail: Malfunction 54; 操作员下意识地按下 Continue……</li></ul></li></ul><blockquote><p>全数字化带来的悲剧</p></blockquote><ul><li>在更早的产品 (Therac-20) 中，assertion fail 会触发电路互锁 (interlock) 直接停机，需要手工重启</li></ul><blockquote><p>问题修复后……</p></blockquote><ul><li>If the operator sent a command at the exact moment the counter overflowed, the machine would skip setting up some of the beam accessories</li></ul><blockquote><p>最终解决方法</p></blockquote><ul><li>独立的硬件安全方案</li><li>检测到大计量照射时直接停机</li></ul><blockquote><p>思考：AI 时代的 “最后防线” 在哪里？</p></blockquote><ul><li>我们会不会从此生活在 AI 为我们生成的幻觉中？</li></ul><p><strong>历史上，还有许多并发性导致的严重事故，包括 2003 年美加大停电，估计经济损失 250 亿—300 亿美元。并发 bug 难捉摸的重要原因之一来自它触发的不确定性，即便经历严格的测试，仍有罕见的调度可能导致连锁反应；直到 2010 年左右，学术界和工业界才对并发系统的正确性开始有了系统性的认识。</strong></p><h2 id="2-死锁">2 死锁</h2><h3 id="2-1-死锁产生的必要条件">2.1 死锁产生的必要条件</h3><blockquote><p>System deadlocks (1971): 把锁看成袋子里的球</p></blockquote><ol><li>Mutual-exclusion - 一个口袋一个球，得到球才能继续</li><li>Wait-for - 得到球的人想要更多的球</li><li>No-preemption - 不能抢别人的持有的球</li><li>Circular-chain - 形成循环等待球的关系</li></ol><blockquote><p>“必要条件”？</p></blockquote><ul><li>打破任何一个条件，就不会发生死锁了</li></ul><blockquote><p>“理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。”</p></blockquote><p><strong>不能称为是一个合理的 argument</strong></p><ul><li>对于玩具系统/模型<ul><li>我们可以直接证明系统是 deadlock-free 的</li></ul></li><li>对于真正的复杂系统<ul><li>哪一个条件最容易打破？</li></ul></li></ul><h3 id="2-2-在实际系统中避免死锁？">2.2 在实际系统中避免死锁？</h3><blockquote><p>Lock ordering</p></blockquote><ul><li>任意时刻系统中的锁都是有限的</li><li>给所有锁编号 (Lock Ordering)<ul><li>严格按照从小到大的顺序获得锁</li></ul></li></ul><blockquote><p>Proof (sketch)</p></blockquote><ul><li>任意时刻，总有一个线程获得 “编号最大” 的锁</li><li>这个线程总是可以继续运行</li></ul><h2 id="3-数据竞争">3 数据竞争</h2><blockquote><p>不同的线程同时访问同一内存，且至少有一个是写。</p></blockquote><ul><li>两个内存访问在 “赛跑”，“跑赢” 的操作先执行</li><li>例子：共享内存上实现的 Peterson 算法</li></ul><blockquote><p>“跑赢” 并没有想象中那么简单</p></blockquote><ul><li>Weak memory model 允许不同观测者看到不同结果</li><li>Since C11: data race is undefined behavior</li></ul><h3 id="3-1-例子">3.1 例子</h3><blockquote><p>Case 1: 上错了锁</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">T_1</span><span class="params">()</span> &#123; spin_lock(&amp;A); sum++; spin_unlock(&amp;A); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">T_2</span><span class="params">()</span> &#123; spin_lock(&amp;B); sum++; spin_unlock(&amp;B); &#125;</span><br></pre></td></tr></table></figure><blockquote><p>Case 2: 忘记上锁</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">T_1</span><span class="params">()</span> &#123; spin_lock(&amp;A); sum++; spin_unlock(&amp;A); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">T_2</span><span class="params">()</span> &#123; sum++; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>不同的线程同时访问同一内存，且至少有一个是写</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait_next_beat</span><span class="params">(<span class="type">int</span> expect)</span> &#123;</span><br><span class="line">    <span class="comment">// This is a spin-wait loop.</span></span><br><span class="line">retry:</span><br><span class="line">    mutex_lock(&amp;lk);</span><br><span class="line">    <span class="comment">// This read is protected by a mutex.</span></span><br><span class="line">    <span class="type">int</span> got = n;</span><br><span class="line">    mutex_unlock(&amp;lk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Case 2: 忘记上锁</span></span><br><span class="line">    <span class="keyword">if</span> (n != expect) <span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实际不是忘记上锁，是用错了变量</li><li>更致命的：bug (error state) 很难触发 “Heisenbugs”</li></ul><blockquote><p>实际系统面临更复杂的情况</p></blockquote><ul><li>“内存” 可以是地址空间中的任何内存<ul><li>可以是全部变量</li><li>可以是堆区分配的变量</li><li>可以是栈</li></ul></li><li>“访问” 可以是任何代码<ul><li>可能发生在你的代码里</li><li>可以发生在框架代码里</li><li>可能是一行你没有读到过的汇编代码</li><li>可能是一条 ret 指令</li></ul></li></ul><h2 id="4-原子性-顺序违反">4 原子性/顺序违反</h2><h3 id="4-1-并发编程的本质困难">4.1 并发编程的本质困难</h3><blockquote><p>人类是 sequential creature</p></blockquote><ul><li>我们只能用 sequential 的方式来理解并发<ul><li>程序分成若干 “块”，每一块看起来都没被打断 (原子)<ul><li>例子：produce → (happens-before) → consume</li></ul></li></ul></li></ul><blockquote><p>并发控制的机制完全是 “后果自负” 的</p></blockquote><ul><li>互斥锁 (lock/unlock) 实现原子性<ul><li>忘记上锁——原子性违反 (Atomicity Violation, AV)</li></ul></li><li>条件变量/信号量 (wait/signal) 实现先后顺序同步<ul><li>忘记同步——顺序违反 (Order Violation, OV)</li></ul></li></ul><p><strong>97% 的非死锁并发 bug 都是原子性或顺序错误</strong></p><h3 id="4-2-原子性违反-Atomicity-Violation">4.2 原子性违反 (Atomicity Violation)</h3><blockquote><p>“ABA”: 代码被别人 “强势插入”</p></blockquote><ul><li>即便分别上锁 (消除数据竞争)，依然是 AV<ul><li>Diablo I 里复制物品的例子</li><li>Therac-25 中 “移动 Mirror + 设置状态”</li></ul></li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c12-4.2-1.webp" alt="c12-4.2-1.webp"></p><h3 id="4-3-顺序违反-Order-Violation">4.3 顺序违反 (Order Violation)</h3><blockquote><p>“BA”: 事件未按预定的顺序发生</p></blockquote><ul><li>例子：concurrent use-after-free</li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c12-4.3-1.webp" alt="c12-4.3-1.webp"></p><p>实际上，“原子性” 一直是并发控制的终极目标。对编程者而言，理想情况是一段代码的执行要么看起来在瞬间全部完成，要么好像完全没有执行过。代码中的副作用：共享内存写入、文件系统写入等，则都是实现原子性的障碍。</p><p>因为 “原子性” 如此诱人，在计算机硬件/系统层面提供原子性的尝试一直都没有停止过：从数据库事务 (transactions, tx) 到软件和硬件支持的 Transactional Memory (“an idea ahead its time”) 到 Operating System Transactions，直到今天我们依然没有每个程序员都垂手可得的可靠原子性保障。</p><p>而保证程序的执行顺序就更困难了。Managed runtime 实现自动内存管理、channel 实现线程间通信等，都是减少程序员犯错的手段。</p><p><em>人类本质上是 sequential creature，因此总是通过 “块的顺序执行” 这一简化模型去理解并发程序，也相应有了两种类型的并发 bugs：</em></p><ul><li>Atomicity violation，本应原子完成不被打断的代码被打断</li><li>Order violation，本应按某个顺序完成的未能被正确同步</li></ul><p><em>与这两类 bugs 关联的一个重要问题是数据竞争，即两个线程同时访问同一内存，且至少有一个是写。数据竞争非常危险，因此我们在编程时要尽力避免。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js前世今生</title>
      <link href="/2024/06/11/JavaScript-ninja/1_/"/>
      <url>/2024/06/11/JavaScript-ninja/1_/</url>
      
        <content type="html"><![CDATA[<blockquote><p>1990年，世界上第一个网页诞生</p></blockquote><p>蒂姆·伯纳斯-李，他是一名计算机科学家，他在1990年发明了万维网，并且没有申请专利。他希望所有人在互联网上分享知识。</p><ul><li><p>需要解决的问题一：语言</p><ul><li>设计一个超文本的实现，html<ul><li>a标签，超链接，锚点ahchor</li></ul></li></ul></li><li><p>需要解决的问题二：数据接受和传输</p><ul><li>基于TCP/IP协议发明了http协议</li></ul></li><li><p>需要解决的问题三：可以渲染html的引擎</p><ul><li>浏览器(终端内的www)</li></ul></li></ul><blockquote><p>1993年，页面不只是文字，还有图片</p></blockquote><p>马克安德森和另一位NCSA的朋友一起研发了mosiac浏览器，可以渲染图片。</p><blockquote><p>1994年以后，安德森和吉姆克拉克从NCSA离开了，成立了NetScap网景公司</p></blockquote><p>在MOSIAC浏览器的基础上，开发了netscap naviagtor浏览器，可以渲染图片和文字。</p><blockquote><p>1995年，liveScript诞生</p></blockquote><p>Brendan Eich开发这种网页脚本语言，可以嵌入网页中。<br>同年12月，网景公司与Sun公司达成协议，命名这种语言叫做javascrpt。</p><blockquote><p>1996年，微软加入浏览器市场</p></blockquote><p>3月，Navigato浏览器正式内置了javascript语言。</p><p>Netscape 公司很快发现，Navigator浏览器需要一种可以嵌入网页的脚本语言，用来控制浏览器行为。当时，网速很慢而且上网费很贵，有些操作不宜在服务器端完成。比如，如果用户忘记填写“用户名”，就点了“发送”按钮，到服务器再发现这一点就有点太晚了，最好能在用户发出数据之前，就告诉用户“请填写用户名”。这就需要在网页中嵌入小程序，让浏览器检查每一栏是否都填写了。</p><p>8月，微软收购了spy glass公司，开发了jscript语言。</p><p>11月，网景公司将javascrpt语言提交给ECMA，希望javascrpt成为国际标准，抵抗微软。</p><p><em>此时并没有单独的脚本解析引擎。而是在原有的渲染引擎中加了点代码去解析脚本</em></p><blockquote><p>2001年，windowsxp携手ie6登场</p></blockquote><p>此时，js引擎被抽离出来(为了让浏览器更强，看图片，玩游戏…)。</p><blockquote><p>2003年</p></blockquote><p>网景公司的Navigator被windowsxp的ie6战胜，退出了历史舞台，但是网景公司开源了Navigator内核。从此Navigator被交给了firefox，火狐在此基础上开发了Gecko引擎。</p><blockquote><p>2008年</p></blockquote><p>谷歌浏览器横空出世，跟safari共同研制了webkit内核，基于webkit内核开发了blink内核。</p><p>谷歌浏览器之所以最快，因为它研制了v8引擎作为js引擎，它具有如下特点：</p><ul><li>直接把代码转为机器码，跳过字节码</li><li>可以独立于浏览器运行的nodjs</li></ul><p>从此，前端语言变成了关键的脚本语言，前端工程师的变得稀缺，甲骨文公司收购了sun公司，js版权归甲骨文公司所有。</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. 真实世界的并发编程</title>
      <link href="/2024/06/11/OS/class11/"/>
      <url>/2024/06/11/OS/class11/</url>
      
        <content type="html"><![CDATA[<h2 id="1-我们身边的并发编程">1 我们身边的并发编程</h2><h3 id="1-1-互联网的开始：Web1-0">1.1 互联网的开始：Web1.0</h3><blockquote><p>从 PC 时代到互联网时代 (1990s)</p></blockquote><ul><li>Amazon (1994), Yahoo (1994), eBay (1995), Google (1998)</li><li>HTTP (对，没有 HTTPS), HTML，但没有 CSS<ul><li>中国互联网初代 “三巨头”：新浪、搜狐、网易诞生</li><li><code>&lt;font&gt;</code>, <code>&lt;table&gt;</code>, vbscript 和切图工程师一统天下</li></ul></li></ul><h3 id="1-2-Web2-0">1.2 Web2.0</h3><blockquote><p>Asynchronous JavaScript and XML (Ajax; ~1999)</p></blockquote><ul><li>允许网页实现 “后台刷新”<ul><li>悄悄请求后端，然后更新 DOMTree</li><li>“应用” 可以做的，网页也都可以做了！</li></ul></li><li>(你没看错，竟然不是 JSON)<ul><li>原因：后端 (Java) 应用广泛使用 XML</li></ul></li></ul><blockquote><p>jQuery $ (2006)</p></blockquote><ul><li>允许 Javascript 代码优雅地修改 DOMTree</li><li><code>$('h3').replaceWith('XXX');</code></li></ul><p><strong>从此，做“任何事”都只要浏览器就行</strong></p><blockquote><p>甚至诞生了 ChromeOS</p></blockquote><ul><li>HTML + CSS 构建应用的方便程度超过传统 GUI 编程</li><li>GTK, Qt, MFC 谁用谁知道</li></ul><h3 id="Web2-0时代的并发编程">Web2.0时代的并发编程</h3><blockquote><p>Challenges</p></blockquote><ul><li>线程 (在 1990s) 开销很大</li><li>线程同步很难写对</li></ul><blockquote><p>Solution: Event-based concurrency (动态计算图)</p></blockquote><ul><li>允许随时创建计算节点<ul><li>例如网络请求、定时器</li></ul></li><li>禁止计算节点并行<ul><li>网络访问占大部分时间；浏览器内计算只是小部分</li></ul></li><li>以事件为单位调度<ul><li>事件可以在浏览器里看到！</li></ul></li></ul><blockquote><p>“Callback hell (回调地狱)”</p></blockquote><ul><li>2024 年，教务系统里还能看到明文</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/api/user&#x27;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">user</span>) &#123;</span><br><span class="line">        $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">            <span class="attr">url</span>: <span class="string">`/api/user/<span class="subst">$&#123;user.id&#125;</span>/friends`</span>,</span><br><span class="line">            <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">friends</span>) &#123;</span><br><span class="line">                $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">                    <span class="attr">url</span>: <span class="string">`/api/friend/<span class="subst">$&#123;friends[<span class="number">0</span>].id&#125;</span>`</span>,</span><br><span class="line">                    ...</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">error</span>: <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>ECMAScript 2015 (ES6)</p></blockquote><ul><li>一统第三方库 “军阀混战” 的局面</li><li>开源生态开始起飞</li></ul><blockquote><p>现代前端的代表作品</p></blockquote><ul><li>Angular, React, Vue</li><li>Express.js, Next.js</li><li>Bootstrap, Tailwindcss</li><li>Electron (vscode)<ul><li>2016 年，还用先烈 Github Atom 做过实验</li></ul></li></ul><blockquote><p>Promise: 描述动态计算图</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">`/api/localhost/?action=demo&amp;path=<span class="subst">$&#123;path&#125;</span>`</span>)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">fetchedData</span> =&gt;</span> <span class="title function_">setData</span>(fetchedData))</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">    <span class="title function_">fetch</span>(...).<span class="title function_">then</span>(...),</span><br><span class="line">    <span class="title function_">fetch</span>(...).<span class="title function_">then</span>(...),</span><br><span class="line">    <span class="title function_">fetch</span>(...).<span class="title function_">then</span>(...),</span><br><span class="line">]).<span class="title function_">then</span>(</span><br><span class="line">    <span class="comment">// succeeded</span></span><br><span class="line">).<span class="title function_">catch</span>(</span><br><span class="line">    <span class="comment">// error handling (catches exceptions in the fetch)</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="1-3-历史车轮碾过">1.3 历史车轮碾过</h3><blockquote><p>PC → Web → Web 2.0 (UGC) → AI (AGI)</p></blockquote><ul><li>“框架” 是驱动技术发展的原动力</li><li>我们需要好的抽象来表达人类世界中的需求<ul><li>简单可靠，聚集大量行业开发者</li><li>灵活通用，构造各种应用程序</li></ul></li></ul><blockquote><p>单机 → 互联网 → 移动计算 → ???</p></blockquote><ul><li>机遇和不确定</li><li>风险和回报</li></ul><h2 id="2-高性能计算中的并发编程">2 高性能计算中的并发编程</h2><h3 id="2-1-CRAY-1-超级计算机">2.1 CRAY-1 超级计算机</h3><blockquote><p>“<a href="https://dl.acm.org/doi/10.1145/359327.359336">The world’s most expensive love-seat</a>” (1976)</p></blockquote><ul><li>138 MFLOPS @ 115kW (Apple M3: 4.1 TFLOPS @ 20W)</li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c11-2.1-1.webp" alt="c11-2.1-1.webp"></p><h3 id="2-2-高性能计算">2.2 高性能计算</h3><blockquote><p>“A technology that harnesses the power of supercomputers or computer clusters to solve complex problems requiring massive computation.” (IBM)<br>源自数值密集型科学计算任务</p></blockquote><ul><li>物理系统模拟<ul><li>天气预报、航天、制造、能源、制药、……</li><li>大到宇宙小到量子，有模型就能模拟</li></ul></li><li>矿厂</li><li>AI: 新时代的高性能计算 (之后专门讲解)</li><li><a href="http://www.hpc100.cn/top100/22/">HPC-China 100</a></li></ul><blockquote><p>物理世界具有 “空间局部性”</p></blockquote><ul><li>“模拟物理世界” 的系统具有 embarrassingly parallel 的特性</li></ul><h3 id="2-3-高性能计算中的并行编程">2.3 高性能计算中的并行编程</h3><blockquote><p>通常计算图容易静态切分 (机器-线程两级任务分解)</p></blockquote><ul><li>生产者-消费者解决一切<ul><li>MPI - “message passing libraries”, OpenMP - “multi-platform shared-memory parallel programming (C/C++ and Fortran)”</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(128)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Challenges</p></blockquote><ul><li>网络通信、功耗管理、稳定性和容错、软件和工具链</li></ul><h2 id="3-数据中心中的并发编程">3 数据中心中的并发编程</h2><h3 id="3-1数据中心程序：特点">3.1数据中心程序：特点</h3><blockquote><p>“A network of computing and storage resources that enable the delivery of shared applications and data.” (CISCO)</p></blockquote><blockquote><p>以海量分布式数据 (存储) 为中心</p></blockquote><ul><li>实时的 “小数据处理”<ul><li>内容分发、用户认证、视频直播、弹幕……</li></ul></li><li>离线的 “大数据处理”<ul><li>内容索引、数据挖掘……</li></ul></li></ul><blockquote><p>我们的生活离不开数据中心应用</p></blockquote><ul><li>AI、搜索、社交、支付、游戏……</li></ul><h3 id="3-2-数据中心里的并发编程">3.2 数据中心里的并发编程</h3><blockquote><p>Challenge: 高可靠、低延迟的多副本分布式存储和计算</p></blockquote><ul><li>数据保持一致 (Consistency)、服务时刻可用 (Availability)、容忍机器离线 (Partition tolerance) 不可兼得</li></ul><blockquote><p>高吞吐 (QPS) &amp; 低延迟的事件处理</p></blockquote><ul><li>处理事件可能需要读写持久存储或请求网络上的服务<ul><li>延迟不确定</li></ul></li><li>线程维护和上下文切换都会带来开销</li></ul><blockquote><p>假设有数千/数万个请求同时到达服务器……</p></blockquote><ul><li>“Denial of Service, DoS”<ul><li>全国的小爱音箱在小米汽车发布会上同步瘫痪</li></ul></li></ul><h3 id="3-3-协程：操作系统-“不感知”-的上下文切换">3.3 协程：操作系统 “不感知” 的上下文切换</h3><blockquote><p>和线程概念相同 (独立堆栈、共享内存)</p></blockquote><ul><li>但 “一直执行”，直到 yield() 主动放弃处理器<ul><li>yield() 是函数调用<ul><li>只需保存/恢复 non-volatile 的寄存器</li><li>(线程切换需要保存/恢复全部寄存器)</li></ul></li></ul></li><li>但 sleep (I/O) 时，所有协程都 “卡住了”</li><li>失去了并行</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只可能是 1122 或 2211</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">T1</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>); <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>); <span class="built_in">yield</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">T2</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;2&quot;</span>); <span class="built_in">printf</span>(<span class="string">&quot;2&quot;</span>); <span class="built_in">yield</span>(); &#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-Go-和-Goroutine">3.4 Go 和 Goroutine</h3><blockquote><p>小孩子才做选择，多处理器并行和轻量级并发我全都要！</p></blockquote><ul><li>Goroutine: 概念上是线程，实现是线程和协程的混合体</li></ul><blockquote><p>Goroutine 实现</p></blockquote><ul><li>每个 CPU 上有一个 Go Worker，运行协程</li><li>协程执行 blocking API (sleep, read)<ul><li>偷偷调用 non-blocking 的版本</li><li>成功 → 立即继续执行</li><li>失败 → 立即 yield 到另一个需要 CPU 的 goroutine<ul><li>太巧妙了！完全不浪费！</li></ul></li></ul></li></ul><h3 id="3-5-Go-语言中的同步与通信">3.5 Go 语言中的同步与通信</h3><blockquote><p>Do not communicate by sharing memory; instead, share memory by communicating. ——Effective Go</p></blockquote><blockquote><p>共享内存 = 万恶之源</p></blockquote><ul><li>信号量/条件变量：实现了同步，但没有实现 “通信”<ul><li>数据传递完全靠手工 (没上锁就错了)</li></ul></li></ul><blockquote><p>但 UNIX 时代就有一个实现并行的机制了</p></blockquote><ul><li><code>cat *.txt | wc -l</code><ul><li>管道是一个天然的生产者/消费者！</li><li>为什么不用 “管道” 实现协程/线程间的同步 + 通信呢？<ul><li>Channels in Go</li></ul></li></ul></li></ul><blockquote><p>“Leader/follower” 架构</p></blockquote><ul><li>有一个集中的 “总控” 负责调度</li><li>在可靠的消息机制上实现任务分派<ul><li>Leader 串行处理所有请求</li><li>例子：哲学家吃饭时，由服务员掌管叉子</li></ul></li></ul><blockquote><p>你可能会觉得，管叉子的人是性能瓶颈？</p></blockquote><ul><li>一大桌人吃饭，每个人都叫服务员的感觉</li><li>Premature optimization is the root of all evil (D. E. Knuth)</li></ul><blockquote><p>抛开 workload 谈优化就是耍流氓</p></blockquote><ul><li>吃饭的时间通常远远大于请求服务员的时间</li><li>如果一个 manager 搞不定，可以分多个 (fast/slow path)<ul><li>The Google File System (SOSP’03) 开启大数据时代</li></ul></li></ul><h2 id="4-人工智能时代的并发编程">4 人工智能时代的并发编程</h2><h3 id="4-1-大语言模型背后的计算">4.1 大语言模型背后的计算</h3><blockquote><p>“Attention Is All You Need”</p></blockquote><ul><li>“Transformers”:类似人处理问题的思维方式(注意力机制)。</li></ul><h3 id="4-2-机器学习系统中的并发编程">4.2 机器学习系统中的并发编程</h3><blockquote><p>Challenge: 既计算密集，又数据密集</p></blockquote><ul><li>推理<ul><li>GPT-3: 175B 参数 (~300GB VRAM, FP-16)<ul><li>GPT-3 single training run cost: ~$5,000,000</li></ul></li><li>LLaMA2: 70B 参数 (~65GB VRAM, FP-16)<ul><li>美国人断供芯片 = 三体人行为</li></ul></li></ul></li><li>训练<ul><li>320TB 语料</li><li>相比图片和视频，还是小弟弟<br><strong>解决：所有能想到的技术，全部都用上了！</strong></li></ul></li></ul><p><em>对并发编程的争议一直存在，例如 “Threads cannot be implemented as a library”。实际上，我们在很多应用领域看到了 “领域特定” 的解决方案：Web 中的异步编程、高性能计算中的 MPI 和 OpenMI、数据中心中的 goroutines、人工智能时代的 CUDA。更有趣的是，我们可以看到：改变世界的技术，往往只是一个小小的奇思妙想, 最终坚持到底得到的——它们很难被 “规划” 出来，而是需要一些 “背道而驰” 的人坚持到底。在当今的社会环境下，我们最缺少的是有能力背道而驰的人——有了下一代人的进步，才会有包容他们的土壤。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10. 并发控制：同步 (2)</title>
      <link href="/2024/06/06/OS/class10/"/>
      <url>/2024/06/06/OS/class10/</url>
      
        <content type="html"><![CDATA[<h2 id="1-信号量">1 信号量</h2><h3 id="1-1-用互斥锁实现同步">1.1 用互斥锁实现同步</h3><blockquote><p>一个奇妙的想法</p></blockquote><ul><li>创建锁时，立即 “获得” 它 (总是成功)</li><li>其他人想要获得时就会等待<ul><li>此时 release 就实现了同步</li></ul></li><li>一个线程上锁，在另一个线程解锁</li></ul><blockquote><p>让我们来试一试吧 (demo)</p></blockquote><ul><li>先把厕所门都锁上</li><li>线程到达以后等待</li><li>管理员把所有门都打开</li></ul><blockquote><p>Acquire-Release 实现计算图</p></blockquote><ul><li>为每一条边 𝑒=(𝑢, 𝑣) 分配一个互斥锁</li><li>初始时，全部处于锁定状态</li><li>对于一个节点，它需要获得所有入边的锁才能继续</li><li>可以直接计算的节点立即开始计算</li><li>计算完成后，释放所有出边对应的锁</li></ul><blockquote><p>挺好用 (demo)</p></blockquote><ul><li>甚至比条件变量还好用！</li></ul><h3 id="1-2-本质：Release-as-Synchronization">1.2 本质：Release as Synchronization</h3><blockquote><p>Release-Acquire 实现了 happens-before</p></blockquote><ul><li>Acquire = 等待 token</li><li>Release = 发出 token</li></ul><blockquote><p>Token 可以理解为现实生活中的“资源”</p></blockquote><ul><li>停车场：停车位</li><li>游泳馆：获得手环 (token) 的人可以进入更衣室<ul><li>mutex 实现 token 似乎有什么问题？<br>缺点：token=1</li></ul></li></ul><h3 id="1-3-信号量">1.3 信号量</h3><blockquote><p>如果我是游泳馆的老板……</p></blockquote><ul><li>一个能 “计数” 的 mutex: 发 𝑛 个手环！<ul><li>手环 = synchronization token</li></ul></li><li>mutex 是 𝑛=1 的特殊情况</li></ul><blockquote><p>Acquire</p></blockquote><ul><li>获得手环的同学进入游泳池 (手环不够，等待)</li></ul><blockquote><p>Release</p></blockquote><ul><li>归还一个手环 (一个等待的同学就能得到手环了)</li></ul><h3 id="1-4-把任何东西理解为Token">1.4 把任何东西理解为Token</h3><blockquote><p>停车场有 𝑛 个车位</p></blockquote><ul><li>Acquire: 在有车位时进入停车场</li><li>Release: 出停车场；车位 + 1</li></ul><blockquote><p>袋子里有 𝑛 个球</p></blockquote><ul><li>Acquire: 从袋子里取一个球<ul><li>如果没有球，需要等待</li></ul></li><li>Release: 向袋子里放一个球<ul><li>如果有人在等待，直接把球交给他</li></ul></li></ul><blockquote><p>注意我们可以有多个口袋！</p></blockquote><h3 id="1-5-API">1.5 API</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="type">sem_t</span> *sem)</span> &#123;</span><br><span class="line">    <span class="comment">// P - prolaag</span></span><br><span class="line">    <span class="comment">//     try + decrease/down/wait/acquire</span></span><br><span class="line">    atomic &#123;</span><br><span class="line">        wait_until(sem-&gt;count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sem-&gt;count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="type">sem_t</span> *sem)</span> &#123;</span><br><span class="line">    <span class="comment">// V - verhoog</span></span><br><span class="line">    <span class="comment">//     increase/up/post/signal/release</span></span><br><span class="line">    atomic &#123;</span><br><span class="line">        sem-&gt;count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-使用信号量实现同步">2 使用信号量实现同步</h2><blockquote><ol><li>实现一次临时的 happens-before: 𝐴→𝐵</li></ol></blockquote><ul><li>𝐴→𝑉(𝑠)→𝑃(𝑠)→𝐵这就是刚才的 “互斥锁实现同步”</li></ul><blockquote><ol start="2"><li>管理计数型资源</li></ol></blockquote><ul><li>游泳池里的人不能超过 𝑛 个</li><li>停车场里的车不能超过 𝑛 个</li><li>但可以有多个 “停车场”、“游泳池”</li><li>我们也可以创造出车位</li></ul><h3 id="2-1-线程join">2.1 线程join()</h3><blockquote><ol><li>形成 happens-before</li></ol></blockquote><ul><li>worker: $ V(done_t) $</li><li>main: $ P(done_1 )→P(done_2​)…→P(done_T) $描述了一个 “计算图”</li></ul><blockquote><ol start="2"><li>使用计数型资源</li></ol></blockquote><ul><li>worker: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>d</mi><mi>o</mi><mi>n</mi><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(done)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span></li><li>main: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>d</mi><mi>o</mi><mi>n</mi><mi>e</mi><mo stretchy="false">)</mo><mo>×</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">P(done)×T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></li></ul><h3 id="2-2-实现生产者-消费者">2.2 实现生产者-消费者</h3><blockquote><p>信号量设计思路</p></blockquote><ul><li>考虑 “球”/“手环” (每一单位的 “资源”) 是什么</li><li>生产者/消费者 = 把球从一个袋子里放到另一个袋子里</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">produce</span><span class="params">()</span> &#123;</span><br><span class="line">    P(&amp;empty);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">    V(&amp;fill);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consume</span><span class="params">()</span> &#123;</span><br><span class="line">    P(&amp;fill);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    V(&amp;empty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-信号量、条件变量与同步">3 信号量、条件变量与同步</h2><h3 id="3-1-信号量-v-s-条件变量">3.1 信号量 v.s. 条件变量</h3><blockquote><p>信号量</p></blockquote><ul><li>互斥锁的自然推广</li><li>干净、优雅：没有条件变量的 “自旋”</li></ul><blockquote><p>条件变量</p></blockquote><ul><li>万能：适用于任何同步条件</li><li>不太好用：代码总感觉不太干净</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">synchronized (obj) &#123;  <span class="comment">// reads better in Java</span></span><br><span class="line">    <span class="keyword">while</span> (!cond) &#123;</span><br><span class="line">        obj.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>哲学家吃饭问题 (E. W. Dijkstra, 1960)</p></blockquote><ul><li>哲学家 (线程) 有时思考，有时吃饭</li><li>吃饭需要同时得到左手和右手的叉子</li></ul><blockquote><p>条件变量</p></blockquote><ul><li>同步条件：<code>avail[lhs] &amp;&amp; avail[rhs]</code></li></ul><blockquote><p>信号量</p></blockquote><ul><li><code>P(&amp;sem[lhs]) &amp;&amp; P(&amp;sem[rhs])</code></li><li>看起来没什么问题？<ul><li>当互斥锁用就行了</li></ul></li></ul><blockquote><p>如果 5 个哲学家同时举起左手的叉子……</p></blockquote><ul><li>我们需要禁止这件事发生</li></ul><blockquote><p>Workaround 1: 从桌子上赶走一个人</p></blockquote><ul><li>直观理解：大家先从桌上退出<ul><li>袋子里有 4 张卡</li><li>拿到卡的可以上桌吃饭 (拿叉子)</li><li>吃完以后把卡归还到袋子</li></ul></li></ul><blockquote><p>Workaround 2: Lock Ordering</p></blockquote><ul><li>给叉子编号，总是先拿编号小的</li></ul><h3 id="3-2-用条件变量实现信号量">3.2 用条件变量实现信号量</h3><blockquote><p>P 操作的同步条件</p></blockquote><ul><li><code>sem-&gt;count &gt; 0</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="type">sem_t</span> *sem)</span> &#123;</span><br><span class="line">    hold(&amp;sem-&gt;mutex) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!COND)</span><br><span class="line">            cond_wait(&amp;sem-&gt;cv, &amp;sem-&gt;mutex);</span><br><span class="line">        sem-&gt;count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="type">sem_t</span> *sem)</span> &#123;</span><br><span class="line">    hold(&amp;sem-&gt;mutex) &#123;</span><br><span class="line">        sem-&gt;count++;</span><br><span class="line">        cond_broadcast(&amp;sem-&gt;cv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-用信号量实现条件变量">3.3 用信号量实现条件变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(<span class="keyword">struct</span> condvar *cv, <span class="type">mutex_t</span> *mutex)</span> &#123;</span><br><span class="line">    mutex_lock(&amp;cv-&gt;lock);</span><br><span class="line">    cv-&gt;nwait++;</span><br><span class="line">    mutex_unlock(&amp;cv-&gt;lock);</span><br><span class="line"></span><br><span class="line">    mutex_unlock(mutex);</span><br><span class="line">    P(&amp;cv-&gt;sleep);</span><br><span class="line"></span><br><span class="line">    mutex_lock(mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">broadcast</span><span class="params">(<span class="keyword">struct</span> condvar *cv)</span> &#123;</span><br><span class="line">    mutex_lock(&amp;cv-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cv-&gt;nwait; i++) &#123;</span><br><span class="line">        V(&amp;cv-&gt;sleep);</span><br><span class="line">    &#125;</span><br><span class="line">    cv-&gt;nwait = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;cv-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-实现困难的本质原因">3.4 实现困难的本质原因</h3><blockquote><p>先释放锁，再执行 P</p></blockquote><ul><li>释放锁的一瞬间可能与 broadcast 并发</li></ul><blockquote><p>先执行 P，再释放锁</p></blockquote><ul><li><code>P(&amp;cv-&gt;sleep)</code> 会 “永久睡眠”</li></ul><blockquote><p>那怎么办</p></blockquote><ul><li>release-wait 必须实现成 “原子操作”</li><li>信号量：在合适的时候好用；但不总是好用</li></ul><p><em>信号量可以看做是互斥锁的一个 “推广”，可以理解成游泳馆的手环、袋子里的球，通过计数的方式实现同步——在符合这个抽象时，使用信号量能够带来优雅的代码。但信号量不是万能的——理解线程同步的条件才是真正至关重要的。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9. 并发控制：同步 (1)</title>
      <link href="/2024/06/05/OS/class9/"/>
      <url>/2024/06/05/OS/class9/</url>
      
        <content type="html"><![CDATA[<h2 id="1-线程同步">1. 线程同步</h2><blockquote><p>Synchronization</p></blockquote><ul><li>控制并发，使得 “两个或两个以上随时间变化的量在变化过程中保持一定的相对关系”</li><li>有点抽象，让我们来看例子</li></ul><blockquote><p>理解并发的方法</p></blockquote><ul><li>线程 = 我们自己</li><li>共享内存 = 物理空间</li></ul><h3 id="1-1-现实世界中的同步">1.1 现实世界中的同步</h3><blockquote><p>演奏音乐中的同步</p></blockquote><ul><li>每个乐手都是一个 “线程”</li><li>节拍 𝑖 到达 → 演奏 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝑛</mi><mi>𝑖</mi></msub></mrow><annotation encoding="application/x-tex">𝑛_𝑖</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>​</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">T_player</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!end) &#123;</span><br><span class="line">        wait_next_beat();</span><br><span class="line">        play_next_note();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在某个瞬间达到 “互相已知” 的状态</p></blockquote><ul><li>NPY: 等我洗个头就出门</li><li>NPY: 等我打完这局游戏就来</li><li>舍友：等我修好这个 bug 就吃饭</li><li>导师：等我出差回来就讨论这个课题</li><li>join(): 等所有线程结束就继续</li></ul><blockquote><p>“先到先等”，在条件达成的瞬间再次恢复并行</p></blockquote><ul><li>同时开始出去玩/吃饭/讨论</li></ul><h3 id="1-2-状态机视角">1.2 状态机视角</h3><blockquote><p>系统到达某个 “同步” (互相已知) 的状态</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">T_player</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!end) &#123;</span><br><span class="line">        wait_next_beat();</span><br><span class="line">        play_next_note();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">T_conductor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!end) &#123;</span><br><span class="line">        wait_next_beat();</span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>release() 之后，player 都会演奏下一拍</li></ul><blockquote><p>自旋等待同步条件达成</p></blockquote><ul><li>线程有先后，先来先等待</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait_next_beat</span><span class="params">()</span> &#123;</span><br><span class="line">retry:</span><br><span class="line">    <span class="keyword">if</span> (!next_beat_has_come) &#123;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-生产者-消费者问题与条件变量">2. 生产者-消费者问题与条件变量</h2><ul><li>99% 的实际并发问题都可以用生产者-消费者解决</li></ul><blockquote><p>Producer 和 Consumer 共享一个缓冲区</p></blockquote><ul><li>Producer (生产数据)：如果缓冲区有空位，放入；否则等待</li><li>Consumer (消费数据)：如果缓冲区有数据，取走；否则等待</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">produce</span><span class="params">(Object obj)</span>; </span><br><span class="line">Object <span class="title function_">consume</span><span class="params">()</span>; </span><br></pre></td></tr></table></figure><h3 id="2-1-生产者-消费者问题的简化">2.1 生产者-消费者问题的简化</h3><blockquote><p>缓冲区太麻烦，我们有一个简化版问题</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">produce</span><span class="params">()</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">consume</span><span class="params">()</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>); &#125;</span><br></pre></td></tr></table></figure><ul><li>生产 = 打印左括号 (push into buffer)</li><li>消费 = 打印右括号 (pop from buffer)</li><li>在 printf 前后增加代码，使得打印的括号序列满足<ul><li>一定是某个合法括号序列的前缀</li><li>括号嵌套的深度不超过 𝑛<ul><li>𝑛 = 3, <code>((())())(((</code> 合法</li><li>𝑛 = 3, <code>(((())))</code>, <code>(()))</code> 不合法</li></ul></li></ul></li></ul><h3 id="2-2-同步：先来先等待">2.2 同步：先来先等待</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">produce</span><span class="params">()</span> &#123;</span><br><span class="line">    wait_until(括号深度 &lt; n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consume</span><span class="params">()</span> &#123;</span><br><span class="line">    wait_until(括号深度 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们发明了条件变量！</p></blockquote><ul><li>把条件用一个变量来替代</li><li>条件不满足时等待，条件满足时唤醒</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(&amp;lk);</span><br><span class="line"><span class="keyword">if</span> (!condition) &#123;</span><br><span class="line">    cond_wait(&amp;cv, &amp;lk);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Wait for someone for wake-up.</span></span><br><span class="line">assert(condition);</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;lk);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cond_signal(&amp;cv);  <span class="comment">// Wake up a (random) thread</span></span><br><span class="line">cond_broadcast(&amp;cv);  <span class="comment">// Wake up all threads</span></span><br></pre></td></tr></table></figure><blockquote><p>条件变量的正确打开方式</p></blockquote><ul><li>使用 while 循环和 broadcast<ul><li>总是在唤醒后再次检查同步条件</li><li>总是唤醒所有潜在可能被唤醒的人</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(&amp;mutex);</span><br><span class="line"><span class="keyword">while</span> (!COND) &#123;</span><br><span class="line">  wait(&amp;cv, &amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">assert(cond);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure><h2 id="3-同步机制的应用">3. 同步机制的应用</h2><h3 id="3-1-实现任意计算图">3.1 实现任意计算图</h3><blockquote><p>计算任务构成有向无环图</p></blockquote><ul><li>(𝑢, 𝑣)∈𝐸表示 𝑣 要用到前 𝑢 的值</li><li>只要调度器 (生产者) 分配任务效率够高，算法就能并行</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">T_worker</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        consume().run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">T_scheduler</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!jobs.empty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j : jobs.find_ready()) &#123;</span><br><span class="line">            produce(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为每个节点设置一个条件变量</p></blockquote><ul><li>𝑣 能执行的同步条件：𝑢 → 𝑣 都已完成</li><li>𝑢 完成后，signal 每个 𝑢 →<br>𝑣</li></ul><p>例子</p><p><img src="https://cdn-img-el3.pages.dev/os/c9-3.1-1.webp" alt="c9-3.1-1.webp"></p><h3 id="3-2-条件变量">3.2 条件变量</h3><blockquote><p>有三种线程</p></blockquote><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">T_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 若干: 死循环打印 <code>&lt;</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">T_b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 若干: 死循环打印 <code>&gt;</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">T_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 若干: 死循环打印 <code>_</code></li></ul><blockquote><p>任务：</p></blockquote><ul><li>对线程同步，使得屏幕打印出 <code>&lt;&gt;&lt;_</code> 和 <code>&gt;&lt;&gt;_</code> 的组合</li></ul><blockquote><p>使用条件变量，只要回答三个问题：</p></blockquote><ul><li>打印 “<code>&lt;</code>” 的条件？打印 “<code>&gt;</code>” 的条件？打印 “<code>_</code>” 的条件？</li></ul><p><em>同步的本质是线程需要等待某件它所预期的事件发生，而事件的发生总是可以用条件 (例如 depth 满足某个条件，或是程序处于某个特定的状态) 来表达。因此计算机系统的设计者实现了条件变量，将条件检查和临界区 “放在一起”，以实现线程间的同步。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8. 调试理论与实践</title>
      <link href="/2024/06/04/OS/class8/"/>
      <url>/2024/06/04/OS/class8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-调试理论">1. 调试理论</h2><h3 id="1-1-Debug">1.1 Debug</h3><blockquote><p>如果我们已经知道 bug 的存在</p></blockquote><ul><li>Segmentation Fault</li><li>Online Judge 拒绝</li><li>虚拟机神秘重启</li><li>……</li></ul><blockquote><p>怎么找到它</p></blockquote><blockquote><p>公理 1：机器永远是对的</p></blockquote><ul><li>CPU: “无情的、执行指令的机器”</li><li>Crash, Wrong Answer, 虚拟机神秘重启<ul><li>99.9999% 是自己的问题</li><li>有亿点点概率是编译器错了 (但你可以知道)</li><li>有亿点点点点概率是处理器错了 (你也可以知道)</li></ul></li></ul><blockquote><p>公理 2：未测代码永远是错的</p></blockquote><ul><li>反复测试过的代码都是错的</li><li>你以为最不可能出 bug 的地方，往往 bug 就在那躺着</li></ul><h3 id="1-2-调试理论">1.2 调试理论</h3><blockquote><p>“软件” 的两层含义</p></blockquote><ul><li>人类需求在信息世界的投影<ul><li>理解错需求 → bug</li></ul></li><li>计算过程的精确 (数学) 描述<ul><li>实现错误 → bug</li></ul></li></ul><blockquote><p>调试为什么困难？</p></blockquote><ul><li>Bug 的触发经历了漫长的过程</li><li>可观测的现象未必能直接对应到 root cause 上</li></ul><h3 id="1-3-Fault，Error，和Failure">1.3 Fault，Error，和Failure</h3><blockquote><p>需求 → 设计 → 代码 (Fault/bug) → 执行 (Error) → 失败 (Failure)</p></blockquote><ul><li>我们只能观测到 failure (可观测的结果错)</li><li>我们可以检查状态的正确性 (但非常费时)</li><li>无法预知 bug 在哪里 (每一行 “看起来” 都挺对的)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>人总是 “默认” (不默认，浪费的时间就太多了)</li></ul><h3 id="1-4-调试理论">1.4 调试理论</h3><blockquote><p>调试理论：如果我们能判定任意程序状态的正确性，那么给定一个 failure，我们可以通过二分查找定位到第一个 error 的状态，此时的代码就是 fault (bug)。</p></blockquote><blockquote><p>推论</p></blockquote><ul><li>为什么我们喜欢 “单步调试”？<ul><li>从一个假定正确的状态出发</li><li>每个语句的行为有限，容易判定是否是 error</li></ul></li><li>为什么调试理论看起来很没用？<ul><li>“判定状态正确” 非常困难</li><li>(是否在调试 DP 题/图论算法时陷入时间黑洞？)</li></ul></li></ul><blockquote><p>调试 = 观察状态机执行 (trace) 的某个侧面</p></blockquote><ul><li>缩小错误状态 (error) 可能产生的位置</li><li>提出假设，作出验证<br>? 观察状态机执行的两个基本工具</li><li>printf → 自定义 log 的 trace<ul><li>灵活可控、能快速定位问题大概位置、适用于大型软件</li><li>无法精确定位、大量的 logs 管理起来比较麻烦</li></ul></li><li>gdb → 指令/语句级 trace<ul><li>精确、指令级定位、任意查看程序内部状态</li><li>耗费大量时间</li></ul></li></ul><p><strong>调试理论给了我们在遇到 “问题” 时候 self-check 的列表：</strong></p><p><strong>是怎样的程序 (状态机) 在运行？<br>我们遇到了怎样的 failure？<br>我们能从状态机的运行中从易到难得到什么信息？<br>如何二分检查这些信息和 error 之间的关联？</strong></p><h2 id="2-调试一切状态机">2. 调试一切状态机</h2><blockquote><p>计算机随时随地都在拒绝你</p></blockquote><p><code>bash: curl: command not found</code></p><p><code>fatal error: 'sys/cdefs.h': No such file or directory #include &lt;sys/cdefs.h&gt;</code></p><p><code>/usr/bin/ld: cannot find -lgcc: No such file or directory</code></p><p><code>make[2]: *** run: No such file or directory.  Stop. Makefile:31: recipe for target 'run' failed</code></p><blockquote><p>万能方法：假设你遇到的问题是别人也遇到的</p></blockquote><ul><li>但如果这是一个全新的问题？</li></ul><h3 id="2-1-一切皆可调试">2.1 一切皆可调试</h3><blockquote><p>程序 = 计算机系统 = 状态机</p></blockquote><ul><li>机器永远是对的</li></ul><blockquote><p>UNIX 世界里你做任何事情都是在编程</p></blockquote><ul><li>“用编程语言把脑中所想传达给电脑”</li><li>刚才的问题都可以看成是程序/输入/配置有 bug</li></ul><blockquote><p>调试理论可以用于解决任何 “问题”</p></blockquote><ul><li>curl: command not found</li><li><code>'sys/cdefs.h'</code>: No such file or directory</li><li>Makefile:31: recipe for target ‘run’ failed</li></ul><h3 id="2-2-使用调试理论">2.2 使用调试理论</h3><blockquote><p>Fault (程序/输入/配置错) → Error → Failure (可观测)</p></blockquote><ul><li>大部分 Error 和 Failure 都比较接近<ul><li>出错时，使用 perror 打印日志</li></ul></li></ul><blockquote><p>“找不到问题” 的原因</p></blockquote><ul><li>出错原因报告不准确</li><li>程序执行的过程看不到<ul><li>那我们想办法 “看到” 状态机的执行过程就好了！</li></ul></li></ul><blockquote><p>理解状态机执行：不是 “调试”，也是 “调试”</p></blockquote><ul><li><code>ssh</code>：使用 <code>-v</code> 选项检查日志</li><li><code>gcc</code>：使用 <code>-v</code> 选项打印各种过程</li><li><code>make</code>：使用 <code>-nB</code> 选项查看完整命令历史</li></ul><blockquote><p>调试：不仅是 “调试器”</p></blockquote><ul><li>Profiler: <code>perf</code> - “采样” 状态机</li><li>Trace: <code>strace</code> - 追踪系统调用</li></ul><h2 id="3-调试理论的应用">3. 调试理论的应用</h2><blockquote><p>需求 → 设计 → 代码 → Fault → Error → Failure</p></blockquote><ul><li>“Technical Debt”: 每当你写出不好维护的代码，你都在给你未来的调试/需求变更挖坑</li></ul><blockquote><p>中枪了？</p></blockquote><ul><li>《计算机系统基础》为了赶紧实现指令，随手写的代码</li><li>《操作系统》为了快点跑程序，随便写的 klib</li><li>《我读研了》为了应付老板，随便写的系统实现</li></ul><h3 id="3-1-调试理论：推论">3.1 调试理论：推论</h3><blockquote><p>需求 → 设计 → 代码 → Fault</p></blockquote><ul><li>写好代码：不要在写代码的时候忘记需求和设计</li><li>不言自明 (Self-explanatory)<ul><li>能通过字面知道需求 (流程)</li></ul></li><li>不言自证 (Self-evident)<ul><li>能通过字面确认代码和需求一致</li></ul></li></ul><blockquote><p>一个评判标准</p></blockquote><ul><li>AI 是否能正确理解/维护你的代码: toybox</li></ul><blockquote><p>Programs are meant to be read by humans and only incidentally for computers to execute. (Donald E. Knuth)</p></blockquote><blockquote><p>Fault → Error</p></blockquote><ul><li>做好测试：未测代码永远是错的<ul><li>残酷的现实：相信自己写不对代码</li><li>LLM 一样经常犯 “傻” 错</li></ul></li></ul><blockquote><p>Small Scope Hypothesis</p></blockquote><p>If a system does not have a counterexample (i.e., an error or a bug) for a certain property within a small scope (a limited size or configuration), then it is unlikely to have a counterexample in a larger scope. (Daniel Jackson)</p><blockquote><p>Error → Failure</p></blockquote><ul><li>多写断言：把代码中的 “隐藏性质” 写出来<ul><li>Error 暴露的越晚，调试越困难</li><li>追溯导致 assert failure 的变量值 (slice) 通常可以快速定位到 bug</li></ul></li></ul><blockquote><p>“There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no obvious deficiencies” (Tony Hoare)</p></blockquote><p><em>如果我们观察到软件发生了 “超出预期的表现”，我们需要理解的是我们的 “预期” 经历了需求 → 设计 → 代码 → Fault → Error → Failure 的漫长过程，其中的每一个过程多多少少都有些失控：我们的预期本身可能有误，或是对软件需要实现的需求有误解。而设计失误、编码错误最终反应到可观测的表现时，有时可能已经太晚了。因此，我们 “写好代码、做好测试、多写断言” 是十分重要的。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7. 并发控制：互斥 (2)</title>
      <link href="/2024/05/30/OS/class7/"/>
      <url>/2024/05/30/OS/class7/</url>
      
        <content type="html"><![CDATA[<h2 id="1-操作系统内核中的互斥">1 操作系统内核中的互斥</h2><h3 id="1-1-计算机系统的状态机模型">1.1 计算机系统的状态机模型</h3><blockquote><p>状态</p></blockquote><ul><li>共享内存 + per-CPU 寄存器</li></ul><blockquote><p>初始状态</p></blockquote><ul><li>由系统设计者规定 (CPU Reset)</li></ul><blockquote><p>状态迁移</p></blockquote><ul><li>选择任意 CPU：<ul><li>从 PC 取指令执行或响应中断信号 (中断打开时)<ul><li>计算：改变内存/寄存器数值</li><li>I/O：与 “计算机系统外” 交换数据</li></ul></li></ul></li></ul><h3 id="1-2-操作系统内核中的互斥">1.2 操作系统内核中的互斥</h3><blockquote><p>操作系统接管了完整的计算机系统</p></blockquote><ul><li>每个处理器都并行 x++</li><li>每个处理器中断发生时执行 x += 1000000000</li><li>(假想 x 是操作系统中的数据结构，例如进程表)</li></ul><blockquote><p>如何正确实现 x 的原子访问？</p></blockquote><ul><li>仅仅自旋是不够的<br>lock后，sum++，如果sum++里面也lock，再执行其他任务的时候，会死锁。</li><li>因为还有中断</li></ul><h3 id="1-3-正确性准则">1.3 正确性准则</h3><blockquote><p>正确实现互斥</p></blockquote><ul><li>关中断 + 自旋可以保证实现互斥</li></ul><blockquote><p>上锁/解锁前后中断状态不变</p></blockquote><ul><li>不得在关中断时随意打开中断 (例如处理中断时)</li><li>不得随意关闭中断 (否则可能导致中断丢失)</li><li>因此我们需要保存中断状态<ul><li>全局？</li><li>Per CPU?</li><li>Per Thread?</li></ul></li><li>xv6 自旋锁</li></ul><h2 id="2-操作系统内核中的-半-无锁互斥">2 操作系统内核中的 (半) 无锁互斥</h2><h3 id="2-1-自旋的后果">2.1 自旋的后果</h3><blockquote><p>同一份计算任务，时间 (CPU cycles) 和空间 (内存占用) 会随处理器数量的增长而变化。</p></blockquote><p><img src="https://cdn-img-el3.pages.dev/os/c7-2.1-1.webp" alt="c7-2.1-1.webp"></p><center> 用自旋锁实现 sum++：更多的处理器，更差的性能 </center><blockquote><p>严谨的统计很难</p></blockquote><p>影响cpu性能的因素：</p><ul><li>CPU 是动态功耗的</li><li>系统中的其他进程</li><li>超线程</li><li>NUMA</li><li>……</li></ul><!-- [Benchmarking crimes](https://gernot-heiser.org/benchmarking-crimes.html) by Gernot Heiser --><h3 id="2-2-自旋锁的使用场景">2.2 自旋锁的使用场景</h3><blockquote><p>操作系统内核的并发数据结构 (短临界区)</p></blockquote><ul><li>临界区几乎不 “拥堵”，迅速结束</li></ul><blockquote><p>Linux Kernel 里有 ~180K 个并发控制函数调用！</p></blockquote><ul><li>自旋锁当然不 scale</li></ul><blockquote><p>许多操作系统内核对象具有 “read-mostly” 特点</p></blockquote><ul><li>路由表<ul><li>每个数据包都要读</li><li>网络拓扑改变时才变更</li></ul></li><li>用户和组信息<ul><li>无时不刻在检查 (Permission Denied)</li><li>但几乎从不修改用户</li></ul></li></ul><h3 id="2-3-Read-copy-update">2.3 Read-copy-update</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Counter *c_current;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Read</span></span><br><span class="line">    Counter *c = c_current;</span><br><span class="line">    <span class="keyword">return</span> c-&gt;sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    SPIN_LOCKED &#123;</span><br><span class="line">        <span class="comment">// Copy</span></span><br><span class="line">        Counter *c = alloc_counter();</span><br><span class="line">        c-&gt;sum = c_current-&gt;sum + <span class="number">1</span>;</span><br><span class="line">        smp_wmb(); <span class="comment">// Memory barrier</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update</span></span><br><span class="line">        c_current = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>改写 = 复制</p></blockquote><ul><li>任何对象都可以复制！<ul><li>(甚至可以只复制改变的部分)</li><li>例子：链表</li></ul></li><li>允许某一时刻，不同 CPU “看到” 不同版本</li></ul><blockquote><p>何时回收旧版本？</p></blockquote><ul><li>旧版本对象会存在一个 “graceful period”</li><li>直到某个时刻，所有 CPU read 都会访问到新版本<ul><li>怎么准确地找到这个时间点？</li></ul></li></ul><h3 id="2-4-Linux内核的复杂性">2.4 Linux内核的复杂性</h3><p><img src="https://cdn-img-el3.pages.dev/os/c7-2.4-1.webp" alt="c7-2.4-1.webp"></p><h2 id="3-应用程序中的互斥">3 应用程序中的互斥</h2><h3 id="3-1-应用程序自旋的后果">3.1 应用程序自旋的后果</h3><blockquote><p>性能问题 (1)</p></blockquote><ul><li>除了进入临界区的线程，其他处理器上的线程都在空转<ul><li>争抢锁的处理器越多，利用率越低</li><li>如果临界区较长，不如把处理器让给其他线程</li></ul></li></ul><blockquote><p>性能问题 (2)</p></blockquote><ul><li>应用程序不能关中断……<ul><li>持有自旋锁的线程被切换</li><li>导致 100% 的资源浪费</li><li>(如果应用程序能 “告诉” 操作系统就好了)</li></ul></li></ul><h3 id="3-2-应用程序：互斥">3.2 应用程序：互斥</h3><blockquote><p>思路：“拟人”</p></blockquote><ul><li>作业那么多，与其干等 Online Judge 发布，不如把自己 (CPU) 让给其他作业 (线程) 执行？</li></ul><blockquote><p>如何 “让”？</p></blockquote><ul><li>只有一种特殊的指令能做到：<code>syscall</code></li><li>把锁的实现放到操作系统里就好<ul><li><code>syscall(SYSCALL_lock, &amp;lk);</code><ul><li>试图获得 lk，但如果失败，就切换到其他线程</li></ul></li><li><code>syscall(SYSCALL_unlock, &amp;lk);</code><ul><li>释放 lk，如果有等待锁的线程就唤醒</li></ul></li></ul></li></ul><blockquote><p>一个足够高性能的实现</p></blockquote><ul><li>具有相当不错的 scalability</li><li>更多线程争抢时也没有极为显著的性能下降</li></ul><blockquote><p>使用方法：与自旋锁完全一致</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock;</span><br><span class="line">pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure><h3 id="3-3-应用程序和互斥锁Futex-Fast-Userspace-muTexes">3.3 应用程序和互斥锁Futex: Fast Userspace muTexes</h3><blockquote><p>小孩子才做选择。操作系统是全都要！</p></blockquote><ul><li>性能优化的最常见技巧：考虑平均而不是极端情况<ul><li>RCU 就用了这个思想！</li></ul></li></ul><blockquote><p>Fast Path: 自旋一次</p></blockquote><ul><li>一条原子指令，成功直接进入临界区</li></ul><blockquote><p>Slow Path: 自旋失败</p></blockquote><ul><li>请求系统调用 futex_wait</li><li>请操作系统帮我达到自旋的效果<ul><li>(实际上并不真的自旋)</li></ul></li></ul><blockquote><p>比想象的复杂</p></blockquote><ul><li>如果没有锁的争抢，Fast Path 不能调用 <code>futex_wake</code></li><li>自旋失败 → 调用 <code>futex_wait</code> → 线程睡眠<ul><li>如果刚开始系统调用，自旋锁被立即释放？</li><li>如果任何时候都可能发生中断？</li></ul></li></ul><blockquote><p>并发：水面下的冰山</p></blockquote><!-- * [LWN: A futex overview and update](https://lwn.net/Articles/360699/)* [Futexes are tricky](https://cis.temple.edu/~giorgio/cis307/readings/futex.pdf) by Ulrich Drepper --><p><em>“互斥” 看起来简单，用自旋就能实现，但如果在实际的场景 (例如可被中断的操作系统内核、不希望浪费 CPU 资源的应用程序等)，实际的互斥实现就不再简单。我们在 xv6 的自旋锁实现中，发现了许多 “防御性编程” 的例子，先假设程序员可能会犯一切可能的错误——然后不断加以检查。而 “正确性完全由开发者负责” 的时代将要过去，我们将会在未来越来越多地看到编程语言中的机制，帮助我们写出正确的代码。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6. 并发控制：互斥 (1)</title>
      <link href="/2024/05/29/OS/class6/"/>
      <url>/2024/05/29/OS/class6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-阻止并发-并行-的发生">1 阻止并发 (并行) 的发生</h2><h3 id="1-1-并发困难的原因">1.1 并发困难的原因</h3><blockquote><p>人类是 “sequential creatures[有序生物]”</p></blockquote><ul><li>人类具备 𝐴→…→𝐵 简化为 𝐴→𝐵 的直觉本能<ul><li>并且据此开发了编译器 (处理器也是编译器)</li><li><strong>多处理器和并发执行推翻了顺序执行的基本假设！</strong></li></ul></li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c5-4.2-2.webp" alt="c5-4.2-2.webp"></p><h3 id="1-2-互斥">1.2 互斥</h3><blockquote><p>人类是 (绝不轻言放弃的) sequential creatures</p></blockquote><ul><li>互斥 (互相排斥)：阻止并发，问题不就解决了？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ATOMIC &#123; sum++; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">T_alipay_withdraw</span><span class="params">(<span class="type">int</span> amt)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    ATOMIC &#123;</span><br><span class="line">        <span class="comment">// No concurrency with</span></span><br><span class="line">        <span class="comment">// other critical sections</span></span><br><span class="line">        <span class="keyword">if</span> (balance &gt;= amt) &#123;</span><br><span class="line">            balance -= amt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-互斥：阻止并发、独占访问">1.3 互斥：阻止并发、独占访问</h3><blockquote><p>既然用互斥 “阻止并发”，那我们为什么还要做并行？</p></blockquote><blockquote><p>状态机视角的互斥</p></blockquote><ul><li>临界区同时发生时，依然满足执行的原子性</li><li>可以把多次状态迁移理解为 “一次大状态迁移”</li></ul><blockquote><p>实现任何共享资源 (内存) 的独占访问</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ATOMIC &#123;</span><br><span class="line">    <span class="comment">// 状态迁移 (语义）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock();</span><br><span class="line"><span class="comment">// 任意代码</span></span><br><span class="line">unlock();</span><br></pre></td></tr></table></figure><blockquote><p>既然是顺序执行，那我们还要并发做什么？</p></blockquote><ul><li>如果你有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">1/k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>的代码是不能并发执行的，那么：</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>T</mi><mi mathvariant="normal">∞</mi></msub><mo>&gt;</mo><mfrac><msub><mi>T</mi><mn>1</mn></msub><mi>k</mi></mfrac></mrow><annotation encoding="application/x-tex">T_∞&gt;\frac{T_1}{k} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><ul><li>并行计算总是能实现的：</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>T</mi><mi>p</mi></msub><mo>&lt;</mo><msub><mi>T</mi><mi mathvariant="normal">∞</mi></msub><mo>+</mo><mfrac><msub><mi>T</mi><mn>1</mn></msub><mi>k</mi></mfrac></mrow><annotation encoding="application/x-tex">T_p &lt; T_∞ + \frac{T_1}{k} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h3 id="1-4-计算是可以并行的">1.4 计算是可以并行的</h3><blockquote><p>经典物理：局部性原理</p></blockquote><ul><li>物体对相邻物体的影响需要时间<ul><li>(即便严格来说不成立，依然是一个很好的近似)</li></ul></li><li>推论：任何物理世界模拟皆可以大规模并行</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>𝑇</mi><mi mathvariant="normal">∞</mi></msub><mo>≪</mo><msub><mi>𝑇</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">𝑇_∞≪𝑇_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≪</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p>Embarrassingly Parallel 的例子</p></blockquote><ul><li>图书馆 v.s. 分布式数据存储</li><li>大脑 v.s. 深度神经网络</li><li>……</li></ul><h3 id="1-5-实现互斥">1.5 实现互斥</h3><blockquote><p>能否使当前程序状态机独占计算机系统？</p></blockquote><ul><li>类比：关掉电脑手机，专注一件事</li><li>单处理器系统中 “其他任何事”：仅有中断</li></ul><blockquote><p>一条指令就可以实现原子性</p></blockquote><ul><li>x86: <code>cli</code> 清除 eflags 中的 IF bit</li><li>RISC-V: 清除 mstatus 的 MIE bit</li><li>AArch64: msr daifset, #3<ul><li>程序死循环 = 计算机系统卡死</li></ul></li></ul><blockquote><p>道高一尺、魔高一丈</p></blockquote><ul><li>处理器有 NMI (Non-Maskable Interrupts)</li><li>可以利用 NMI 实现错误监控<ul><li>设置硬件定时触发</li><li>操作系统定时复位定时器</li><li>触发 timeout，执行 NMI 处理程序<ul><li>例如，重启计算机</li></ul></li></ul></li></ul><h3 id="1-6-关中断不是万能的">1.6 关中断不是万能的</h3><blockquote><p>操作系统可以，但普通程序不行</p></blockquote><ul><li>中断保证了死循环不能把计算机 “卡死”</li><li>操作系统不允许普通程序关中断<ul><li>但如果是操作系统代码，完全可以短暂关闭中断</li></ul></li></ul><blockquote><p>单处理器系统可以，多处理器系统不行</p></blockquote><ul><li>每个处理器有独立的寄存器组</li><li>中断是每个处理器内部状态</li></ul><h2 id="2-使用-load-store-实现互斥">2 使用 load/store 实现互斥</h2><blockquote><p><a href="https://series1.github.io/blog/dekkers-algorithm/">绕口令</a>：A process 𝑃 can enter the critical section if the other does not want to enter, otherwise it may enter only if it is its turn.</p></blockquote><blockquote><p>实现假设</p></blockquote><ul><li>任何时候可以执行一条 load/store 指令</li><li>读写本身是原子的</li></ul><blockquote><p>并发的危险</p></blockquote><ul><li>你很难从字面上判断它到底对不对</li></ul><h3 id="2-1-问题重述">2.1 问题重述</h3><p>举例：上厕所</p><blockquote><p>若希望进入厕所，按顺序执行以下操作：</p></blockquote><ol><li>举起自己的旗子 (store)</li><li>把写有对方名字的字条贴在厕所门上 (store; 覆盖)</li></ol><blockquote><p>然后进入持续的观察模式：</p></blockquote><ol><li>观察对方是否举旗 (load)</li><li>观察厕所门上的名字 (load)<ul><li>对方不举旗或名字是自己，进入厕所，否则继续观察</li></ul></li></ol><blockquote><p>出厕所后，放下自己的旗子</p></blockquote><ul><li>不用管门上的字条</li></ul><p>总结：A手上拿着B的旗子，B手上拿着A的旗子，也就是说最开始A和B都举旗子了，然后A和B就会抢着把对方的旗子贴在门上，然后A和B乱序贴完后就开始观察门上的名字，如果是自己，就进厕所，如果不是自己，就继续观察。（贴的时候闭眼，观察的时候睁眼）</p><p>结论：手快反而会后进入。</p><blockquote><p>进入临界区的情况</p></blockquote><ul><li>如果只有一个人举旗，他就可以直接进入</li><li>如果两个人同时举旗，由厕所门上的标签决定谁进<ul><li>手快 🈶️ (被另一个人的标签覆盖)、手慢 🈚</li></ul></li></ul><blockquote><p>一些具体的细节情况</p></blockquote><ul><li>A 看到 B 没有举旗<ul><li>B 一定不在临界区</li><li>B 可能想进但还没来得及把 “B 正在使用” 贴在门上</li></ul></li><li>A 看到 B 举旗子<ul><li>A 一定已经把旗子举起来了 (!@^#&amp;!%^(&amp;^!@%#</li></ul></li></ul><blockquote><p>自动遍历状态空间的乐趣：快速回答更多问题</p></blockquote><ul><li>如果结束后把门上的字条撕掉，算法还正确吗？<ul><li>在放下旗子之前撕 v.s. 放下旗子之后撕</li></ul></li><li>先贴标签再举旗，算法还正确吗？</li><li>观察模式两个查看操作的顺序影响正确性吗？<ul><li>看对方的旗有没有举起来</li><li>看门上的贴纸是不是自己</li></ul></li><li>是否存在 “两个人谁都无法进入临界区” (liveness)、“对某一方不公平” (fairness) 等行为？<ul><li>都转换成图 (状态空间) 上的遍历问题了！</li></ul></li></ul><h3 id="2-2-Model-Checker和自动化">2.2 Model Checker和自动化</h3><blockquote><p>电脑为什么叫 “电脑”</p></blockquote><pre><code>- 因为它能替代部分人类的思维活动</code></pre><blockquote><p>回忆：每个班上都有一个笔记和草稿纸都工工整整的 Ta</p></blockquote><ul><li>Ta：认认真真完成老师作业<ul><li>工整的笔记可以启发思维，但花费了宝贵的人工</li></ul></li><li>我：烦死了！劳资不干了！玩去了<ul><li>战略：提出好的问题、适当地分解问题</li><li>战术：尽可能使用先进工具替代机械思维活动<ul><li>对于 Peterson 算法：都是一个晚自习时间，model checker 可以回答更多更深刻的问题</li></ul></li></ul></li></ul><blockquote><p>关于学习 (思考)：Tree of Thoughts</p></blockquote><ul><li>有一些别名：“批判性思维”、“第一性原理”……</li><li>有一些实现：AlphaGo……</li></ul><blockquote><p>那个好好学习的、总被老师表扬的 Ta？</p></blockquote><ul><li>听话的学生 → Chain of Thoughts (顺从)</li><li>不听话的学生 → Tree of Thoughts (质疑)</li></ul><h3 id="2-3-实现-Peterson-算法">2.3 实现 Peterson 算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;    <span class="comment">// 举起自己的旗子</span></span><br><span class="line">turn = B; <span class="comment">// 贴上对方的名字</span></span><br><span class="line"><span class="keyword">do</span> &#123;      <span class="comment">// 进入持续观察模式</span></span><br><span class="line">&#125; <span class="keyword">while</span> (b &amp;&amp; turn == B); <span class="comment">// 对方举旗且门上是对方的的名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;    <span class="comment">// 放下自己的旗子</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">1</span>;</span><br><span class="line">turn = A;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">&#125; <span class="keyword">while</span> (a &amp;&amp; turn == A);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><blockquote><p>模型的假设：Atomic load &amp; store</p></blockquote><ul><li>但这个假设在现代多处理器上并不成立</li><li>所以实际上按照模型直接写 Peterson 算法应该是错的？<ul><li>不妨实现了试一试？</li></ul></li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c5-4.2-2.webp" alt="c5-4.2-2.webp"></p><h3 id="2-4-现实中的-Peterson-算法">2.4 现实中的 Peterson 算法</h3><blockquote><p>“实现正确的 Peterson 算法” 是合理需求</p></blockquote><ul><li>编译器应该提供了机制实现</li></ul><blockquote><p>内存屏障 (Memory Barrier)</p></blockquote><ul><li><code>__sync_synchronize()</code> = Compiler Barrier +<ul><li>x86: <code>mfence</code></li><li>ARM: <code>dmb ish</code></li><li>RISC-V: <code>fence rw, rw</code></li></ul></li></ul><blockquote><p>编译器到底做了什么？</p></blockquote><ul><li><a href="https://godbolt.org/">godbolt.org</a>，不用装那些 cross compiler 了<ul><li>你甚至可以看到 compiler barrier 是如何在优化中传递的</li></ul></li></ul><h2 id="3-在多处理器上实现互斥">3 在多处理器上实现互斥</h2><p>继续回到厕所问题</p><blockquote><p>为什么不能就 “等在门口” 呢？</p></blockquote><ul><li>上一个人出来了，我再进去呗！</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> status = ✅;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">retry:</span><br><span class="line">    <span class="keyword">if</span> (status != ✅) &#123;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">    status = ❌;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    status = ✅;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 锁门的时候有人，不进去，不锁门的时候进去，但是这样是不可以的，因为两个线程同时进去的时候，都会观测到 ✅</span></span><br></pre></td></tr></table></figure><blockquote><p>没有跨语句 (指令) 的原子性？</p></blockquote><ul><li>Peterson 算法真是大费周章</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">retry:</span><br><span class="line">    <span class="keyword">if</span> (status != ✅) &#123;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">    status = ❌;</span><br></pre></td></tr></table></figure><blockquote><p>软件不够，硬件来凑</p></blockquote><ul><li>原子指令：一小段时间的 “Stop the World” 执行</li><li>不可打断的 load + 计算 + store<ul><li>x86: Bus Lock; RISC-V: LR/SC (来自 MIPS) + atomic</li></ul></li></ul><p><code>asm volatile(&quot;lock incq %0&quot; : &quot;+m&quot;(sum));  </code></p><p><img src="https://cdn-img-el3.pages.dev/os/c6-3-1.webp" alt="c6-3-1.webp"></p><h3 id="3-1-第一个自旋锁">3.1 第一个自旋锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原子交换操作atomic_xchg</span></span><br><span class="line"><span class="comment">// atomic_xchg就可以stop the world，所以实现了多线程的原子操作</span></span><br><span class="line"><span class="type">int</span> status = ✅;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">retry:</span><br><span class="line">    <span class="type">int</span> got = <span class="type">atomic_xchg</span>(&amp;status, ❌);</span><br><span class="line">    <span class="keyword">if</span> (got != ✅) &#123;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">atomic_xchg</span>(&amp;status, ✅);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有 “带条件写入” 的版本：节约写入内存带宽</p></blockquote><p><em>并发编程 “很难”：想要完全理解并发程序的行为，是非常困难的——我们甚至可以利用一个 “万能” 的调度器去帮助我们求解 NP-完全问题。因此，人类应对这种复杂性的方法就是退回到不并发。通过互斥实现 stop/resume the world，我们就可以使并发程序的执行变得更容易理解——而只要程序中 “能并行” 的部分足够多，串行化一小部分也并不会对性能带来致命的影响。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于对抽象的一点理解</title>
      <link href="/2024/05/29/programming/abstract/"/>
      <url>/2024/05/29/programming/abstract/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是抽象">1 什么是抽象</h2><h3 id="1-1-关于多态">1.1 关于多态</h3><p><em>在面向对象编程中，多态是指一类事物有多种形态。比如A类，A-1和A-2都属于动物类，它们都有A类中公共的方法</em></p><blockquote><p>由于多态的存在，每个子类都可以覆写父类的方法，例如下面的代码中子类1和2都覆写了父类中的某个方法：</p></blockquote><p>在这里，假如我们要设计一款游戏名叫 <strong>Apax</strong> 的枪械游戏。在这款游戏中，我们的武器就是枪械，所以我们来为我们的游戏设计一个 <code>Weapon</code> 类，它代表所有枪械的父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类-武器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">    <span class="comment">// 具有的方法</span></span><br><span class="line">    <span class="comment">// 子弹类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">WeaponAmmo</span><span class="params">()</span> &#123; … &#125;</span><br><span class="line">    <span class="comment">// 击中要害转化倍率</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">WeaponForce</span><span class="params">()</span> &#123; … &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类1-轻型弹药武器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LightAmmo</span> <span class="keyword">extends</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">WeaponAmmo</span><span class="params">()</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类2-霰弹类武器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShotgunAmmo</span> <span class="keyword">extends</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">WeaponAmmo</span><span class="params">()</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-关于抽象">1.2 关于抽象</h3><p>可以看到， <code>WeaponAmmo</code> 方法在子类中是覆写的父类的方法，并且父类也确实具有 <code>WeaponAmmo</code> 方法的实现。<strong>但是</strong>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">    <span class="comment">// 此处并未赋予WeaponAmmo方法任何实现，仅仅只是定义了WeaponAmmo方法的签名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">WeaponAmmo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把一个方法声明为 <code>abstract</code> ，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以， <code>Weapon</code> 类也无法被实例化。编译器会告诉我们，无法编译 <code>Weapon</code> 类，因为它包含抽象方法。必须把 <code>Weapon</code> 类本身也声明为 <code>abstract</code> ，才能正确编译它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">WeaponAmmo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个 <code>class</code> 定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用 <code>abstract</code> 修饰。</p><p>因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。</p><p>使用 <code>abstract</code> 修饰的类就是抽象类。我们无法实例化一个抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Weapon</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weapon</span>(); <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><blockquote><p>正确的方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 定义抽象类Weapon</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法，需要具体子类实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">WeaponAmmo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义LightAmmo类，继承自Weapon类并实现其抽象方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LightAmmo</span> <span class="keyword">extends</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">WeaponAmmo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用轻型弹药&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义主类Main，包含程序入口main方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建LightAmmo的实例并调用其方法</span></span><br><span class="line">        <span class="type">LightAmmo</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LightAmmo</span>();</span><br><span class="line">        w.WeaponAmmo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们定义了抽象类 <code>Weapon</code> ，以及具体的 <code>LightAmmo</code> 、 <code>ShotgunAmmo</code> 子类的时候，我们可以通过抽象类 <code>Weapon</code> 类型去引用具体的子类的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Weapon</span> <span class="variable">R301</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LightAmmo</span>();</span><br><span class="line"><span class="type">Weapon</span> <span class="variable">Peacekeeper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShotgunAmmo</span>();</span><br></pre></td></tr></table></figure><blockquote><p>这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</p></blockquote><p>面向抽象编程的本质就是：</p><ul><li><p>上层代码只定义规范；</p></li><li><p>不需要子类就可以实现业务逻辑；</p></li><li><p>具体的业务逻辑由不同的子类实现，调用者并不关心。</p></li></ul><h2 id="2-进一步理解抽象">2 进一步理解抽象</h2><p><em>将复杂的概念进行封装与简化</em></p><blockquote><p>抽象减少了信息的负载，否则需要全面详细地记录与处理事物的所有细节（熵减）。抽象的目标是简化看待事物的方式，允许忽略一些不重要的东西。</p></blockquote><ul><li><p>编程的时候，并不需要直接操作比特流，这一切都是编译器提供的功能。</p><ul><li>可以说编译器在编译的时候做了一层抽象。</li></ul></li><li><p>抽象就是隐藏细节，只暴露接口。在使用计算机的usb等接口的时候，我们只需要做连接操作，不需要关心它的具体实现。</p><ul><li>可以说计算机接口在运行的时候做了一层抽象。</li></ul></li></ul><p>在写代码的时候，我们可以在一开始就定义好接口，然后具体实现的时候再去实现。这样可以提高代码可读性且减少代码量与复杂度。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抽象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5. 多处理器编程：从入门到放弃</title>
      <link href="/2024/05/28/OS/class5/"/>
      <url>/2024/05/28/OS/class5/</url>
      
        <content type="html"><![CDATA[<h2 id="1-多处理器编程入门">1 多处理器编程入门</h2><h3 id="1-1-多线程编程模型">1.1 多线程编程模型</h3><blockquote><p>多个共享内存的状态机</p></blockquote><ul><li>C 语言状态机的多个线程<ul><li>共享所有全局变量</li><li>独立的栈帧列表</li></ul></li><li>汇编语言状态机的多个线程<ul><li>共享一个地址空间</li><li>独立的寄存器 (SP 指向不同内存位置)</li></ul></li></ul><blockquote><p>状态迁移</p></blockquote><ul><li>选择任意一个线程执行一步</li></ul><blockquote><p>Mosaic 状态机</p></blockquote><ul><li>“heap” 是共享内存</li><li>sys_sched 主动随机切换线程<ul><li>单处理器系统：中断会引起切换<ul><li>(这就是为什么死循环不能把机器卡死)</li></ul></li><li>多处理器系统：真正同时执行<ul><li>相当于无时不刻在切换</li></ul></li></ul></li></ul><blockquote><p>模拟多线程程序的行为</p></blockquote><ul><li>思考题：我们可以借助共享内存做什么？</li></ul><h3 id="1-2-多处理器编程：入门">1.2 多处理器编程：入门</h3><blockquote><p>简化的线程 API (使用thread.h库就可以直接create)</p></blockquote><ul><li><code>spawn(fn)</code><ul><li>创建一个入口函数是 <code>fn</code> 的线程，并立即开始执行<ul><li><code>void fn(int tid) &#123; ... &#125;</code></li><li>参数 <code>tid</code> 从 1 开始编号</li></ul></li><li>行为：<code>sys_spawn(fn, tid)</code></li></ul></li><li><code>join()</code><ul><li>等待所有运行线程的返回 (也可以不调用)</li><li>行为：<code>while (done != T) sys_sched()</code></li></ul></li></ul><blockquote><p>一个API搞定</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">T_a</span><span class="params">()</span> &#123; <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;a&quot;</span>); &#125; &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">T_b</span><span class="params">()</span> &#123; <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;b&quot;</span>); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    create(T_a);</span><br><span class="line">    create(T_b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实现多处理器的利用</p></blockquote><pre><code>- 操作系统会自动把线程放置在不同的处理器上- CPU 使用率超过了 100%</code></pre><h3 id="1-3-Q-A">1.3 Q&amp;A</h3><blockquote><p><code>T_a</code> 和 <code>T_b</code> 真的共享内存吗？</p></blockquote><ul><li>如何证明/否证这件事？</li></ul><blockquote><p>如何证明线程具有独立堆栈 (以及确定堆栈的范围)？</p></blockquote><ul><li>输出混乱，应该如何处理？</li></ul><blockquote><p>更多的 “好问题” 和解决</p></blockquote><ul><li><p>创建线程使用的是哪个系统调用？<br><code>man pthreads</code></p></li><li><p>能不能用 gdb 调试？</p><ul><li>基本原则：有需求，就能做到 (RTFM)</li></ul></li></ul><h2 id="2-放弃-1-：状态迁移原子性的假设">2 放弃 (1)：状态迁移原子性的假设</h2><p>当我们谈 “放弃” 时，放弃的并非并发编程，而是要舍弃一些我们之前对单线程顺序程序的理解。这些理解在我们长期的编程中，多多少少成为了肌肉记忆，这也是并发编程打破这些理解带来麻烦的原因。我们努力试图理解并发程序和顺序程序的本质区别，从而更好地应对并发带来的编程挑战。</p><h3 id="2-1-反思：状态机模型的隐含假设">2.1 反思：状态机模型的隐含假设</h3><blockquote><p>“世界上只有一个状态机”</p></blockquote><ul><li>没有其他任何人能 “干涉” 程序的状态</li><li>课堂上常用的简化方法<ul><li>假设一段程序执行没有系统调用</li><li>可以直接简化为一个原子的状态迁移 “计算”</li></ul></li></ul><h3 id="2-2-放弃-1-反思：状态机模型的隐含假设">2.2 放弃 (1)反思：状态机模型的隐含假设</h3><blockquote><p>共享内存推翻了 “原子性” 假设</p></blockquote><ul><li>任何时候，load 读到的值都可能是别的线程写入的</li><li>我们习以为常的简化会漏掉并发程序可能的行为<ul><li>如果你觉得你可能会犯错误，那别人也一定会的</li></ul></li></ul><blockquote><p>一些我们见到过的例子</p></blockquote><ul><li>线程的交错执行 <code>ABABAABB</code></li><li>消失的 1: <code>A2B2A3A5B5B6</code></li><li>潘多拉的魔盒已经打开……</li></ul><h3 id="2-3-并发Bugs">2.3 并发Bugs</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> balance = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">T_alipay_withdraw</span><span class="params">(<span class="type">int</span> amt)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (balance &gt;= amt) &#123;</span><br><span class="line">        balance -= amt;</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> FAIL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>两个线程并发支付 ¥100 会发生什么 (代码： <code>alipay.c</code> )</p></blockquote><p>当把usleep(1)取消注释后，程序执行将会无法合理计算，因为两个线程的执行顺序是随机的。</p><ul><li>账户里会多出用不完的钱！</li><li>历史事件：Mt. Gox Hack 损失 650, 000 BTC</li></ul><blockquote><p>计算 1+1+1+…+1 (sum.c)</p></blockquote><ul><li>共计 2n 个 1，分 2 个线程计算</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100000000</span></span><br><span class="line"><span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">T_sum</span><span class="params">()</span> &#123; <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) sum++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    create(T_sum);</span><br><span class="line">    create(T_sum);</span><br><span class="line">    join();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %ld\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>会得到怎样的结果？<br>基本上得不到同样的sum</li></ul><blockquote><p>正确实现并发 1 + 1 比想象中困难得多</p></blockquote><ul><li>1960s，大家争先在共享内存上实现原子性 (互斥)</li><li>但几乎所有的实现都是错的<ul><li>直到<a href="https://en.wikipedia.org/wiki/Dekker%27s_algorithm">Dekker’s Algorithm</a>的算法出现，还只能保证两个线程的互斥</li></ul></li></ul><blockquote><p>感到脊背发凉？</p></blockquote><ul><li>printf 还能在多线程程序里调用吗？<ul><li>当然可以，但会乱序执行</li></ul></li></ul><h3 id="2-4-失去“原子执行”的终极后果">2.4 失去“原子执行”的终极后果</h3><blockquote><p>并发执行三个 T_sum，sum 的最小值是多少？</p></blockquote><ul><li>初始时 sum = 0; 假设单行语句的执行是原子的</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">T_sum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t = load(sum);</span><br><span class="line">        t += <span class="number">1</span>;</span><br><span class="line">        store(sum, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>GPT-4: 细微改变问题会导致各种错误回答<ul><li>Claude 3 Opus 也不行，大模型没戏</li><li><a href="https://epubs.siam.org/doi/10.1137/S0097539794279614">Trace recovery is NP-Complete.</a></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sum_model</span></span><br><span class="line">mosaic -C sum.py | collect</span><br></pre></td></tr></table></figure><blockquote><p>Model Checker: sum = 2</p></blockquote><ul><li>是的，不是 1<ul><li>(因为有 <code>i</code> 的循环)</li></ul></li><li>也不是 3<ul><li>虽然 sum = 3 是很容易想到的</li></ul></li><li>无论有多少 <code>T_sum</code>，都可以 sum = 2</li></ul><blockquote><p>GPT-4 的 “直觉” 哪怕对最 “简单” 的并发程序都不起效</p></blockquote><h3 id="2-5-“数学视角”的价值">2.5 “数学视角”的价值</h3><blockquote><p>对于并发，讲概念是不够的</p></blockquote><ul><li>事实可能不是你想的那样</li></ul><blockquote><p>甚至讲代码都是不够的</p></blockquote><ul><li>代码需要非常精巧的 workload 才能跑出那个 corner case</li></ul><blockquote><p>证明才是解决问题的方法</p></blockquote><p>证明：∀ 线程调度方法，程序满足 XXX 性质。</p><ul><li>我们现在甚至还没有趁手的并发程序证明工具！</li><li>对于课堂的例子，model checker 倒也够用了</li></ul><h2 id="3-放弃-2-：程序顺序执行的假设">3 放弃 (2)：程序顺序执行的假设</h2><h3 id="3-1-状态机模型的隐含假设">3.1 状态机模型的隐含假设</h3><blockquote><p>“世界上只有一个状态机”</p></blockquote><ul><li>没有其他任何人能 “干涉” 程序的状态</li><li>课堂上常用的简化方法<ul><li>假设一段程序执行没有系统调用</li><li>可以直接简化为一个原子的状态迁移 “计算”</li></ul></li></ul><blockquote><p>编译器也做了同样的假设</p></blockquote><ul><li>编译器会试图优化状态迁移，改变执行流</li></ul><h3 id="3-2-放弃程序按顺序执行的假设">3.2 放弃程序按顺序执行的假设</h3><blockquote><p>共享内存推翻了编译器的假设</p></blockquote><ul><li>但编译器依然会按照顺序执行优化代码</li><li>否则几乎任何涉及共享内存的代码都变得 “不可优化”</li></ul><blockquote><p>程序的行为在并发编程下变得更难理解了</p></blockquote><ul><li>“顺序程序” 变得一点也不 “顺序” 了</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100000000</span></span><br><span class="line"><span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">T_sum</span><span class="params">()</span> &#123; <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) sum++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    create(T_sum);</span><br><span class="line">    create(T_sum);</span><br><span class="line">    join();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %ld\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果添加编译优化？</p></blockquote><ul><li><code>-O1</code>: 100000000</li><li><code>-O2</code>: 200000000</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!flag);</span><br></pre></td></tr></table></figure><blockquote><p>“等另一个线程举起旗子，我再继续”？</p></blockquote><ul><li>如果这是个顺序程序，编译器可以做什么优化？<ul><li>(这甚至也是一个常见的并发 bug 模式)</li><li>“Ad hoc synchronization considered harmful”</li></ul></li></ul><blockquote><p>方法 1：插入 “不可优化” 代码</p></blockquote><ul><li>asm volatile (“” ::: “memory”);<ul><li>告诉编译器其他线程可能写入内存</li></ul></li></ul><blockquote><p>方法 2：标记变量 load/store 为不可优化</p></blockquote><ul><li>使用 volatile 修饰变量可以做到</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">volatile</span> flag;</span><br><span class="line"><span class="keyword">while</span> (!flag);</span><br></pre></td></tr></table></figure><blockquote><p>以上都不是《操作系统》课推荐的方法</p></blockquote><ul><li>“一把大锁保平安” 加锁 ✔</li></ul><h2 id="4-放弃-3-：存在全局指令执行顺序的假设">4 放弃 (3)：存在全局指令执行顺序的假设</h2><h3 id="4-1-状态机模型的隐含假设">4.1 状态机模型的隐含假设</h3><blockquote><p>状态迁移</p></blockquote><ul><li>选择一个线程，执行一条指令</li><li>“顺序一致性” (sequential consistency)</li></ul><blockquote><p>单处理器多线程符合这个假设</p></blockquote><ul><li>处理器会保证指令 “看起来” 顺序完成</li><li>处理器也是编译器 (oops… 感觉不好的事情要发生了)<ul><li>预取状态机执行的若干步，然后像编译器一样优化</li><li>Load(x); Store(y)</li><li>𝑥≠𝑦 → 两条指令执行的先后顺序就无所谓</li><li>Load cache miss → store 可以直接执行</li></ul></li></ul><h3 id="4-2-放弃全局顺序存在的假设">4.2 放弃全局顺序存在的假设</h3><blockquote><p>共享内存推翻了 “统一上帝视角” 的存在性</p></blockquote><ul><li>就像相对论中，时间顺序的相对性<ul><li>𝐴 和 𝐵 没有因果关系，例子：Load(x) v.s. Store(y)</li><li>两个观测者可以分别看到 𝐴→𝐵 或 𝐵→𝐴</li><li>观测的相对性使全局世界的行为 “极难理解”</li></ul></li></ul><blockquote><p>不同处理器可能看到不同的共享内存</p></blockquote><ul><li>“一个共享内存” 只是个简化的幻觉</li><li>Reading: <a href="https://research.swtch.com/mm">Memory Models</a> by Russ Cox</li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c5-4.2-1.webp" alt="c5-4.2-1.webp"></p><p>实际上：</p><p><img src="https://cdn-img-el3.pages.dev/os/c5-4.2-2.webp" alt="c5-4.2-2.webp"></p><h3 id="4-3-“相对论效应”带来的后果">4.3 “相对论效应”带来的后果</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//men-model.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">T1</span><span class="params">()</span> &#123;</span><br><span class="line">  x = <span class="number">1</span>; <span class="type">int</span> t = y; <span class="comment">// Store(x); Load(y)</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">T2</span><span class="params">()</span> &#123;</span><br><span class="line">  y = <span class="number">1</span>; <span class="type">int</span> t = x; <span class="comment">// Store(y); Load(x)</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Model Checker: 01 10 11</p></blockquote><ul><li>实际：00 (???) 未被观测到</li></ul><blockquote><p>CPU 设计者面临了难题</p></blockquote><ul><li>更强的内存模型 = 更糟糕的性能，但更容易编程</li><li>x86：市面 “最强” 内存模型 (类比 ARM/RISC-V)</li></ul><blockquote><p>因此，在 ARM 上模拟 x86 是个世界性的难题</p></blockquote><p><em>在简化多线程的模型中，并发程序就是 “状态机的集合”，每一步选一个状态机执行一步。然而，真实的系统却因为 “编译器” 的无处不在，使共享内存并发的行为十分复杂。</em></p><p><em>不幸的是，人类本质上是物理世界 (宏观时间) 中的 “sequential creature”，因此我们在编程时，我们的直觉也只习惯于单线程的顺序/选择/循环结构，真实多处理器上的并发编程是非常具有挑战性的 “底层技术”。在后续的课程中，我们将会提出若干并发控制技术，使得我们可以在需要的时候避免并发的发生，使并发程序退回到顺序程序，从而使我们能够理解和控制并发。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4. 数学视角的操作系统</title>
      <link href="/2024/05/27/OS/class4/"/>
      <url>/2024/05/27/OS/class4/</url>
      
        <content type="html"><![CDATA[<h2 id="1-程序正确性证明">1 程序正确性证明</h2><blockquote><p>数千年来，数学的“严格性”都是由人类保证的</p></blockquote><h3 id="1-1-程序的本质">1.1 程序的本质</h3><blockquote><p>程序是一种 “数学严格” 的对象</p></blockquote><ul><li><p>Everything is a state machine</p><ul><li>程序 = 初始状态 + 迁移函数</li><li>在这个视角下，程序和数学对象已经无限接近了</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f(s) = s&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8019em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></p></li><li><p>我们经常写出 “似是而非” 的代码</p></li><li><p>类似于细节有错但可以修正的数学证明</p><ul><li><code>for (int j = 0; j &lt; n; i++)</code></li><li>(有时候也会疏忽，导致设计全错)</li></ul></li></ul><blockquote><p>为什么会有程序？</p></blockquote><ul><li>是因为我们有无情的执行指令的机器 (计算机)</li><li>只有程序才配得上它</li></ul><blockquote><p>程序天生是 “人类” 的，也是 “反人类” 的</p></blockquote><ul><li>人类的一面：程序连接了人类世界需求<ul><li>程序写的一切都能在现实生活观测到</li><li>我们并不是在实现 “uniform-random” 的 𝑓</li></ul></li><li>反人类的一面：程序会在机器上执行<ul><li>初学者对 “机器严格” 普遍不太适应</li><li>部分原因是对程序的行为没有 100% 的掌控</li><li>使用秘技：debug来观察程序的行为</li></ul></li></ul><h3 id="1-2-当我们谈论数学的时候，我们想谈论什么？">1.2 当我们谈论数学的时候，我们想谈论什么？</h3><blockquote><p>证明程序正确性！</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AlipayAccount</span>:</span><br><span class="line">    b: <span class="built_in">int</span> = <span class="number">0</span>  <span class="comment"># Balance</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">...</span>): ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">...</span>): ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transfer</span>(<span class="params">...</span>): ...</span><br></pre></td></tr></table></figure><blockquote><p>针对这段python代码，我们可以用数学的语言提出程序的规约</p></blockquote><ul><li>例如：任意时刻 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi mathvariant="normal">.</mi><mi>b</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a.b≥0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal">a</span><span class="mord">.</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></li><li>有没有可能真正 “证明” 它呢？<br>任意状态中b都大于0</li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c4-1.2-1.webp" alt="证明方式"></p><h3 id="1-3-程序正确性证明的两种方法">1.3 程序正确性证明的两种方法</h3><blockquote><p>暴力枚举-启发</p></blockquote><ul><li>写一个 driver code，运行所有可能的函数调用序列，proof assistant 帮助我们检查<ul><li>PL/SE 已经研究生成 driver code 几十年了</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>t</mi><mo stretchy="false">(</mo><mi>b</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">assert(b≥0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">sser</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></li></ul></li><li>如果机器和 driver 都没有 bug，程序就是对的</li></ul><blockquote><p>写出证明-启发</p></blockquote><ul><li>我们可以多写<code>assert</code>断言来避免出错</li><li>For all 𝑓 - reachable states, b≥0 holds.</li><li>为 𝑓 写一份数学证明就行了<ul><li>就像你在上数学课时做的习题一样</li></ul></li></ul><p>没错，计算机科学和数学的发展速度可能超过大家的想象——我们有被 “证明正确” 的 编译器、操作系统内核；可以阅读科普文章：</p><p><em>Formal verification doesn’t result in perfect code; it simply narrows the possibility for errors and vulnerabilities to creep in, ” Parno says. “What makes the technique so attractive is that you push the uncertainty or scope of problems down to smaller and smaller windows.</em></p><p><em>同时，proof assistant 也是人工智能时代堪称完美的辅助工具：如果我们要信任 AI 产生的结果，就让它们给出一个 proof assistant 认可的证明吧！</em></p><h2 id="2-为操作系统建模">2 为操作系统建模</h2><h3 id="2-1-操作系统的两个视角">2.1 操作系统的两个视角</h3><blockquote><p>应用视角 (自顶向下)</p></blockquote><ul><li>操作系统 = 对象 + API<ul><li>应用通过 <code>syscall</code> 访问操作系统</li></ul></li></ul><blockquote><p>机器视角 (自底向上)</p></blockquote><ul><li>操作系统 = C 程序<ul><li>运行在计算机硬件上的一个普通程序</li></ul></li></ul><h3 id="2-2-为操作系统建模">2.2 为操作系统建模</h3><blockquote><p>操作系统 = 状态机的管理者（状态机的容器）</p></blockquote><ul><li>当然，它自己也是状态机，有自己的状态</li></ul><blockquote><p>有了一个有趣的想法……</p></blockquote><ul><li>能不能我们自己定义 “状态机”<ul><li>用我们喜欢的语言、喜欢的方式</li><li>不要受限于 C、汇编……</li></ul></li><li>自己模拟状态机的执行<ul><li>形成一个 “玩具操作系统”</li></ul></li></ul><blockquote><p>简化的操作系统模型</p></blockquote><ul><li>用更方便的编程语言描述状态机<ul><li>依然是程序</li><li>依旧是 “数学严格” 的对象</li></ul></li><li>但用更简单的方法实现操作系统<ul><li>管理状态机</li><li>执行系统调用</li></ul></li></ul><h3 id="2-3-表示状态机">2.3 表示状态机</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">StateMachine</span>():</span><br><span class="line">    b = sys_read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        sys_write(<span class="string">&#x27;I got a zero.&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sys_write(<span class="string">&#x27;I got a one.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    sys_spawn(StateMachine)</span><br></pre></td></tr></table></figure><blockquote><p>系统调用</p></blockquote><ul><li>read(): 返回随机的 0 或 1</li><li>write(s): 向 buffer 输出字符串 <code>s</code></li><li>spawn(f): 创建一个可运行的状态机 <code>f</code></li></ul><blockquote><p>操作系统中的对象</p></blockquote><ul><li>状态机 (进程)<ul><li>Python 代码</li><li>初始时，仅有一个状态机 (main)</li><li>允许执行计算或 read, write, spawn 系统调用</li></ul></li><li>一个进程间共享的 buffer (“设备”)</li></ul><blockquote><p>因为 spawn 的存在，操作系统中有多个状态机 (进程)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以拿到一个python模拟的状态机</span></span><br><span class="line">wget -r -np -nH --cut-dirs=2 -R <span class="string">&quot;index.html*&quot;</span> <span class="string">&quot;https://jyywiki.cn/os-demos/introduction/os-model/&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#链接中的proc.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Process</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        sys_write(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    sys_spawn(Process, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    sys_spawn(Process, <span class="string">&#x27;B&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>操作系统会 “雨露均沾” 地运行它们</li><li>但 buffer 是所有状态机共享的<ul><li>于是有了并发……</li><li>操作系统是最早的实用并发程序</li></ul></li></ul><h2 id="3-数学视角的操作系统">3 数学视角的操作系统</h2><blockquote><p>状态</p></blockquote><ul><li>多个 “应用程序” 状态机<ul><li>当然，可以是模型</li></ul></li></ul><blockquote><p>初始状态</p></blockquote><ul><li>仅有一个 “main” 状态机<ul><li>这个状态机处于初始状态</li></ul></li></ul><blockquote><p>迁移</p></blockquote><ul><li>选择一个状态机执行一步<ul><li>就像我们在操作系统模型上看到的那样</li></ul></li></ul><h3 id="3-1-计算机系统中的不确定性">3.1 计算机系统中的不确定性</h3><blockquote><p>ps: 算法定义：一个有穷的指令集，这些指令为解决某一特定任务规定了一个运算序列 （就是一个描述集，就是一个指令集，就是一个序列集）</p></blockquote><blockquote><p>调度：状态机的选择不确定（并发：反人类直觉的一个过程）</p></blockquote><ul><li><code>current = random.choice(self.procs)</code></li><li>操作系统每次可以随机选择一个状态机执行一步</li></ul><blockquote><p>I/O：系统外的输入不确定</p></blockquote><ul><li>read 返回的结果也有两种可能性</li><li><code>t = sys_read()</code> 后，可能 t=0 或 t=1</li></ul><blockquote><p>推论：我们得到了状态图</p></blockquote><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑢</mi><mo>→</mo><mi>𝑣</mi><mo>⇔</mo><mi>𝑢</mi></mrow><annotation encoding="application/x-tex">𝑢→𝑣⇔𝑢</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> 可以通过一步迁移到达 𝑣</li><li>当然，我们只关心<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">s_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>可达的状态</li></ul><blockquote><p>Breadth-first search（广度优先算法）可以构建 “状态图”</p></blockquote><p><img src="https://cdn-img-el3.pages.dev/os/maze.webp" alt="maze.webp"></p><h3 id="3-2-蛮力法-Brute-force">3.2 蛮力法(Brute-force)</h3><blockquote><p>想要证明程序的性质？</p></blockquote><ul><li>只要稍微 “修改” 一下模拟器的实现就行了</li></ul><blockquote><p>构建状态图，检查程序正确性</p></blockquote><ul><li>read()：创建两个状态，分别是 𝑟=0和 𝑟=1</li><li>调度：为每个进程 𝑝 创建一个状态，对应选择 𝑝 执行</li><li>程序正确：不存在从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">s_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>可达的 “坏状态”<ul><li>例如：最终 buffer 中 A 和 B 的数量相同</li><li>“模型检查器”；Turing Award Lecture</li></ul></li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c4-3.2-1.webp" alt="c4-3.2-1.webp"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下面是我们绘制一个 “Hello World” 状态空间的例子。Hello 会调用一个有趣的系统调用 fork，它的行为是复制状态机的当前状态：</span></span><br><span class="line">wget -r -np -nH --cut-dirs=2 -R &quot;index.html*&quot; &quot;https://jyywiki.cn/os-demos/mosaic/mosaic/&quot;</span><br></pre></td></tr></table></figure><p><em>程序就是状态机；状态机可以用程序表示。因此：</em></p><ul><li>我们可以用更 “简单” 的方式 (例如 Python) 描述状态机、建模操作系统上的应用，并且实现操作系统的可执行模型。</li><li>一旦把操作系统、应用程序当做 “数学对象” 处理，那么我们图论、数理逻辑中的工具就能被应用于处理程序——例如，可以用图遍历 “暴力枚举” 的方法证明程序的正确性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-绪论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.应用视角的操作系统</title>
      <link href="/2024/05/25/OS/class2/"/>
      <url>/2024/05/25/OS/class2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-操作系统上的最小应用程序">1. 操作系统上的最小应用程序</h2><h3 id="要想理解-“操作系统”，就要理解什么是-“程序”">要想理解 “操作系统”，就要理解什么是 “程序”</h3><ul><li><strong>一个Hello World示例</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>实际上，这个Hello World并不小</strong></p><ul><li><p>当我们使用objdump工具查看这个Hello World后可以发现：</p><ul><li><code>--verbose</code>可以查看所有编译选项 (真不少)<ul><li>printf 变成了 puts@plt</li></ul></li></ul></li><li><p><code>-Wl,--verbose</code>可以查看所有链接选项 (真不少)</p><ul><li>原来链接了那么多东西</li><li>还解释了 end 符号的由来</li></ul></li><li><p><code>-static</code> 会链接 libc (大量的代码)</p></li></ul></li><li><p><strong>Hello World的最小实现</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line"></span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">  movq $SYS_write, %rax   # write(</span><br><span class="line">  movq $1,         %rdi   #   fd=1,</span><br><span class="line">  movq $st,        %rsi   #   buf=st,</span><br><span class="line">  movq $(ed - st), %rdx   #   count=ed-st</span><br><span class="line">  syscall                 # );</span><br><span class="line"></span><br><span class="line">  movq $SYS_exit,  %rax   # exit(</span><br><span class="line">  movq $1,         %rdi   #   status=1</span><br><span class="line">  syscall                 # );</span><br><span class="line"></span><br><span class="line">st:</span><br><span class="line">  .ascii &quot;\033[01;31mHello, OS World\033[0m\n&quot;</span><br><span class="line">ed:</span><br></pre></td></tr></table></figure><p>下面我们在shell中编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc minimal.S -c &amp;&amp; ld minimal.o</span><br><span class="line">./a.out</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Hello, OS World</span></span><br></pre></td></tr></table></figure><p>这就是一个minimal. S</p><ul><li><strong>什么是程序：</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CPUState</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> regs[<span class="number">32</span>], csrs[CSR_COUNT];</span><br><span class="line">    <span class="type">uint8_t</span> *mem;</span><br><span class="line">    <span class="type">uint32_t</span> mem_offset, mem_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>处理器：无情的、执行指令的状态机</strong><ul><li>从M[PC] 取出一条指令</li><li>执行它</li><li>循环往复</li></ul></li></ul><h3 id="解决程序异常退出">解决程序异常退出</h3><ul><li><p><strong>程序自己是不能 “停下来” 的</strong></p><ul><li>指令集里没有一条关闭计算机的指令，那么操作系统是如何在关闭所有软件后，切断计算机的电源的？</li></ul></li><li><p><strong>只能借助操作系统</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $SYS_exit,  %rax   # exit(</span><br><span class="line">movq $1,         %rdi   #   status=1</span><br><span class="line">syscall                 # );</span><br></pre></td></tr></table></figure><ul><li>把 “系统调用” 的参数放到寄存器中</li><li>执行 syscall，操作系统接管程序<br>操作系统可以任意改变程序状态 (甚至终止程序)</li></ul><h3 id="所有二进制程序-状态机">所有二进制程序 = 状态机</h3><ul><li><strong>状态</strong><ul><li>gdb 内可见的内存和寄存器</li></ul></li><li><strong>初始状态</strong><ul><li>由 ABI 规定 (例如有一个合法的 %rsp)</li></ul></li><li><strong>状态迁移</strong><ul><li>执行一条指令<ul><li>我们花了一整个《计算机系统基础》解释这件事</li><li>gdb 可以单步观察状态机的执行</li></ul></li><li><strong>syscall</strong> 指令: 将状态机 “完全交给” 操作系统</li></ul></li></ul><h2 id="2-操作系统上的应用程序">2. 操作系统上的应用程序</h2><ul><li><p><strong>应用程序和minimal. S 一样，都是状态机</strong></p><ul><li>任何程序 = minimal. S =  状态机<ul><li>总是从被操作系统加载开始<ul><li>通过另一个进程执行 execve 设置为初始状态</li></ul></li><li>经历状态机执行 (计算 + syscalls)<ul><li>进程管理：fork, execve, exit, …</li><li>文件/设备管理：open, close, read, write, …</li><li>存储管理：mmap, brk, …</li></ul></li><li>最终调用 _exit (exit_group) 退出</li></ul></li></ul></li><li><p><strong>可执行文件是操作系统中的对象</strong></p><ul><li>与 minimal 的二进制文件没有本质区别</li><li>我们甚至可以像文本一样直接编辑可执行文件</li></ul></li><li><p><strong>一切应用程序的实现：</strong></p><ul><li>应用程序 = 计算 + 操作系统 API<ul><li>窗口管理器<ul><li>能直接管理屏幕设备 (read/write/mmap)<ul><li>能画一个点，理论上就能画任何东西</li></ul></li><li>能够和其他进程通信 (send, recv)</li></ul></li><li>任务管理器<ul><li>能访问操作系统提供的进程对象 (M1 - pstree)</li></ul></li><li>杀毒软件<ul><li>文件静态扫描 (read)、主动防御 (ptrace)</li></ul></li></ul></li></ul></li><li><p><strong>操作系统的职责：提供令应用程序舒适的抽象 (对象 + API)</strong></p></li></ul><h2 id="3-编译器与编译优化">3. 编译器与编译优化</h2><h3 id="3-1-什么是编译器">3.1 什么是编译器</h3><ul><li>编译器的输入<ul><li>高级语言 ( C ) 代码 = 状态机</li></ul></li><li>编译器的输出<ul><li>汇编代码 (指令序列) = 状态机</li></ul></li><li>编译器 = 状态机之间的翻译器</li></ul><h3 id="3-2-为什么c被称为高级汇编语言">3.2 为什么c被称为高级汇编语言</h3><ul><li>存在 C 代码到指令集的直接对应关系<ul><li>状态机和迁移都可以 “直译”</li><li>于是计算机系统里多了一个抽象层 (“一生二、二生三、三生万物”)</li></ul></li><li>更 “高级” 的语言就很难了<ul><li>C++ virtual void foo();</li><li>Python [1, 2, 3, *rest]</li><li>Javascript await fetch(…)</li></ul></li></ul><p><em>Everything (高级语言代码、机器代码) 都是状态机；而编译器实现了两种状态机之间的翻译。无论何种状态机，在没有操作系统时，它们只能做纯粹的计算，甚至都不能把结果传递到程序之外——而程序与操作系统沟通的唯一桥梁是系统调用 (例如 x86-64 的 syscall 指令)。如此重要的桥梁，操作系统中自然也有工具：strace 可以查看程序运行过程中的系统调用序列。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-绪论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.硬件视角的操作系统</title>
      <link href="/2024/05/25/OS/class3/"/>
      <url>/2024/05/25/OS/class3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-计算机系统的状态机模型">1 计算机系统的状态机模型</h2><h3 id="1-1-一切皆为状态机">1.1 一切皆为状态机</h3><ul><li>C 代码 = 状态机<ul><li>SimpleC &amp; GDB (TUI source)</li></ul></li><li>汇编代码 = 状态机<ul><li>GDB (TUI assembly)</li></ul></li><li>处理器 = 状态机<ul><li>mini-rv32ima; ICS PA</li></ul></li><li>数字电路 = 状态机<ul><li>Logisim</li></ul></li></ul><h3 id="1-2-计算机系统的状态机模型">1.2 计算机系统的状态机模型</h3><ul><li>状态<ul><li>内存、寄存器的数值</li></ul></li><li>初始状态<ul><li>由系统设计者规定 (CPU Reset)</li></ul></li><li>状态迁移<ul><li>从 PC 取指令执行</li></ul></li></ul><p>基本准确；但我们可以做一些补充</p><h4 id="1-2-1-计算机系统：状态">1.2.1 计算机系统：状态</h4><ul><li>寄存器、内存</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CPUState</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> regs[<span class="number">32</span>], csrs[CSR_COUNT];</span><br><span class="line">    <span class="type">uint8_t</span> *mem;</span><br><span class="line">    <span class="type">uint32_t</span> mem_offset, mem_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>还有外部世界的态</li><li>设备上的寄存器 (memory-mapped I/O 可以访问)</li><li>Interrupt/Reset Line</li><li><strong>客观存在，但计算机系统不能直接访问</strong><ul><li>类比：进程只能通过 syscall 访问进程外的信息</li></ul></li></ul><h4 id="1-2-2-计算机系统：初始状态">1.2.2 计算机系统：初始状态</h4><blockquote><p>CPU Reset</p></blockquote><ul><li>Intel 的工程师已经规定好，x86 处理器复位：<ul><li><code>EIP = 0x0000fff0</code></li><li><code>CR0 = 0x60000010</code><ul><li>处理器处于 16-bit 模式</li></ul></li></ul></li><li>RISC-V：百花齐放，百家争鸣<ul><li>初始 PC 无规定；寄存器除了 x0 全部 undefined</li><li>少数 CSR 有规定 (例如 interrupt disabled)<ul><li>设计原则：省电路</li><li>软件能做的，硬件绝对不管</li></ul></li></ul></li></ul><h4 id="1-2-3-计算机系统：状态迁移">1.2.3 计算机系统：状态迁移</h4><p><strong>执行指令</strong></p><ul><li>如果有多个处理器？<ul><li>可以想象成 “每次选一个处理器执行一条指令”</li></ul></li></ul><p><strong>响应中断</strong></p><ul><li>if (intr) goto vec;</li></ul><p><strong>输入输出</strong></p><ul><li>与 “计算机系统外” 交换数据</li><li>类似于程序：不使用 syscall 就等于死循环</li></ul><h2 id="2-固件：接管计算机系统的第一个程序">2 固件：接管计算机系统的第一个程序</h2><h3 id="2-1-计算机系统-状态机">2.1 计算机系统 = 状态机</h3><p><strong>程序员如何控制计算机系统？</strong></p><ul><li>仅有 RESET 状态是不够的</li><li>答案：计算机系统会和 System Programmers 达成约定</li></ul><h3 id="2-2-Firmware">2.2 Firmware</h3><p><strong>“固件”</strong></p><ul><li>厂商 “固定” 在计算机系统里的代码<ul><li>早期：固件是 ROM</li><li>想升级？换芯片！</li></ul></li></ul><p><strong>Firmware 的功能</strong></p><ul><li>运行程序前的计算机系统配置<ul><li>CPU 电压、内存时序、接口开关……</li><li>(这些配置要生效可能需要重启计算机)</li></ul></li><li>不严格地说，<strong>加载操作系统</strong><ul><li>QEMU：可以绕过 Firmware 直接加载操作系统 (RTFM)</li></ul></li></ul><p><em>Firmware：配置计算机系统</em><br><img src="https://cdn-img-el3.pages.dev/os/bios-1.webp" alt="bios-1"></p><p><em>Firmware：加载存储设备上的引导程序</em><br><img src="https://cdn-img-el3.pages.dev/os/bios-2.webp" alt="bios-2"></p><p><strong>Firmware：就是一段代码</strong></p><ul><li>一个小 “操作系统”<ul><li>CPU Reset 后初始化硬件；对接操作系统 Boot Loader</li></ul></li><li>Legacy BIOS (Basic I/O System)<ul><li>IBM PC 所有设备/BIOS 中断是有 specification 的<ul><li>16-bit DOS 时代 BIOS 常驻内存，提供 I/O 等功能</li></ul></li><li>成就了百花齐放的 “兼容机” 时代<ul><li>AMI 和 Phoenix BIOS, 等都活到了今天！</li></ul></li></ul></li><li>UEFI (Unified Extensible Firmware Interface)<ul><li>提供更丰富的支持 (例如设备驱动程序)：指纹锁、山寨网卡上的 PXE 网络启动、USB 蓝牙转接器连接的蓝牙键盘……</li></ul></li></ul><p><em>计算机系统是严格的数学对象：没有魔法；计算机系统的一切行为都是可观测、可理解的。</em></p><ul><li><em>处理器是无情的执行指令的机器。</em></li><li><em>处理器会规定好 Reset 后的行为。</em></li><li><em>Reset 后 Firmware 开始运行，再加载操作系统。</em></li><li><em>厂商逐渐形成了达成共识的 Firmware Specification (IBM PC “兼容机”、UEFI、……)。</em></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-绪论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. 操作系统概述</title>
      <link href="/2024/05/24/OS/class1/"/>
      <url>/2024/05/24/OS/class1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>课程来源:b站-绿导师原谅你了<a href="https://space.bilibili.com/202224425/channel/collectiondetail?sid=2237004&amp;spm_id_from=333.788.0.0">“操作系统：设计与实现”(蒋炎岩)</a></p></blockquote><h2 id="教材"><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">教材</a></h2><h2 id="1-为什么要学操作系统">1. 为什么要学操作系统</h2><h3 id="1-1-为什么要学xxx">1.1 为什么要学xxx</h3><ul><li>理解这门学科为了解决什么样的问题</li><li>重走一遍前人的发现历程</li><li>最终为了做到应用、创新、革命</li><li>了解到这门学科能做什么，不能做什么，知道这门技术的边界在哪里</li></ul><h2 id="2-什么是操作系统">2. 什么是操作系统</h2><blockquote><p>Operating System: A body of software, in fact, that is responsible for making it easy to run programs (even allowing you to seemingly run many at the same time), allowing programs to share memory, enabling programs to interact with devices, and other fun stuff like that. (OSTEP)</p></blockquote><h3 id="2-1-什么是操作系统">2.1 什么是操作系统</h3><p>简单的说，操作系统就是管理软/硬件资源、为程序提供服务的程序。</p><p><img src="https://cdn-img-el3.pages.dev/os/os-1-1.webp" alt="os-1-1"></p><ul><li>操作系统如何从一开始变成现在这样的？</li><li>三个重要的线索<br>硬件 (计算机)、软件 (程序)、操作系统 (管理硬件和软件的软件)</li></ul><h3 id="2-2前导知识">2.2前导知识</h3><ul><li>高级语言代码 → 指令序列 → 二进制文件 → 处理器执行<ul><li>前导课程目标：能将需求实现；掌握工具使用；阅读汇编指令</li></ul></li></ul><h3 id="3-3-理解操作系统">3.3 理解操作系统</h3><ul><li>操作系统他是在计算机硬件软件发展历史之间出现的一个产物。</li></ul><blockquote><h3 id="1940s">1940s</h3></blockquote><ul><li>在没有操作系统、甚至连编程语言都没有的时候，人们还在画流程图、写机制代码、戳纸袋，这个阶段，能把程序跑起来就很了不起了。</li></ul><blockquote><h3 id="1950s-1960s">1950s-1960s</h3></blockquote><ul><li><p>这个阶段，硬件改进了，逻辑门-存储-I/O 的基本格局没有变。</p><ul><li>晶体管、磁芯内存、丰富的 I/O 设备</li><li>I/O 设备的速度严重低于处理器的速度，中断机制出现 (1953)</li></ul></li><li><p>更复杂的通用的数值计算</p><ul><li>高级语言和 API 诞生 (Fortran, 1957)：一行代码，一张卡片80 行的规范沿用至今</li></ul></li></ul><p><img src="https://cdn-img-el3.pages.dev/os/os-1-2.webp" alt="os-1-2"></p><ul><li><p>Fortran 已经 “足够好用”</p><ul><li>迎来了自然科学、工程机械、军事……对计算机的需求暴涨</li></ul></li><li><p>库函数 + 管理程序排队运行的调度代码</p><ul><li>写程序 (戳纸带)、跑程序都是非常费事的</li><li>计算机非常贵<ul><li>$50,000−$1,000,000</li><li>通常一个学校只有一台</li></ul></li></ul></li><li><p>算力成为服务，操作系统概念形成</p><ul><li>多用户轮流共享计算机，operator 负责操作程序切换</li><li>Operating systems (操作系统/作業系統)<ul><li>(今天算力又成为服务了-<em>人工智能</em>)</li></ul></li></ul></li><li><p>CTSS (Compatible Time-Sharing System)</p></li></ul><blockquote><h3 id="1960s-1970s">1960s-1970s</h3></blockquote><ul><li><p>集成电路、总线出现</p></li><li><p>更多的高级语言和编译器出现</p></li><li><p>个人电脑登上历史舞台</p></li><li><p>能载入多个程序到内存且调度它们的管理程序</p><ul><li>为防止程序之间形成干扰，操作系统自然地将共享资源 (如设备) 以 API 形式管理起来<ul><li>有了进程 (process) 的概念</li><li>进程在执行 I/O 时，可以将 CPU 让给另一个进程<ul><li>在多个地址空间隔离的程序之间切换</li><li>虚拟存储使一个程序出 bug 不会 crash 整个系统</li></ul></li></ul></li></ul></li><li><p>操作系统中自然地增加进程管理 API</p></li></ul><blockquote><h3 id="1970s">1970s+</h3></blockquote><ul><li>分时系统走向成熟，UNIX 诞生并走向完善，奠定了现代操作系统的形态</li></ul><h2 id="3-如何学操作系统">3. 如何学操作系统</h2><blockquote><p><strong>试着去成为一个有 CS 梦想的人</strong></p></blockquote><p>是一个合格的操作系统用户</p><ul><li>会 STFW/RTFM/ATFAI 自己动手解决问题，进而，不怕使用任何命令行工具vim, tmux, grep, gcc, binutils, …</li><li>不怕 (或者爱上) 写代码<ul><li>能管理一定规模 (数千行) 的代码</li><li>在出 bug 时默念 “机器永远是对的、我肯定能调出来的”<ul><li>然后开始用正确的工具/方法调试</li></ul></li></ul></li></ul><p><em>操作系统是软件和硬件之间的桥梁；因此我们 “找到” 一些合适的软件、一些相对简单的硬件，理解操作系统就会变得容易。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-绪论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2024/05/23/2024-5/2024-5-23/"/>
      <url>/2024/05/23/2024-5/2024-5-23/</url>
      
        <content type="html"><![CDATA[<blockquote><h2 id="测试">测试</h2></blockquote><p>​这篇测试文章将会是我的第一篇文章，立下flag，今后我将会记录我的一些：</p><ul><li>学习笔记</li><li>遇到并解决的问题</li><li>随笔</li></ul>]]></content>
      
      
      <categories>
          
          <category> 第一篇文档分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第一篇文档标签 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
