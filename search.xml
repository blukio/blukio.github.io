<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>4. 数学视角的操作系统</title>
      <link href="/2024/05/27/OS/class4/"/>
      <url>/2024/05/27/OS/class4/</url>
      
        <content type="html"><![CDATA[<h2 id="1-程序正确性证明">1 程序正确性证明</h2><blockquote><p>数千年来，数学的“严格性”都是由人类保证的</p></blockquote><h3 id="1-1-程序的本质">1.1 程序的本质</h3><blockquote><p>程序是一种 “数学严格” 的对象</p></blockquote><ul><li>Everything is a state machine<ul><li>程序 = 初始状态 + 迁移函数</li><li>在这个视角下，程序和数学对象已经无限接近了</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f(s) = s&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8019em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></p></li></ul><blockquote><p>人类觉得编程难——人类并不擅长 “数学严格”</p></blockquote><ul><li>我们经常写出 “似是而非” 的代码</li><li>类似于细节有错但可以修正的数学证明<ul><li><code>for (int j = 0; j &lt; n; i++)</code></li><li>(有时候也会疏忽，导致设计全错)</li></ul></li></ul><blockquote><p>为什么会有程序？</p></blockquote><ul><li>是因为我们有无情的执行指令的机器 (计算机)</li><li>只有程序才配得上它</li></ul><blockquote><p>程序天生是 “人类” 的，也是 “反人类” 的</p></blockquote><ul><li>人类的一面：程序连接了人类世界需求<ul><li>程序写的一切都能在现实生活观测到</li><li>我们并不是在实现 “uniform-random” 的 𝑓</li></ul></li><li>反人类的一面：程序会在机器上执行<ul><li>初学者对 “机器严格” 普遍不太适应</li><li>部分原因是对程序的行为没有 100% 的掌控</li><li>使用秘技：debug来观察程序的行为</li></ul></li></ul><h3 id="1-2-当我们谈论数学的时候，我们想谈论什么？">1.2 当我们谈论数学的时候，我们想谈论什么？</h3><blockquote><p>证明程序正确性！</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AlipayAccount</span>:</span><br><span class="line">    b: <span class="built_in">int</span> = <span class="number">0</span>  <span class="comment"># Balance</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">...</span>): ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">...</span>): ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transfer</span>(<span class="params">...</span>): ...</span><br></pre></td></tr></table></figure><blockquote><p>针对这段python代码，我们可以用数学的语言提出程序的规约</p></blockquote><ul><li>例如：任意时刻 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi mathvariant="normal">.</mi><mi>b</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a.b≥0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal">a</span><span class="mord">.</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></li><li>有没有可能真正 “证明” 它呢？<br>任意状态中b都大于0</li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c4-1.2-1.webp" alt="证明方式"></p><h3 id="1-3-程序正确性证明的两种方法">1.3 程序正确性证明的两种方法</h3><blockquote><p>暴力枚举-启发</p></blockquote><ul><li>写一个 driver code，运行所有可能的函数调用序列，proof assistant 帮助我们检查<ul><li>PL/SE 已经研究生成 driver code 几十年了</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>t</mi><mo stretchy="false">(</mo><mi>b</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">assert(b≥0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">sser</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></li></ul></li><li>如果机器和 driver 都没有 bug，程序就是对的</li></ul><blockquote><p>写出证明-启发</p></blockquote><ul><li>我们可以多写<code>assert</code>断言来避免出错</li><li>For all 𝑓 - reachable states, b≥0 holds.</li><li>为 𝑓 写一份数学证明就行了<ul><li>就像你在上数学课时做的习题一样</li></ul></li></ul><p>没错，计算机科学和数学的发展速度可能超过大家的想象——我们有被 “证明正确” 的 编译器、操作系统内核；可以阅读科普文章：</p><p><em>Formal verification doesn’t result in perfect code; it simply narrows the possibility for errors and vulnerabilities to creep in, ” Parno says. “What makes the technique so attractive is that you push the uncertainty or scope of problems down to smaller and smaller windows.</em></p><p><em>同时，proof assistant 也是人工智能时代堪称完美的辅助工具：如果我们要信任 AI 产生的结果，就让它们给出一个 proof assistant 认可的证明吧！</em></p><h2 id="2-为操作系统建模">2 为操作系统建模</h2><h3 id="2-1-操作系统的两个视角">2.1 操作系统的两个视角</h3><blockquote><p>应用视角 (自顶向下)</p></blockquote><ul><li>操作系统 = 对象 + API<ul><li>应用通过 <code>syscall</code> 访问操作系统</li></ul></li></ul><blockquote><p>机器视角 (自底向上)</p></blockquote><ul><li>操作系统 = C 程序<ul><li>运行在计算机硬件上的一个普通程序</li></ul></li></ul><h3 id="2-2-为操作系统建模">2.2 为操作系统建模</h3><blockquote><p>操作系统 = 状态机的管理者（状态机的容器）</p></blockquote><ul><li>当然，它自己也是状态机，有自己的状态</li></ul><blockquote><p>有了一个有趣的想法……</p></blockquote><ul><li>能不能我们自己定义 “状态机”<ul><li>用我们喜欢的语言、喜欢的方式</li><li>不要受限于 C、汇编……</li></ul></li><li>自己模拟状态机的执行<ul><li>形成一个 “玩具操作系统”</li></ul></li></ul><blockquote><p>简化的操作系统模型</p></blockquote><ul><li>用更方便的编程语言描述状态机<ul><li>依然是程序</li><li>依旧是 “数学严格” 的对象</li></ul></li><li>但用更简单的方法实现操作系统<ul><li>管理状态机</li><li>执行系统调用</li></ul></li></ul><h3 id="2-3-表示状态机">2.3 表示状态机</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">StateMachine</span>():</span><br><span class="line">    b = sys_read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        sys_write(<span class="string">&#x27;I got a zero.&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sys_write(<span class="string">&#x27;I got a one.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    sys_spawn(StateMachine)</span><br></pre></td></tr></table></figure><blockquote><p>系统调用</p></blockquote><ul><li>read(): 返回随机的 0 或 1</li><li>write(s): 向 buffer 输出字符串 <code>s</code></li><li>spawn(f): 创建一个可运行的状态机 <code>f</code></li></ul><blockquote><p>操作系统中的对象</p></blockquote><ul><li>状态机 (进程)<ul><li>Python 代码</li><li>初始时，仅有一个状态机 (main)</li><li>允许执行计算或 read, write, spawn 系统调用</li></ul></li><li>一个进程间共享的 buffer (“设备”)</li></ul><blockquote><p>因为 spawn 的存在，操作系统中有多个状态机 (进程)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以拿到一个python模拟的状态机</span></span><br><span class="line">wget -r -np -nH --cut-dirs=2 -R <span class="string">&quot;index.html*&quot;</span> <span class="string">&quot;https://jyywiki.cn/os-demos/introduction/os-model/&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#链接中的proc.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Process</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        sys_write(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    sys_spawn(Process, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    sys_spawn(Process, <span class="string">&#x27;B&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>操作系统会 “雨露均沾” 地运行它们</li><li>但 buffer 是所有状态机共享的<ul><li>于是有了并发……</li><li>操作系统是最早的实用并发程序</li></ul></li></ul><h2 id="3-数学视角的操作系统">3 数学视角的操作系统</h2><blockquote><p>状态</p></blockquote><ul><li>多个 “应用程序” 状态机<ul><li>当然，可以是模型</li></ul></li></ul><blockquote><p>初始状态</p></blockquote><ul><li>仅有一个 “main” 状态机<ul><li>这个状态机处于初始状态</li></ul></li></ul><blockquote><p>迁移</p></blockquote><ul><li>选择一个状态机执行一步<ul><li>就像我们在操作系统模型上看到的那样</li></ul></li></ul><h3 id="3-1-计算机系统中的不确定性">3.1 计算机系统中的不确定性</h3><blockquote><p>ps: 算法定义：一个有穷的指令集，这些指令为解决某一特定任务规定了一个运算序列 （就是一个描述集，就是一个指令集，就是一个序列集）</p></blockquote><blockquote><p>调度：状态机的选择不确定（并发：反人类直觉的一个过程）</p></blockquote><ul><li><code>current = random.choice(self.procs)</code></li><li>操作系统每次可以随机选择一个状态机执行一步</li></ul><blockquote><p>I/O：系统外的输入不确定</p></blockquote><ul><li>read 返回的结果也有两种可能性</li><li><code>t = sys_read()</code> 后，可能 t=0 或 t=1</li></ul><blockquote><p>推论：我们得到了状态图</p></blockquote><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑢</mi><mo>→</mo><mi>𝑣</mi><mo>⇔</mo><mi>𝑢</mi></mrow><annotation encoding="application/x-tex">𝑢→𝑣⇔𝑢</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> 可以通过一步迁移到达 𝑣</li><li>当然，我们只关心<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">s_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>可达的状态</li></ul><blockquote><p>Breadth-first search（广度优先算法）可以构建 “状态图”</p></blockquote><p><img src="https://cdn-img-el3.pages.dev/os/maze.webp" alt="maze.webp"></p><h3 id="3-2-蛮力法-Brute-force">3.2 蛮力法(Brute-force)</h3><blockquote><p>想要证明程序的性质？</p></blockquote><ul><li>只要稍微 “修改” 一下模拟器的实现就行了</li></ul><blockquote><p>构建状态图，检查程序正确性</p></blockquote><ul><li>read()：创建两个状态，分别是 𝑟=0和 𝑟=1</li><li>调度：为每个进程 𝑝 创建一个状态，对应选择 𝑝 执行</li><li>程序正确：不存在从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">s_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>可达的 “坏状态”<ul><li>例如：最终 buffer 中 A 和 B 的数量相同</li><li>“模型检查器”；Turing Award Lecture</li></ul></li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c4-3.2-1.webp" alt="c4-3.2-1.webp"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下面是我们绘制一个 “Hello World” 状态空间的例子。Hello 会调用一个有趣的系统调用 fork，它的行为是复制状态机的当前状态：</span></span><br><span class="line">wget -r -np -nH --cut-dirs=2 -R &quot;index.html*&quot; &quot;https://jyywiki.cn/os-demos/mosaic/mosaic/&quot;</span><br></pre></td></tr></table></figure><p><em>程序就是状态机；状态机可以用程序表示。因此：</em></p><ul><li>我们可以用更 “简单” 的方式 (例如 Python) 描述状态机、建模操作系统上的应用，并且实现操作系统的可执行模型。</li><li>一旦把操作系统、应用程序当做 “数学对象” 处理，那么我们图论、数理逻辑中的工具就能被应用于处理程序——例如，可以用图遍历 “暴力枚举” 的方法证明程序的正确性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-绪论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.应用视角的操作系统</title>
      <link href="/2024/05/25/OS/class2/"/>
      <url>/2024/05/25/OS/class2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-操作系统上的最小应用程序">1. 操作系统上的最小应用程序</h2><h3 id="要想理解-“操作系统”，就要理解什么是-“程序”">要想理解 “操作系统”，就要理解什么是 “程序”</h3><ul><li><strong>一个Hello World示例</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>实际上，这个Hello World并不小</strong></p><ul><li><p>当我们使用objdump工具查看这个Hello World后可以发现：</p><ul><li><code>--verbose</code>可以查看所有编译选项 (真不少)<ul><li>printf 变成了 puts@plt</li></ul></li></ul></li><li><p><code>-Wl,--verbose</code>可以查看所有链接选项 (真不少)</p><ul><li>原来链接了那么多东西</li><li>还解释了 end 符号的由来</li></ul></li><li><p><code>-static</code> 会链接 libc (大量的代码)</p></li></ul></li><li><p><strong>Hello World的最小实现</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line"></span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">  movq $SYS_write, %rax   # write(</span><br><span class="line">  movq $1,         %rdi   #   fd=1,</span><br><span class="line">  movq $st,        %rsi   #   buf=st,</span><br><span class="line">  movq $(ed - st), %rdx   #   count=ed-st</span><br><span class="line">  syscall                 # );</span><br><span class="line"></span><br><span class="line">  movq $SYS_exit,  %rax   # exit(</span><br><span class="line">  movq $1,         %rdi   #   status=1</span><br><span class="line">  syscall                 # );</span><br><span class="line"></span><br><span class="line">st:</span><br><span class="line">  .ascii &quot;\033[01;31mHello, OS World\033[0m\n&quot;</span><br><span class="line">ed:</span><br></pre></td></tr></table></figure><p>下面我们在shell中编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc minimal.S -c &amp;&amp; ld minimal.o</span><br><span class="line">./a.out</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Hello, OS World</span></span><br></pre></td></tr></table></figure><p>这就是一个minimal. S</p><ul><li><strong>什么是程序：</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CPUState</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> regs[<span class="number">32</span>], csrs[CSR_COUNT];</span><br><span class="line">    <span class="type">uint8_t</span> *mem;</span><br><span class="line">    <span class="type">uint32_t</span> mem_offset, mem_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>处理器：无情的、执行指令的状态机</strong><ul><li>从M[PC] 取出一条指令</li><li>执行它</li><li>循环往复</li></ul></li></ul><h3 id="解决程序异常退出">解决程序异常退出</h3><ul><li><p><strong>程序自己是不能 “停下来” 的</strong></p><ul><li>指令集里没有一条关闭计算机的指令，那么操作系统是如何在关闭所有软件后，切断计算机的电源的？</li></ul></li><li><p><strong>只能借助操作系统</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $SYS_exit,  %rax   # exit(</span><br><span class="line">movq $1,         %rdi   #   status=1</span><br><span class="line">syscall                 # );</span><br></pre></td></tr></table></figure><ul><li>把 “系统调用” 的参数放到寄存器中</li><li>执行 syscall，操作系统接管程序<br>操作系统可以任意改变程序状态 (甚至终止程序)</li></ul><h3 id="所有二进制程序-状态机">所有二进制程序 = 状态机</h3><ul><li><strong>状态</strong><ul><li>gdb 内可见的内存和寄存器</li></ul></li><li><strong>初始状态</strong><ul><li>由 ABI 规定 (例如有一个合法的 %rsp)</li></ul></li><li><strong>状态迁移</strong><ul><li>执行一条指令<ul><li>我们花了一整个《计算机系统基础》解释这件事</li><li>gdb 可以单步观察状态机的执行</li></ul></li><li><strong>syscall</strong> 指令: 将状态机 “完全交给” 操作系统</li></ul></li></ul><h2 id="2-操作系统上的应用程序">2. 操作系统上的应用程序</h2><ul><li><p><strong>应用程序和minimal. S 一样，都是状态机</strong></p><ul><li>任何程序 = minimal. S =  状态机<ul><li>总是从被操作系统加载开始<ul><li>通过另一个进程执行 execve 设置为初始状态</li></ul></li><li>经历状态机执行 (计算 + syscalls)<ul><li>进程管理：fork, execve, exit, …</li><li>文件/设备管理：open, close, read, write, …</li><li>存储管理：mmap, brk, …</li></ul></li><li>最终调用 _exit (exit_group) 退出</li></ul></li></ul></li><li><p><strong>可执行文件是操作系统中的对象</strong></p><ul><li>与 minimal 的二进制文件没有本质区别</li><li>我们甚至可以像文本一样直接编辑可执行文件</li></ul></li><li><p><strong>一切应用程序的实现：</strong></p><ul><li>应用程序 = 计算 + 操作系统 API<ul><li>窗口管理器<ul><li>能直接管理屏幕设备 (read/write/mmap)<ul><li>能画一个点，理论上就能画任何东西</li></ul></li><li>能够和其他进程通信 (send, recv)</li></ul></li><li>任务管理器<ul><li>能访问操作系统提供的进程对象 (M1 - pstree)</li></ul></li><li>杀毒软件<ul><li>文件静态扫描 (read)、主动防御 (ptrace)</li></ul></li></ul></li></ul></li><li><p><strong>操作系统的职责：提供令应用程序舒适的抽象 (对象 + API)</strong></p></li></ul><h2 id="3-编译器与编译优化">3. 编译器与编译优化</h2><h3 id="3-1-什么是编译器">3.1 什么是编译器</h3><ul><li>编译器的输入<ul><li>高级语言 ( C ) 代码 = 状态机</li></ul></li><li>编译器的输出<ul><li>汇编代码 (指令序列) = 状态机</li></ul></li><li>编译器 = 状态机之间的翻译器</li></ul><h3 id="3-2-为什么c被称为高级汇编语言">3.2 为什么c被称为高级汇编语言</h3><ul><li>存在 C 代码到指令集的直接对应关系<ul><li>状态机和迁移都可以 “直译”</li><li>于是计算机系统里多了一个抽象层 (“一生二、二生三、三生万物”)</li></ul></li><li>更 “高级” 的语言就很难了<ul><li>C++ virtual void foo();</li><li>Python [1, 2, 3, *rest]</li><li>Javascript await fetch(…)</li></ul></li></ul><p><em>Everything (高级语言代码、机器代码) 都是状态机；而编译器实现了两种状态机之间的翻译。无论何种状态机，在没有操作系统时，它们只能做纯粹的计算，甚至都不能把结果传递到程序之外——而程序与操作系统沟通的唯一桥梁是系统调用 (例如 x86-64 的 syscall 指令)。如此重要的桥梁，操作系统中自然也有工具：strace 可以查看程序运行过程中的系统调用序列。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-绪论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.硬件视角的操作系统</title>
      <link href="/2024/05/25/OS/class3/"/>
      <url>/2024/05/25/OS/class3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-计算机系统的状态机模型">1 计算机系统的状态机模型</h2><h3 id="1-1-一切皆为状态机">1.1 一切皆为状态机</h3><ul><li>C 代码 = 状态机<ul><li>SimpleC &amp; GDB (TUI source)</li></ul></li><li>汇编代码 = 状态机<ul><li>GDB (TUI assembly)</li></ul></li><li>处理器 = 状态机<ul><li>mini-rv32ima; ICS PA</li></ul></li><li>数字电路 = 状态机<ul><li>Logisim</li></ul></li></ul><h3 id="1-2-计算机系统的状态机模型">1.2 计算机系统的状态机模型</h3><ul><li>状态<ul><li>内存、寄存器的数值</li></ul></li><li>初始状态<ul><li>由系统设计者规定 (CPU Reset)</li></ul></li><li>状态迁移<ul><li>从 PC 取指令执行</li></ul></li></ul><p>基本准确；但我们可以做一些补充</p><h4 id="1-2-1-计算机系统：状态">1.2.1 计算机系统：状态</h4><ul><li>寄存器、内存</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CPUState</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> regs[<span class="number">32</span>], csrs[CSR_COUNT];</span><br><span class="line">    <span class="type">uint8_t</span> *mem;</span><br><span class="line">    <span class="type">uint32_t</span> mem_offset, mem_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>还有外部世界的态</li><li>设备上的寄存器 (memory-mapped I/O 可以访问)</li><li>Interrupt/Reset Line</li><li><strong>客观存在，但计算机系统不能直接访问</strong><ul><li>类比：进程只能通过 syscall 访问进程外的信息</li></ul></li></ul><h4 id="1-2-2-计算机系统：初始状态">1.2.2 计算机系统：初始状态</h4><blockquote><p>CPU Reset</p></blockquote><ul><li>Intel 的工程师已经规定好，x86 处理器复位：<ul><li><code>EIP = 0x0000fff0</code></li><li><code>CR0 = 0x60000010</code><ul><li>处理器处于 16-bit 模式</li></ul></li></ul></li><li>RISC-V：百花齐放，百家争鸣<ul><li>初始 PC 无规定；寄存器除了 x0 全部 undefined</li><li>少数 CSR 有规定 (例如 interrupt disabled)<ul><li>设计原则：省电路</li><li>软件能做的，硬件绝对不管</li></ul></li></ul></li></ul><h4 id="1-2-3-计算机系统：状态迁移">1.2.3 计算机系统：状态迁移</h4><p><strong>执行指令</strong></p><ul><li>如果有多个处理器？<ul><li>可以想象成 “每次选一个处理器执行一条指令”</li></ul></li></ul><p><strong>响应中断</strong></p><ul><li>if (intr) goto vec;</li></ul><p><strong>输入输出</strong></p><ul><li>与 “计算机系统外” 交换数据</li><li>类似于程序：不使用 syscall 就等于死循环</li></ul><h2 id="2-固件：接管计算机系统的第一个程序">2 固件：接管计算机系统的第一个程序</h2><h3 id="2-1-计算机系统-状态机">2.1 计算机系统 = 状态机</h3><p><strong>程序员如何控制计算机系统？</strong></p><ul><li>仅有 RESET 状态是不够的</li><li>答案：计算机系统会和 System Programmers 达成约定</li></ul><h3 id="2-2-Firmware">2.2 Firmware</h3><p><strong>“固件”</strong></p><ul><li>厂商 “固定” 在计算机系统里的代码<ul><li>早期：固件是 ROM</li><li>想升级？换芯片！</li></ul></li></ul><p><strong>Firmware 的功能</strong></p><ul><li>运行程序前的计算机系统配置<ul><li>CPU 电压、内存时序、接口开关……</li><li>(这些配置要生效可能需要重启计算机)</li></ul></li><li>不严格地说，<strong>加载操作系统</strong><ul><li>QEMU：可以绕过 Firmware 直接加载操作系统 (RTFM)</li></ul></li></ul><p><em>Firmware：配置计算机系统</em><br><img src="https://cdn-img-el3.pages.dev/os/bios-1.webp" alt="bios-1"></p><p><em>Firmware：加载存储设备上的引导程序</em><br><img src="https://cdn-img-el3.pages.dev/os/bios-2.webp" alt="bios-2"></p><p><strong>Firmware：就是一段代码</strong></p><ul><li>一个小 “操作系统”<ul><li>CPU Reset 后初始化硬件；对接操作系统 Boot Loader</li></ul></li><li>Legacy BIOS (Basic I/O System)<ul><li>IBM PC 所有设备/BIOS 中断是有 specification 的<ul><li>16-bit DOS 时代 BIOS 常驻内存，提供 I/O 等功能</li></ul></li><li>成就了百花齐放的 “兼容机” 时代<ul><li>AMI 和 Phoenix BIOS, 等都活到了今天！</li></ul></li></ul></li><li>UEFI (Unified Extensible Firmware Interface)<ul><li>提供更丰富的支持 (例如设备驱动程序)：指纹锁、山寨网卡上的 PXE 网络启动、USB 蓝牙转接器连接的蓝牙键盘……</li></ul></li></ul><p><em>计算机系统是严格的数学对象：没有魔法；计算机系统的一切行为都是可观测、可理解的。</em></p><ul><li><em>处理器是无情的执行指令的机器。</em></li><li><em>处理器会规定好 Reset 后的行为。</em></li><li><em>Reset 后 Firmware 开始运行，再加载操作系统。</em></li><li><em>厂商逐渐形成了达成共识的 Firmware Specification (IBM PC “兼容机”、UEFI、……)。</em></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-绪论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.操作系统概述</title>
      <link href="/2024/05/24/OS/class1/"/>
      <url>/2024/05/24/OS/class1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>课程来源:b站-绿导师原谅你了<a href="https://space.bilibili.com/202224425/channel/collectiondetail?sid=2237004&amp;spm_id_from=333.788.0.0">“操作系统：设计与实现”(蒋炎岩)</a></p></blockquote><h2 id="1-为什么要学操作系统">1. 为什么要学操作系统</h2><h3 id="1-1-为什么要学xxx">1.1 为什么要学xxx</h3><ul><li>理解这门学科为了解决什么样的问题</li><li>重走一遍前人的发现历程</li><li>最终为了做到应用、创新、革命</li><li>了解到这门学科能做什么，不能做什么，知道这门技术的边界在哪里</li></ul><h2 id="2-什么是操作系统">2. 什么是操作系统</h2><blockquote><p>Operating System: A body of software, in fact, that is responsible for making it easy to run programs (even allowing you to seemingly run many at the same time), allowing programs to share memory, enabling programs to interact with devices, and other fun stuff like that. (OSTEP)</p></blockquote><h3 id="2-1-什么是操作系统">2.1 什么是操作系统</h3><p>简单的说，操作系统就是管理软/硬件资源、为程序提供服务的程序。</p><p><img src="https://cdn-img-el3.pages.dev/os/os-1-1.webp" alt="os-1-1"></p><ul><li>操作系统如何从一开始变成现在这样的？</li><li>三个重要的线索<br>硬件 (计算机)、软件 (程序)、操作系统 (管理硬件和软件的软件)</li></ul><h3 id="2-2前导知识">2.2前导知识</h3><ul><li>高级语言代码 → 指令序列 → 二进制文件 → 处理器执行<ul><li>前导课程目标：能将需求实现；掌握工具使用；阅读汇编指令</li></ul></li></ul><h3 id="3-3-理解操作系统">3.3 理解操作系统</h3><ul><li>操作系统他是在计算机硬件软件发展历史之间出现的一个产物。</li></ul><blockquote><h3 id="1940s">1940s</h3></blockquote><ul><li>在没有操作系统、甚至连编程语言都没有的时候，人们还在画流程图、写机制代码、戳纸袋，这个阶段，能把程序跑起来就很了不起了。</li></ul><blockquote><h3 id="1950s-1960s">1950s-1960s</h3></blockquote><ul><li><p>这个阶段，硬件改进了，逻辑门-存储-I/O 的基本格局没有变。</p><ul><li>晶体管、磁芯内存、丰富的 I/O 设备</li><li>I/O 设备的速度严重低于处理器的速度，中断机制出现 (1953)</li></ul></li><li><p>更复杂的通用的数值计算</p><ul><li>高级语言和 API 诞生 (Fortran, 1957)：一行代码，一张卡片80 行的规范沿用至今</li></ul></li></ul><p><img src="https://cdn-img-el3.pages.dev/os/os-1-2.webp" alt="os-1-2"></p><ul><li><p>Fortran 已经 “足够好用”</p><ul><li>迎来了自然科学、工程机械、军事……对计算机的需求暴涨</li></ul></li><li><p>库函数 + 管理程序排队运行的调度代码</p><ul><li>写程序 (戳纸带)、跑程序都是非常费事的</li><li>计算机非常贵<ul><li>$50,000−$1,000,000</li><li>通常一个学校只有一台</li></ul></li></ul></li><li><p>算力成为服务，操作系统概念形成</p><ul><li>多用户轮流共享计算机，operator 负责操作程序切换</li><li>Operating systems (操作系统/作業系統)<ul><li>(今天算力又成为服务了-<em>人工智能</em>)</li></ul></li></ul></li><li><p>CTSS (Compatible Time-Sharing System)</p></li></ul><blockquote><h3 id="1960s-1970s">1960s-1970s</h3></blockquote><ul><li><p>集成电路、总线出现</p></li><li><p>更多的高级语言和编译器出现</p></li><li><p>个人电脑登上历史舞台</p></li><li><p>能载入多个程序到内存且调度它们的管理程序</p><ul><li>为防止程序之间形成干扰，操作系统自然地将共享资源 (如设备) 以 API 形式管理起来<ul><li>有了进程 (process) 的概念</li><li>进程在执行 I/O 时，可以将 CPU 让给另一个进程<ul><li>在多个地址空间隔离的程序之间切换</li><li>虚拟存储使一个程序出 bug 不会 crash 整个系统</li></ul></li></ul></li></ul></li><li><p>操作系统中自然地增加进程管理 API</p></li></ul><blockquote><h3 id="1970s">1970s+</h3></blockquote><ul><li>分时系统走向成熟，UNIX 诞生并走向完善，奠定了现代操作系统的形态</li></ul><h2 id="3-如何学操作系统">3. 如何学操作系统</h2><blockquote><p><strong>试着去成为一个有 CS 梦想的人</strong></p></blockquote><p>是一个合格的操作系统用户</p><ul><li>会 STFW/RTFM/ATFAI 自己动手解决问题，进而，不怕使用任何命令行工具vim, tmux, grep, gcc, binutils, …</li><li>不怕 (或者爱上) 写代码<ul><li>能管理一定规模 (数千行) 的代码</li><li>在出 bug 时默念 “机器永远是对的、我肯定能调出来的”<ul><li>然后开始用正确的工具/方法调试</li></ul></li></ul></li></ul><p><em>操作系统是软件和硬件之间的桥梁；因此我们 “找到” 一些合适的软件、一些相对简单的硬件，理解操作系统就会变得容易。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-绪论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2024/05/23/2024-5/2024-5-23/"/>
      <url>/2024/05/23/2024-5/2024-5-23/</url>
      
        <content type="html"><![CDATA[<blockquote><h2 id="测试">测试</h2></blockquote><p>​这篇测试文章将会是我的第一篇文章，立下flag，今后我将会记录我的一些：</p><ul><li>学习笔记</li><li>遇到并解决的问题</li><li>随笔</li></ul>]]></content>
      
      
      <categories>
          
          <category> 第一篇文档分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第一篇文档标签 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
