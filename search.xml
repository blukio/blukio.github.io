<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>js前世今生</title>
      <link href="/2024/06/11/JavaScript-ninja/1_/"/>
      <url>/2024/06/11/JavaScript-ninja/1_/</url>
      
        <content type="html"><![CDATA[<h2 id="1-js前世今生">1 js前世今生</h2><h3 id="1-1-js">1.1 js</h3><blockquote><p>1990年，世界上第一个网页诞生</p></blockquote><p>第一位蒂姆·伯纳斯-李，他是一名计算机科学家，他在1990年发明了万维网，并且没有申请专利。他希望所有人在互联网上分享知识。</p><ul><li><p>需要解决的问题一：语言</p><ul><li>设计一个超文本的实现，html<ul><li>a标签，超链接，锚点ahchor</li></ul></li></ul></li><li><p>需要解决的问题二：数据接受和传输</p><ul><li>基于TCP/IP协议发明了http协议</li></ul></li><li><p>需要解决的问题三：可以渲染html的引擎</p><ul><li>浏览器(终端内的www)</li></ul></li></ul><blockquote><p>1993年，页面不只是文字，还有图片</p></blockquote><p>马克安德森和另一位NCSA的朋友一起研发了mosiac浏览器，可以渲染图片。</p><blockquote><p>1994年以后，安德森和吉姆克拉克从NCSA离开了，成立了NetScap网景公司</p></blockquote><p>在MOSIAC浏览器的基础上，开发了netscap naviagtor浏览器，可以渲染图片和文字。</p><blockquote><p>1995年，liveScript诞生</p></blockquote><p>Brendan Eich开发这种网页脚本语言，可以嵌入网页中。<br>同年12月，网景公司与Sun公司达成协议，命名这种语言叫做javascrpt。</p><blockquote><p>1996年，微软加入浏览器市场</p></blockquote><p>3月，Navigato浏览器正式内置了javascript语言。</p><p>Netscape 公司很快发现，Navigator浏览器需要一种可以嵌入网页的脚本语言，用来控制浏览器行为。当时，网速很慢而且上网费很贵，有些操作不宜在服务器端完成。比如，如果用户忘记填写“用户名”，就点了“发送”按钮，到服务器再发现这一点就有点太晚了，最好能在用户发出数据之前，就告诉用户“请填写用户名”。这就需要在网页中嵌入小程序，让浏览器检查每一栏是否都填写了。</p><p>8月，微软收购了spy glass公司，开发了jscript语言。</p><p>11月，网景公司将javascrpt语言提交给ECMA，希望javascrpt成为国际标准，抵抗微软。</p><p><em>此时并没有单独的脚本解析引擎。而是在原有的渲染引擎中加了点代码去解析脚本</em></p><blockquote><p>2001年，windowsxp携手ie6登场</p></blockquote><p>此时，js引擎被抽离出来(为了让浏览器更强，看图片，玩游戏…)。</p><blockquote><p>2003年</p></blockquote><p>网景公司的Navigator被windowsxp的ie6战胜，退出了历史舞台，但是网景公司开源了Navigator内核。从此Navigator被交给了firefox，火狐在此基础上开发了Gecko引擎。</p><blockquote><p>2008年</p></blockquote><p>谷歌浏览器横空出世，跟safari共同研制了webkit内核，基于webkit内核开发了blink内核。</p><p>谷歌浏览器之所以最快，因为它研制了v8引擎作为js引擎，它具有如下特点：</p><ul><li>直接把代码转为机器码，跳过字节码</li><li>可以独立于浏览器运行的nodjs</li></ul><p>从此，前端语言变成了关键的脚本语言，前端工程师的变得稀缺，甲骨文公司收购了sun公司，js版权归甲骨文公司所有。</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. 真实世界的并发编程</title>
      <link href="/2024/06/11/OS/class11/"/>
      <url>/2024/06/11/OS/class11/</url>
      
        <content type="html"><![CDATA[<h2 id="1-我们身边的并发编程">1 我们身边的并发编程</h2><h3 id="1-1-互联网的开始：Web1-0">1.1 互联网的开始：Web1.0</h3><blockquote><p>从 PC 时代到互联网时代 (1990s)</p></blockquote><ul><li>Amazon (1994), Yahoo (1994), eBay (1995), Google (1998)</li><li>HTTP (对，没有 HTTPS), HTML，但没有 CSS<ul><li>中国互联网初代 “三巨头”：新浪、搜狐、网易诞生</li><li><code>&lt;font&gt;</code>, <code>&lt;table&gt;</code>, vbscript 和切图工程师一统天下</li></ul></li></ul><h3 id="1-2-Web2-0">1.2 Web2.0</h3><blockquote><p>Asynchronous JavaScript and XML (Ajax; ~1999)</p></blockquote><ul><li>允许网页实现 “后台刷新”<ul><li>悄悄请求后端，然后更新 DOMTree</li><li>“应用” 可以做的，网页也都可以做了！</li></ul></li><li>(你没看错，竟然不是 JSON)<ul><li>原因：后端 (Java) 应用广泛使用 XML</li></ul></li></ul><blockquote><p>jQuery $ (2006)</p></blockquote><ul><li>允许 Javascript 代码优雅地修改 DOMTree</li><li><code>$('h3').replaceWith('XXX');</code></li></ul><p><strong>从此，做“任何事”都只要浏览器就行</strong></p><blockquote><p>甚至诞生了 ChromeOS</p></blockquote><ul><li>HTML + CSS 构建应用的方便程度超过传统 GUI 编程</li><li>GTK, Qt, MFC 谁用谁知道</li></ul><h3 id="Web2-0时代的并发编程">Web2.0时代的并发编程</h3><blockquote><p>Challenges</p></blockquote><ul><li>线程 (在 1990s) 开销很大</li><li>线程同步很难写对</li></ul><blockquote><p>Solution: Event-based concurrency (动态计算图)</p></blockquote><ul><li>允许随时创建计算节点<ul><li>例如网络请求、定时器</li></ul></li><li>禁止计算节点并行<ul><li>网络访问占大部分时间；浏览器内计算只是小部分</li></ul></li><li>以事件为单位调度<ul><li>事件可以在浏览器里看到！</li></ul></li></ul><blockquote><p>“Callback hell (回调地狱)”</p></blockquote><ul><li>2024 年，教务系统里还能看到明文</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/api/user&#x27;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">user</span>) &#123;</span><br><span class="line">        $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">            <span class="attr">url</span>: <span class="string">`/api/user/<span class="subst">$&#123;user.id&#125;</span>/friends`</span>,</span><br><span class="line">            <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">friends</span>) &#123;</span><br><span class="line">                $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">                    <span class="attr">url</span>: <span class="string">`/api/friend/<span class="subst">$&#123;friends[<span class="number">0</span>].id&#125;</span>`</span>,</span><br><span class="line">                    ...</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">error</span>: <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>ECMAScript 2015 (ES6)</p></blockquote><ul><li>一统第三方库 “军阀混战” 的局面</li><li>开源生态开始起飞</li></ul><blockquote><p>现代前端的代表作品</p></blockquote><ul><li>Angular, React, Vue</li><li>Express.js, Next.js</li><li>Bootstrap, Tailwindcss</li><li>Electron (vscode)<ul><li>2016 年，还用先烈 Github Atom 做过实验</li></ul></li></ul><blockquote><p>Promise: 描述动态计算图</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">`/api/localhost/?action=demo&amp;path=<span class="subst">$&#123;path&#125;</span>`</span>)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">fetchedData</span> =&gt;</span> <span class="title function_">setData</span>(fetchedData))</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">    <span class="title function_">fetch</span>(...).<span class="title function_">then</span>(...),</span><br><span class="line">    <span class="title function_">fetch</span>(...).<span class="title function_">then</span>(...),</span><br><span class="line">    <span class="title function_">fetch</span>(...).<span class="title function_">then</span>(...),</span><br><span class="line">]).<span class="title function_">then</span>(</span><br><span class="line">    <span class="comment">// succeeded</span></span><br><span class="line">).<span class="title function_">catch</span>(</span><br><span class="line">    <span class="comment">// error handling (catches exceptions in the fetch)</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="1-3-历史车轮碾过">1.3 历史车轮碾过</h3><blockquote><p>PC → Web → Web 2.0 (UGC) → AI (AGI)</p></blockquote><ul><li>“框架” 是驱动技术发展的原动力</li><li>我们需要好的抽象来表达人类世界中的需求<ul><li>简单可靠，聚集大量行业开发者</li><li>灵活通用，构造各种应用程序</li></ul></li></ul><blockquote><p>单机 → 互联网 → 移动计算 → ???</p></blockquote><ul><li>机遇和不确定</li><li>风险和回报</li></ul><h2 id="2-高性能计算中的并发编程">2 高性能计算中的并发编程</h2><h3 id="2-1-CRAY-1-超级计算机">2.1 CRAY-1 超级计算机</h3><blockquote><p>“<a href="https://dl.acm.org/doi/10.1145/359327.359336">The world’s most expensive love-seat</a>” (1976)</p></blockquote><ul><li>138 MFLOPS @ 115kW (Apple M3: 4.1 TFLOPS @ 20W)</li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c11-2.1-1.webp" alt="c11-2.1-1.webp"></p><h3 id="2-2-高性能计算">2.2 高性能计算</h3><blockquote><p>“A technology that harnesses the power of supercomputers or computer clusters to solve complex problems requiring massive computation.” (IBM)<br>源自数值密集型科学计算任务</p></blockquote><ul><li>物理系统模拟<ul><li>天气预报、航天、制造、能源、制药、……</li><li>大到宇宙小到量子，有模型就能模拟</li></ul></li><li>矿厂</li><li>AI: 新时代的高性能计算 (之后专门讲解)</li><li><a href="http://www.hpc100.cn/top100/22/">HPC-China 100</a></li></ul><blockquote><p>物理世界具有 “空间局部性”</p></blockquote><ul><li>“模拟物理世界” 的系统具有 embarrassingly parallel 的特性</li></ul><h3 id="2-3-高性能计算中的并行编程">2.3 高性能计算中的并行编程</h3><blockquote><p>通常计算图容易静态切分 (机器-线程两级任务分解)</p></blockquote><ul><li>生产者-消费者解决一切<ul><li>MPI - “message passing libraries”, OpenMP - “multi-platform shared-memory parallel programming (C/C++ and Fortran)”</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(128)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Challenges</p></blockquote><ul><li>网络通信、功耗管理、稳定性和容错、软件和工具链</li></ul><h2 id="3-数据中心中的并发编程">3 数据中心中的并发编程</h2><h3 id="3-1数据中心程序：特点">3.1数据中心程序：特点</h3><blockquote><p>“A network of computing and storage resources that enable the delivery of shared applications and data.” (CISCO)</p></blockquote><blockquote><p>以海量分布式数据 (存储) 为中心</p></blockquote><ul><li>实时的 “小数据处理”<ul><li>内容分发、用户认证、视频直播、弹幕……</li></ul></li><li>离线的 “大数据处理”<ul><li>内容索引、数据挖掘……</li></ul></li></ul><blockquote><p>我们的生活离不开数据中心应用</p></blockquote><ul><li>AI、搜索、社交、支付、游戏……</li></ul><h3 id="3-2-数据中心里的并发编程">3.2 数据中心里的并发编程</h3><blockquote><p>Challenge: 高可靠、低延迟的多副本分布式存储和计算</p></blockquote><ul><li>数据保持一致 (Consistency)、服务时刻可用 (Availability)、容忍机器离线 (Partition tolerance) 不可兼得</li></ul><blockquote><p>高吞吐 (QPS) &amp; 低延迟的事件处理</p></blockquote><ul><li>处理事件可能需要读写持久存储或请求网络上的服务<ul><li>延迟不确定</li></ul></li><li>线程维护和上下文切换都会带来开销</li></ul><blockquote><p>假设有数千/数万个请求同时到达服务器……</p></blockquote><ul><li>“Denial of Service, DoS”<ul><li>全国的小爱音箱在小米汽车发布会上同步瘫痪</li></ul></li></ul><h3 id="3-3-协程：操作系统-“不感知”-的上下文切换">3.3 协程：操作系统 “不感知” 的上下文切换</h3><blockquote><p>和线程概念相同 (独立堆栈、共享内存)</p></blockquote><ul><li>但 “一直执行”，直到 yield() 主动放弃处理器<ul><li>yield() 是函数调用<ul><li>只需保存/恢复 non-volatile 的寄存器</li><li>(线程切换需要保存/恢复全部寄存器)</li></ul></li></ul></li><li>但 sleep (I/O) 时，所有协程都 “卡住了”</li><li>失去了并行</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只可能是 1122 或 2211</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">T1</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>); <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>); <span class="built_in">yield</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">T2</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;2&quot;</span>); <span class="built_in">printf</span>(<span class="string">&quot;2&quot;</span>); <span class="built_in">yield</span>(); &#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-Go-和-Goroutine">3.4 Go 和 Goroutine</h3><blockquote><p>小孩子才做选择，多处理器并行和轻量级并发我全都要！</p></blockquote><ul><li>Goroutine: 概念上是线程，实现是线程和协程的混合体</li></ul><blockquote><p>Goroutine 实现</p></blockquote><ul><li>每个 CPU 上有一个 Go Worker，运行协程</li><li>协程执行 blocking API (sleep, read)<ul><li>偷偷调用 non-blocking 的版本</li><li>成功 → 立即继续执行</li><li>失败 → 立即 yield 到另一个需要 CPU 的 goroutine<ul><li>太巧妙了！完全不浪费！</li></ul></li></ul></li></ul><h3 id="3-5-Go-语言中的同步与通信">3.5 Go 语言中的同步与通信</h3><blockquote><p>Do not communicate by sharing memory; instead, share memory by communicating. ——Effective Go</p></blockquote><blockquote><p>共享内存 = 万恶之源</p></blockquote><ul><li>信号量/条件变量：实现了同步，但没有实现 “通信”<ul><li>数据传递完全靠手工 (没上锁就错了)</li></ul></li></ul><blockquote><p>但 UNIX 时代就有一个实现并行的机制了</p></blockquote><ul><li><code>cat *.txt | wc -l</code><ul><li>管道是一个天然的生产者/消费者！</li><li>为什么不用 “管道” 实现协程/线程间的同步 + 通信呢？<ul><li>Channels in Go</li></ul></li></ul></li></ul><blockquote><p>“Leader/follower” 架构</p></blockquote><ul><li>有一个集中的 “总控” 负责调度</li><li>在可靠的消息机制上实现任务分派<ul><li>Leader 串行处理所有请求</li><li>例子：哲学家吃饭时，由服务员掌管叉子</li></ul></li></ul><blockquote><p>你可能会觉得，管叉子的人是性能瓶颈？</p></blockquote><ul><li>一大桌人吃饭，每个人都叫服务员的感觉</li><li>Premature optimization is the root of all evil (D. E. Knuth)</li></ul><blockquote><p>抛开 workload 谈优化就是耍流氓</p></blockquote><ul><li>吃饭的时间通常远远大于请求服务员的时间</li><li>如果一个 manager 搞不定，可以分多个 (fast/slow path)<ul><li>The Google File System (SOSP’03) 开启大数据时代</li></ul></li></ul><h2 id="4-人工智能时代的并发编程">4 人工智能时代的并发编程</h2><h3 id="4-1-大语言模型背后的计算">4.1 大语言模型背后的计算</h3><blockquote><p>“Attention Is All You Need”</p></blockquote><ul><li>“Transformers”:类似人处理问题的思维方式(注意力机制)。</li></ul><h3 id="4-2-机器学习系统中的并发编程">4.2 机器学习系统中的并发编程</h3><blockquote><p>Challenge: 既计算密集，又数据密集</p></blockquote><ul><li>推理<ul><li>GPT-3: 175B 参数 (~300GB VRAM, FP-16)<ul><li>GPT-3 single training run cost: ~$5,000,000</li></ul></li><li>LLaMA2: 70B 参数 (~65GB VRAM, FP-16)<ul><li>美国人断供芯片 = 三体人行为</li></ul></li></ul></li><li>训练<ul><li>320TB 语料</li><li>相比图片和视频，还是小弟弟<br><strong>解决：所有能想到的技术，全部都用上了！</strong></li></ul></li></ul><p><em>对并发编程的争议一直存在，例如 “Threads cannot be implemented as a library”。实际上，我们在很多应用领域看到了 “领域特定” 的解决方案：Web 中的异步编程、高性能计算中的 MPI 和 OpenMI、数据中心中的 goroutines、人工智能时代的 CUDA。更有趣的是，我们可以看到：改变世界的技术，往往只是一个小小的奇思妙想, 最终坚持到底得到的——它们很难被 “规划” 出来，而是需要一些 “背道而驰” 的人坚持到底。在当今的社会环境下，我们最缺少的是有能力背道而驰的人——有了下一代人的进步，才会有包容他们的土壤。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10. 并发控制：同步 (2)</title>
      <link href="/2024/06/06/OS/class10/"/>
      <url>/2024/06/06/OS/class10/</url>
      
        <content type="html"><![CDATA[<h2 id="1-信号量">1 信号量</h2><h3 id="1-1-用互斥锁实现同步">1.1 用互斥锁实现同步</h3><blockquote><p>一个奇妙的想法</p></blockquote><ul><li>创建锁时，立即 “获得” 它 (总是成功)</li><li>其他人想要获得时就会等待<ul><li>此时 release 就实现了同步</li></ul></li><li>一个线程上锁，在另一个线程解锁</li></ul><blockquote><p>让我们来试一试吧 (demo)</p></blockquote><ul><li>先把厕所门都锁上</li><li>线程到达以后等待</li><li>管理员把所有门都打开</li></ul><blockquote><p>Acquire-Release 实现计算图</p></blockquote><ul><li>为每一条边 𝑒=(𝑢, 𝑣) 分配一个互斥锁</li><li>初始时，全部处于锁定状态</li><li>对于一个节点，它需要获得所有入边的锁才能继续</li><li>可以直接计算的节点立即开始计算</li><li>计算完成后，释放所有出边对应的锁</li></ul><blockquote><p>挺好用 (demo)</p></blockquote><ul><li>甚至比条件变量还好用！</li></ul><h3 id="1-2-本质：Release-as-Synchronization">1.2 本质：Release as Synchronization</h3><blockquote><p>Release-Acquire 实现了 happens-before</p></blockquote><ul><li>Acquire = 等待 token</li><li>Release = 发出 token</li></ul><blockquote><p>Token 可以理解为现实生活中的“资源”</p></blockquote><ul><li>停车场：停车位</li><li>游泳馆：获得手环 (token) 的人可以进入更衣室<ul><li>mutex 实现 token 似乎有什么问题？<br>缺点：token=1</li></ul></li></ul><h3 id="1-3-信号量">1.3 信号量</h3><blockquote><p>如果我是游泳馆的老板……</p></blockquote><ul><li>一个能 “计数” 的 mutex: 发 𝑛 个手环！<ul><li>手环 = synchronization token</li></ul></li><li>mutex 是 𝑛=1 的特殊情况</li></ul><blockquote><p>Acquire</p></blockquote><ul><li>获得手环的同学进入游泳池 (手环不够，等待)</li></ul><blockquote><p>Release</p></blockquote><ul><li>归还一个手环 (一个等待的同学就能得到手环了)</li></ul><h3 id="1-4-把任何东西理解为Token">1.4 把任何东西理解为Token</h3><blockquote><p>停车场有 𝑛 个车位</p></blockquote><ul><li>Acquire: 在有车位时进入停车场</li><li>Release: 出停车场；车位 + 1</li></ul><blockquote><p>袋子里有 𝑛 个球</p></blockquote><ul><li>Acquire: 从袋子里取一个球<ul><li>如果没有球，需要等待</li></ul></li><li>Release: 向袋子里放一个球<ul><li>如果有人在等待，直接把球交给他</li></ul></li></ul><blockquote><p>注意我们可以有多个口袋！</p></blockquote><h3 id="1-5-API">1.5 API</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="type">sem_t</span> *sem)</span> &#123;</span><br><span class="line">    <span class="comment">// P - prolaag</span></span><br><span class="line">    <span class="comment">//     try + decrease/down/wait/acquire</span></span><br><span class="line">    atomic &#123;</span><br><span class="line">        wait_until(sem-&gt;count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sem-&gt;count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="type">sem_t</span> *sem)</span> &#123;</span><br><span class="line">    <span class="comment">// V - verhoog</span></span><br><span class="line">    <span class="comment">//     increase/up/post/signal/release</span></span><br><span class="line">    atomic &#123;</span><br><span class="line">        sem-&gt;count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-使用信号量实现同步">2 使用信号量实现同步</h2><blockquote><ol><li>实现一次临时的 happens-before: 𝐴→𝐵</li></ol></blockquote><ul><li>𝐴→𝑉(𝑠)→𝑃(𝑠)→𝐵这就是刚才的 “互斥锁实现同步”</li></ul><blockquote><ol start="2"><li>管理计数型资源</li></ol></blockquote><ul><li>游泳池里的人不能超过 𝑛 个</li><li>停车场里的车不能超过 𝑛 个</li><li>但可以有多个 “停车场”、“游泳池”</li><li>我们也可以创造出车位</li></ul><h3 id="2-1-线程join">2.1 线程join()</h3><blockquote><ol><li>形成 happens-before</li></ol></blockquote><ul><li>worker: $ V(done_t) $</li><li>main: $ P(done_1 )→P(done_2​)…→P(done_T) $描述了一个 “计算图”</li></ul><blockquote><ol start="2"><li>使用计数型资源</li></ol></blockquote><ul><li>worker: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>d</mi><mi>o</mi><mi>n</mi><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(done)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span></li><li>main: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>d</mi><mi>o</mi><mi>n</mi><mi>e</mi><mo stretchy="false">)</mo><mo>×</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">P(done)×T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></li></ul><h3 id="2-2-实现生产者-消费者">2.2 实现生产者-消费者</h3><blockquote><p>信号量设计思路</p></blockquote><ul><li>考虑 “球”/“手环” (每一单位的 “资源”) 是什么</li><li>生产者/消费者 = 把球从一个袋子里放到另一个袋子里</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">produce</span><span class="params">()</span> &#123;</span><br><span class="line">    P(&amp;empty);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">    V(&amp;fill);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consume</span><span class="params">()</span> &#123;</span><br><span class="line">    P(&amp;fill);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    V(&amp;empty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-信号量、条件变量与同步">3 信号量、条件变量与同步</h2><h3 id="3-1-信号量-v-s-条件变量">3.1 信号量 v.s. 条件变量</h3><blockquote><p>信号量</p></blockquote><ul><li>互斥锁的自然推广</li><li>干净、优雅：没有条件变量的 “自旋”</li></ul><blockquote><p>条件变量</p></blockquote><ul><li>万能：适用于任何同步条件</li><li>不太好用：代码总感觉不太干净</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">synchronized (obj) &#123;  <span class="comment">// reads better in Java</span></span><br><span class="line">    <span class="keyword">while</span> (!cond) &#123;</span><br><span class="line">        obj.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>哲学家吃饭问题 (E. W. Dijkstra, 1960)</p></blockquote><ul><li>哲学家 (线程) 有时思考，有时吃饭</li><li>吃饭需要同时得到左手和右手的叉子</li></ul><blockquote><p>条件变量</p></blockquote><ul><li>同步条件：<code>avail[lhs] &amp;&amp; avail[rhs]</code></li></ul><blockquote><p>信号量</p></blockquote><ul><li><code>P(&amp;sem[lhs]) &amp;&amp; P(&amp;sem[rhs])</code></li><li>看起来没什么问题？<ul><li>当互斥锁用就行了</li></ul></li></ul><blockquote><p>如果 5 个哲学家同时举起左手的叉子……</p></blockquote><ul><li>我们需要禁止这件事发生</li></ul><blockquote><p>Workaround 1: 从桌子上赶走一个人</p></blockquote><ul><li>直观理解：大家先从桌上退出<ul><li>袋子里有 4 张卡</li><li>拿到卡的可以上桌吃饭 (拿叉子)</li><li>吃完以后把卡归还到袋子</li></ul></li></ul><blockquote><p>Workaround 2: Lock Ordering</p></blockquote><ul><li>给叉子编号，总是先拿编号小的</li></ul><h3 id="3-2-用条件变量实现信号量">3.2 用条件变量实现信号量</h3><blockquote><p>P 操作的同步条件</p></blockquote><ul><li><code>sem-&gt;count &gt; 0</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="type">sem_t</span> *sem)</span> &#123;</span><br><span class="line">    hold(&amp;sem-&gt;mutex) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!COND)</span><br><span class="line">            cond_wait(&amp;sem-&gt;cv, &amp;sem-&gt;mutex);</span><br><span class="line">        sem-&gt;count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="type">sem_t</span> *sem)</span> &#123;</span><br><span class="line">    hold(&amp;sem-&gt;mutex) &#123;</span><br><span class="line">        sem-&gt;count++;</span><br><span class="line">        cond_broadcast(&amp;sem-&gt;cv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-用信号量实现条件变量">3.3 用信号量实现条件变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(<span class="keyword">struct</span> condvar *cv, <span class="type">mutex_t</span> *mutex)</span> &#123;</span><br><span class="line">    mutex_lock(&amp;cv-&gt;lock);</span><br><span class="line">    cv-&gt;nwait++;</span><br><span class="line">    mutex_unlock(&amp;cv-&gt;lock);</span><br><span class="line"></span><br><span class="line">    mutex_unlock(mutex);</span><br><span class="line">    P(&amp;cv-&gt;sleep);</span><br><span class="line"></span><br><span class="line">    mutex_lock(mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">broadcast</span><span class="params">(<span class="keyword">struct</span> condvar *cv)</span> &#123;</span><br><span class="line">    mutex_lock(&amp;cv-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cv-&gt;nwait; i++) &#123;</span><br><span class="line">        V(&amp;cv-&gt;sleep);</span><br><span class="line">    &#125;</span><br><span class="line">    cv-&gt;nwait = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;cv-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-实现困难的本质原因">3.4 实现困难的本质原因</h3><blockquote><p>先释放锁，再执行 P</p></blockquote><ul><li>释放锁的一瞬间可能与 broadcast 并发</li></ul><blockquote><p>先执行 P，再释放锁</p></blockquote><ul><li><code>P(&amp;cv-&gt;sleep)</code> 会 “永久睡眠”</li></ul><blockquote><p>那怎么办</p></blockquote><ul><li>release-wait 必须实现成 “原子操作”</li><li>信号量：在合适的时候好用；但不总是好用</li></ul><p><em>信号量可以看做是互斥锁的一个 “推广”，可以理解成游泳馆的手环、袋子里的球，通过计数的方式实现同步——在符合这个抽象时，使用信号量能够带来优雅的代码。但信号量不是万能的——理解线程同步的条件才是真正至关重要的。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9. 并发控制：同步 (1)</title>
      <link href="/2024/06/05/OS/class9/"/>
      <url>/2024/06/05/OS/class9/</url>
      
        <content type="html"><![CDATA[<h2 id="1-线程同步">1. 线程同步</h2><blockquote><p>Synchronization</p></blockquote><ul><li>控制并发，使得 “两个或两个以上随时间变化的量在变化过程中保持一定的相对关系”</li><li>有点抽象，让我们来看例子</li></ul><blockquote><p>理解并发的方法</p></blockquote><ul><li>线程 = 我们自己</li><li>共享内存 = 物理空间</li></ul><h3 id="1-1-现实世界中的同步">1.1 现实世界中的同步</h3><blockquote><p>演奏音乐中的同步</p></blockquote><ul><li>每个乐手都是一个 “线程”</li><li>节拍 𝑖 到达 → 演奏 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝑛</mi><mi>𝑖</mi></msub></mrow><annotation encoding="application/x-tex">𝑛_𝑖</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>​</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">T_player</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!end) &#123;</span><br><span class="line">        wait_next_beat();</span><br><span class="line">        play_next_note();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在某个瞬间达到 “互相已知” 的状态</p></blockquote><ul><li>NPY: 等我洗个头就出门</li><li>NPY: 等我打完这局游戏就来</li><li>舍友：等我修好这个 bug 就吃饭</li><li>导师：等我出差回来就讨论这个课题</li><li>join(): 等所有线程结束就继续</li></ul><blockquote><p>“先到先等”，在条件达成的瞬间再次恢复并行</p></blockquote><ul><li>同时开始出去玩/吃饭/讨论</li></ul><h3 id="1-2-状态机视角">1.2 状态机视角</h3><blockquote><p>系统到达某个 “同步” (互相已知) 的状态</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">T_player</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!end) &#123;</span><br><span class="line">        wait_next_beat();</span><br><span class="line">        play_next_note();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">T_conductor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!end) &#123;</span><br><span class="line">        wait_next_beat();</span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>release() 之后，player 都会演奏下一拍</li></ul><blockquote><p>自旋等待同步条件达成</p></blockquote><ul><li>线程有先后，先来先等待</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait_next_beat</span><span class="params">()</span> &#123;</span><br><span class="line">retry:</span><br><span class="line">    <span class="keyword">if</span> (!next_beat_has_come) &#123;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-生产者-消费者问题与条件变量">2. 生产者-消费者问题与条件变量</h2><ul><li>99% 的实际并发问题都可以用生产者-消费者解决</li></ul><blockquote><p>Producer 和 Consumer 共享一个缓冲区</p></blockquote><ul><li>Producer (生产数据)：如果缓冲区有空位，放入；否则等待</li><li>Consumer (消费数据)：如果缓冲区有数据，取走；否则等待</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">produce</span><span class="params">(Object obj)</span>; </span><br><span class="line">Object <span class="title function_">consume</span><span class="params">()</span>; </span><br></pre></td></tr></table></figure><h3 id="2-1-生产者-消费者问题的简化">2.1 生产者-消费者问题的简化</h3><blockquote><p>缓冲区太麻烦，我们有一个简化版问题</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">produce</span><span class="params">()</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">consume</span><span class="params">()</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>); &#125;</span><br></pre></td></tr></table></figure><ul><li>生产 = 打印左括号 (push into buffer)</li><li>消费 = 打印右括号 (pop from buffer)</li><li>在 printf 前后增加代码，使得打印的括号序列满足<ul><li>一定是某个合法括号序列的前缀</li><li>括号嵌套的深度不超过 𝑛<ul><li>𝑛 = 3, <code>((())())(((</code> 合法</li><li>𝑛 = 3, <code>(((())))</code>, <code>(()))</code> 不合法</li></ul></li></ul></li></ul><h3 id="2-2-同步：先来先等待">2.2 同步：先来先等待</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">produce</span><span class="params">()</span> &#123;</span><br><span class="line">    wait_until(括号深度 &lt; n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consume</span><span class="params">()</span> &#123;</span><br><span class="line">    wait_until(括号深度 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们发明了条件变量！</p></blockquote><ul><li>把条件用一个变量来替代</li><li>条件不满足时等待，条件满足时唤醒</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(&amp;lk);</span><br><span class="line"><span class="keyword">if</span> (!condition) &#123;</span><br><span class="line">    cond_wait(&amp;cv, &amp;lk);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Wait for someone for wake-up.</span></span><br><span class="line">assert(condition);</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;lk);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cond_signal(&amp;cv);  <span class="comment">// Wake up a (random) thread</span></span><br><span class="line">cond_broadcast(&amp;cv);  <span class="comment">// Wake up all threads</span></span><br></pre></td></tr></table></figure><blockquote><p>条件变量的正确打开方式</p></blockquote><ul><li>使用 while 循环和 broadcast<ul><li>总是在唤醒后再次检查同步条件</li><li>总是唤醒所有潜在可能被唤醒的人</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(&amp;mutex);</span><br><span class="line"><span class="keyword">while</span> (!COND) &#123;</span><br><span class="line">  wait(&amp;cv, &amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">assert(cond);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure><h2 id="3-同步机制的应用">3. 同步机制的应用</h2><h3 id="3-1-实现任意计算图">3.1 实现任意计算图</h3><blockquote><p>计算任务构成有向无环图</p></blockquote><ul><li>(𝑢, 𝑣)∈𝐸表示 𝑣 要用到前 𝑢 的值</li><li>只要调度器 (生产者) 分配任务效率够高，算法就能并行</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">T_worker</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        consume().run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">T_scheduler</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!jobs.empty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j : jobs.find_ready()) &#123;</span><br><span class="line">            produce(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为每个节点设置一个条件变量</p></blockquote><ul><li>𝑣 能执行的同步条件：𝑢 → 𝑣 都已完成</li><li>𝑢 完成后，signal 每个 𝑢 →<br>𝑣</li></ul><p>例子</p><p><img src="https://cdn-img-el3.pages.dev/os/c9-3.1-1.webp" alt="c9-3.1-1.webp"></p><h3 id="3-2-条件变量">3.2 条件变量</h3><blockquote><p>有三种线程</p></blockquote><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">T_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 若干: 死循环打印 <code>&lt;</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">T_b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 若干: 死循环打印 <code>&gt;</code></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">T_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 若干: 死循环打印 <code>_</code></li></ul><blockquote><p>任务：</p></blockquote><ul><li>对线程同步，使得屏幕打印出 <code>&lt;&gt;&lt;_</code> 和 <code>&gt;&lt;&gt;_</code> 的组合</li></ul><blockquote><p>使用条件变量，只要回答三个问题：</p></blockquote><ul><li>打印 “<code>&lt;</code>” 的条件？打印 “<code>&gt;</code>” 的条件？打印 “<code>_</code>” 的条件？</li></ul><p><em>同步的本质是线程需要等待某件它所预期的事件发生，而事件的发生总是可以用条件 (例如 depth 满足某个条件，或是程序处于某个特定的状态) 来表达。因此计算机系统的设计者实现了条件变量，将条件检查和临界区 “放在一起”，以实现线程间的同步。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8. 调试理论与实践</title>
      <link href="/2024/06/04/OS/class8/"/>
      <url>/2024/06/04/OS/class8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-调试理论">1. 调试理论</h2><h3 id="1-1-Debug">1.1 Debug</h3><blockquote><p>如果我们已经知道 bug 的存在</p></blockquote><ul><li>Segmentation Fault</li><li>Online Judge 拒绝</li><li>虚拟机神秘重启</li><li>……</li></ul><blockquote><p>怎么找到它</p></blockquote><blockquote><p>公理 1：机器永远是对的</p></blockquote><ul><li>CPU: “无情的、执行指令的机器”</li><li>Crash, Wrong Answer, 虚拟机神秘重启<ul><li>99.9999% 是自己的问题</li><li>有亿点点概率是编译器错了 (但你可以知道)</li><li>有亿点点点点概率是处理器错了 (你也可以知道)</li></ul></li></ul><blockquote><p>公理 2：未测代码永远是错的</p></blockquote><ul><li>反复测试过的代码都是错的</li><li>你以为最不可能出 bug 的地方，往往 bug 就在那躺着</li></ul><h3 id="1-2-调试理论">1.2 调试理论</h3><blockquote><p>“软件” 的两层含义</p></blockquote><ul><li>人类需求在信息世界的投影<ul><li>理解错需求 → bug</li></ul></li><li>计算过程的精确 (数学) 描述<ul><li>实现错误 → bug</li></ul></li></ul><blockquote><p>调试为什么困难？</p></blockquote><ul><li>Bug 的触发经历了漫长的过程</li><li>可观测的现象未必能直接对应到 root cause 上</li></ul><h3 id="1-3-Fault，Error，和Failure">1.3 Fault，Error，和Failure</h3><blockquote><p>需求 → 设计 → 代码 (Fault/bug) → 执行 (Error) → 失败 (Failure)</p></blockquote><ul><li>我们只能观测到 failure (可观测的结果错)</li><li>我们可以检查状态的正确性 (但非常费时)</li><li>无法预知 bug 在哪里 (每一行 “看起来” 都挺对的)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>人总是 “默认” (不默认，浪费的时间就太多了)</li></ul><h3 id="1-4-调试理论">1.4 调试理论</h3><blockquote><p>调试理论：如果我们能判定任意程序状态的正确性，那么给定一个 failure，我们可以通过二分查找定位到第一个 error 的状态，此时的代码就是 fault (bug)。</p></blockquote><blockquote><p>推论</p></blockquote><ul><li>为什么我们喜欢 “单步调试”？<ul><li>从一个假定正确的状态出发</li><li>每个语句的行为有限，容易判定是否是 error</li></ul></li><li>为什么调试理论看起来很没用？<ul><li>“判定状态正确” 非常困难</li><li>(是否在调试 DP 题/图论算法时陷入时间黑洞？)</li></ul></li></ul><blockquote><p>调试 = 观察状态机执行 (trace) 的某个侧面</p></blockquote><ul><li>缩小错误状态 (error) 可能产生的位置</li><li>提出假设，作出验证<br>? 观察状态机执行的两个基本工具</li><li>printf → 自定义 log 的 trace<ul><li>灵活可控、能快速定位问题大概位置、适用于大型软件</li><li>无法精确定位、大量的 logs 管理起来比较麻烦</li></ul></li><li>gdb → 指令/语句级 trace<ul><li>精确、指令级定位、任意查看程序内部状态</li><li>耗费大量时间</li></ul></li></ul><p><strong>调试理论给了我们在遇到 “问题” 时候 self-check 的列表：</strong></p><p><strong>是怎样的程序 (状态机) 在运行？<br>我们遇到了怎样的 failure？<br>我们能从状态机的运行中从易到难得到什么信息？<br>如何二分检查这些信息和 error 之间的关联？</strong></p><h2 id="2-调试一切状态机">2. 调试一切状态机</h2><blockquote><p>计算机随时随地都在拒绝你</p></blockquote><p><code>bash: curl: command not found</code></p><p><code>fatal error: 'sys/cdefs.h': No such file or directory #include &lt;sys/cdefs.h&gt;</code></p><p><code>/usr/bin/ld: cannot find -lgcc: No such file or directory</code></p><p><code>make[2]: *** run: No such file or directory.  Stop. Makefile:31: recipe for target 'run' failed</code></p><blockquote><p>万能方法：假设你遇到的问题是别人也遇到的</p></blockquote><ul><li>但如果这是一个全新的问题？</li></ul><h3 id="2-1-一切皆可调试">2.1 一切皆可调试</h3><blockquote><p>程序 = 计算机系统 = 状态机</p></blockquote><ul><li>机器永远是对的</li></ul><blockquote><p>UNIX 世界里你做任何事情都是在编程</p></blockquote><ul><li>“用编程语言把脑中所想传达给电脑”</li><li>刚才的问题都可以看成是程序/输入/配置有 bug</li></ul><blockquote><p>调试理论可以用于解决任何 “问题”</p></blockquote><ul><li>curl: command not found</li><li><code>'sys/cdefs.h'</code>: No such file or directory</li><li>Makefile:31: recipe for target ‘run’ failed</li></ul><h3 id="2-2-使用调试理论">2.2 使用调试理论</h3><blockquote><p>Fault (程序/输入/配置错) → Error → Failure (可观测)</p></blockquote><ul><li>大部分 Error 和 Failure 都比较接近<ul><li>出错时，使用 perror 打印日志</li></ul></li></ul><blockquote><p>“找不到问题” 的原因</p></blockquote><ul><li>出错原因报告不准确</li><li>程序执行的过程看不到<ul><li>那我们想办法 “看到” 状态机的执行过程就好了！</li></ul></li></ul><blockquote><p>理解状态机执行：不是 “调试”，也是 “调试”</p></blockquote><ul><li><code>ssh</code>：使用 <code>-v</code> 选项检查日志</li><li><code>gcc</code>：使用 <code>-v</code> 选项打印各种过程</li><li><code>make</code>：使用 <code>-nB</code> 选项查看完整命令历史</li></ul><blockquote><p>调试：不仅是 “调试器”</p></blockquote><ul><li>Profiler: <code>perf</code> - “采样” 状态机</li><li>Trace: <code>strace</code> - 追踪系统调用</li></ul><h2 id="3-调试理论的应用">3. 调试理论的应用</h2><blockquote><p>需求 → 设计 → 代码 → Fault → Error → Failure</p></blockquote><ul><li>“Technical Debt”: 每当你写出不好维护的代码，你都在给你未来的调试/需求变更挖坑</li></ul><blockquote><p>中枪了？</p></blockquote><ul><li>《计算机系统基础》为了赶紧实现指令，随手写的代码</li><li>《操作系统》为了快点跑程序，随便写的 klib</li><li>《我读研了》为了应付老板，随便写的系统实现</li></ul><h3 id="3-1-调试理论：推论">3.1 调试理论：推论</h3><blockquote><p>需求 → 设计 → 代码 → Fault</p></blockquote><ul><li>写好代码：不要在写代码的时候忘记需求和设计</li><li>不言自明 (Self-explanatory)<ul><li>能通过字面知道需求 (流程)</li></ul></li><li>不言自证 (Self-evident)<ul><li>能通过字面确认代码和需求一致</li></ul></li></ul><blockquote><p>一个评判标准</p></blockquote><ul><li>AI 是否能正确理解/维护你的代码: toybox</li></ul><blockquote><p>Programs are meant to be read by humans and only incidentally for computers to execute. (Donald E. Knuth)</p></blockquote><blockquote><p>Fault → Error</p></blockquote><ul><li>做好测试：未测代码永远是错的<ul><li>残酷的现实：相信自己写不对代码</li><li>LLM 一样经常犯 “傻” 错</li></ul></li></ul><blockquote><p>Small Scope Hypothesis</p></blockquote><p>If a system does not have a counterexample (i.e., an error or a bug) for a certain property within a small scope (a limited size or configuration), then it is unlikely to have a counterexample in a larger scope. (Daniel Jackson)</p><blockquote><p>Error → Failure</p></blockquote><ul><li>多写断言：把代码中的 “隐藏性质” 写出来<ul><li>Error 暴露的越晚，调试越困难</li><li>追溯导致 assert failure 的变量值 (slice) 通常可以快速定位到 bug</li></ul></li></ul><blockquote><p>“There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no obvious deficiencies” (Tony Hoare)</p></blockquote><p><em>如果我们观察到软件发生了 “超出预期的表现”，我们需要理解的是我们的 “预期” 经历了需求 → 设计 → 代码 → Fault → Error → Failure 的漫长过程，其中的每一个过程多多少少都有些失控：我们的预期本身可能有误，或是对软件需要实现的需求有误解。而设计失误、编码错误最终反应到可观测的表现时，有时可能已经太晚了。因此，我们 “写好代码、做好测试、多写断言” 是十分重要的。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7. 并发控制：互斥 (2)</title>
      <link href="/2024/05/30/OS/class7/"/>
      <url>/2024/05/30/OS/class7/</url>
      
        <content type="html"><![CDATA[<h2 id="1-操作系统内核中的互斥">1 操作系统内核中的互斥</h2><h3 id="1-1-计算机系统的状态机模型">1.1 计算机系统的状态机模型</h3><blockquote><p>状态</p></blockquote><ul><li>共享内存 + per-CPU 寄存器</li></ul><blockquote><p>初始状态</p></blockquote><ul><li>由系统设计者规定 (CPU Reset)</li></ul><blockquote><p>状态迁移</p></blockquote><ul><li>选择任意 CPU：<ul><li>从 PC 取指令执行或响应中断信号 (中断打开时)<ul><li>计算：改变内存/寄存器数值</li><li>I/O：与 “计算机系统外” 交换数据</li></ul></li></ul></li></ul><h3 id="1-2-操作系统内核中的互斥">1.2 操作系统内核中的互斥</h3><blockquote><p>操作系统接管了完整的计算机系统</p></blockquote><ul><li>每个处理器都并行 x++</li><li>每个处理器中断发生时执行 x += 1000000000</li><li>(假想 x 是操作系统中的数据结构，例如进程表)</li></ul><blockquote><p>如何正确实现 x 的原子访问？</p></blockquote><ul><li>仅仅自旋是不够的<br>lock后，sum++，如果sum++里面也lock，再执行其他任务的时候，会死锁。</li><li>因为还有中断</li></ul><h3 id="1-3-正确性准则">1.3 正确性准则</h3><blockquote><p>正确实现互斥</p></blockquote><ul><li>关中断 + 自旋可以保证实现互斥</li></ul><blockquote><p>上锁/解锁前后中断状态不变</p></blockquote><ul><li>不得在关中断时随意打开中断 (例如处理中断时)</li><li>不得随意关闭中断 (否则可能导致中断丢失)</li><li>因此我们需要保存中断状态<ul><li>全局？</li><li>Per CPU?</li><li>Per Thread?</li></ul></li><li>xv6 自旋锁</li></ul><h2 id="2-操作系统内核中的-半-无锁互斥">2 操作系统内核中的 (半) 无锁互斥</h2><h3 id="2-1-自旋的后果">2.1 自旋的后果</h3><blockquote><p>同一份计算任务，时间 (CPU cycles) 和空间 (内存占用) 会随处理器数量的增长而变化。</p></blockquote><p><img src="https://cdn-img-el3.pages.dev/os/c7-2.1-1.webp" alt="c7-2.1-1.webp"></p><center> 用自旋锁实现 sum++：更多的处理器，更差的性能 </center><blockquote><p>严谨的统计很难</p></blockquote><p>影响cpu性能的因素：</p><ul><li>CPU 是动态功耗的</li><li>系统中的其他进程</li><li>超线程</li><li>NUMA</li><li>……</li></ul><!-- [Benchmarking crimes](https://gernot-heiser.org/benchmarking-crimes.html) by Gernot Heiser --><h3 id="2-2-自旋锁的使用场景">2.2 自旋锁的使用场景</h3><blockquote><p>操作系统内核的并发数据结构 (短临界区)</p></blockquote><ul><li>临界区几乎不 “拥堵”，迅速结束</li></ul><blockquote><p>Linux Kernel 里有 ~180K 个并发控制函数调用！</p></blockquote><ul><li>自旋锁当然不 scale</li></ul><blockquote><p>许多操作系统内核对象具有 “read-mostly” 特点</p></blockquote><ul><li>路由表<ul><li>每个数据包都要读</li><li>网络拓扑改变时才变更</li></ul></li><li>用户和组信息<ul><li>无时不刻在检查 (Permission Denied)</li><li>但几乎从不修改用户</li></ul></li></ul><h3 id="2-3-Read-copy-update">2.3 Read-copy-update</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Counter *c_current;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Read</span></span><br><span class="line">    Counter *c = c_current;</span><br><span class="line">    <span class="keyword">return</span> c-&gt;sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    SPIN_LOCKED &#123;</span><br><span class="line">        <span class="comment">// Copy</span></span><br><span class="line">        Counter *c = alloc_counter();</span><br><span class="line">        c-&gt;sum = c_current-&gt;sum + <span class="number">1</span>;</span><br><span class="line">        smp_wmb(); <span class="comment">// Memory barrier</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update</span></span><br><span class="line">        c_current = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>改写 = 复制</p></blockquote><ul><li>任何对象都可以复制！<ul><li>(甚至可以只复制改变的部分)</li><li>例子：链表</li></ul></li><li>允许某一时刻，不同 CPU “看到” 不同版本</li></ul><blockquote><p>何时回收旧版本？</p></blockquote><ul><li>旧版本对象会存在一个 “graceful period”</li><li>直到某个时刻，所有 CPU read 都会访问到新版本<ul><li>怎么准确地找到这个时间点？</li></ul></li></ul><h3 id="2-4-Linux内核的复杂性">2.4 Linux内核的复杂性</h3><p><img src="https://cdn-img-el3.pages.dev/os/c7-2.4-1.webp" alt="c7-2.4-1.webp"></p><h2 id="3-应用程序中的互斥">3 应用程序中的互斥</h2><h3 id="3-1-应用程序自旋的后果">3.1 应用程序自旋的后果</h3><blockquote><p>性能问题 (1)</p></blockquote><ul><li>除了进入临界区的线程，其他处理器上的线程都在空转<ul><li>争抢锁的处理器越多，利用率越低</li><li>如果临界区较长，不如把处理器让给其他线程</li></ul></li></ul><blockquote><p>性能问题 (2)</p></blockquote><ul><li>应用程序不能关中断……<ul><li>持有自旋锁的线程被切换</li><li>导致 100% 的资源浪费</li><li>(如果应用程序能 “告诉” 操作系统就好了)</li></ul></li></ul><h3 id="3-2-应用程序：互斥">3.2 应用程序：互斥</h3><blockquote><p>思路：“拟人”</p></blockquote><ul><li>作业那么多，与其干等 Online Judge 发布，不如把自己 (CPU) 让给其他作业 (线程) 执行？</li></ul><blockquote><p>如何 “让”？</p></blockquote><ul><li>只有一种特殊的指令能做到：<code>syscall</code></li><li>把锁的实现放到操作系统里就好<ul><li><code>syscall(SYSCALL_lock, &amp;lk);</code><ul><li>试图获得 lk，但如果失败，就切换到其他线程</li></ul></li><li><code>syscall(SYSCALL_unlock, &amp;lk);</code><ul><li>释放 lk，如果有等待锁的线程就唤醒</li></ul></li></ul></li></ul><blockquote><p>一个足够高性能的实现</p></blockquote><ul><li>具有相当不错的 scalability</li><li>更多线程争抢时也没有极为显著的性能下降</li></ul><blockquote><p>使用方法：与自旋锁完全一致</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock;</span><br><span class="line">pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure><h3 id="3-3-应用程序和互斥锁Futex-Fast-Userspace-muTexes">3.3 应用程序和互斥锁Futex: Fast Userspace muTexes</h3><blockquote><p>小孩子才做选择。操作系统是全都要！</p></blockquote><ul><li>性能优化的最常见技巧：考虑平均而不是极端情况<ul><li>RCU 就用了这个思想！</li></ul></li></ul><blockquote><p>Fast Path: 自旋一次</p></blockquote><ul><li>一条原子指令，成功直接进入临界区</li></ul><blockquote><p>Slow Path: 自旋失败</p></blockquote><ul><li>请求系统调用 futex_wait</li><li>请操作系统帮我达到自旋的效果<ul><li>(实际上并不真的自旋)</li></ul></li></ul><blockquote><p>比想象的复杂</p></blockquote><ul><li>如果没有锁的争抢，Fast Path 不能调用 <code>futex_wake</code></li><li>自旋失败 → 调用 <code>futex_wait</code> → 线程睡眠<ul><li>如果刚开始系统调用，自旋锁被立即释放？</li><li>如果任何时候都可能发生中断？</li></ul></li></ul><blockquote><p>并发：水面下的冰山</p></blockquote><!-- * [LWN: A futex overview and update](https://lwn.net/Articles/360699/)* [Futexes are tricky](https://cis.temple.edu/~giorgio/cis307/readings/futex.pdf) by Ulrich Drepper --><p><em>“互斥” 看起来简单，用自旋就能实现，但如果在实际的场景 (例如可被中断的操作系统内核、不希望浪费 CPU 资源的应用程序等)，实际的互斥实现就不再简单。我们在 xv6 的自旋锁实现中，发现了许多 “防御性编程” 的例子，先假设程序员可能会犯一切可能的错误——然后不断加以检查。而 “正确性完全由开发者负责” 的时代将要过去，我们将会在未来越来越多地看到编程语言中的机制，帮助我们写出正确的代码。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6. 并发控制：互斥 (1)</title>
      <link href="/2024/05/29/OS/class6/"/>
      <url>/2024/05/29/OS/class6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-阻止并发-并行-的发生">1 阻止并发 (并行) 的发生</h2><h3 id="1-1-并发困难的原因">1.1 并发困难的原因</h3><blockquote><p>人类是 “sequential creatures[有序生物]”</p></blockquote><ul><li>人类具备 𝐴→…→𝐵 简化为 𝐴→𝐵 的直觉本能<ul><li>并且据此开发了编译器 (处理器也是编译器)</li><li><strong>多处理器和并发执行推翻了顺序执行的基本假设！</strong></li></ul></li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c5-4.2-2.webp" alt="c5-4.2-2.webp"></p><h3 id="1-2-互斥">1.2 互斥</h3><blockquote><p>人类是 (绝不轻言放弃的) sequential creatures</p></blockquote><ul><li>互斥 (互相排斥)：阻止并发，问题不就解决了？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ATOMIC &#123; sum++; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">T_alipay_withdraw</span><span class="params">(<span class="type">int</span> amt)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    ATOMIC &#123;</span><br><span class="line">        <span class="comment">// No concurrency with</span></span><br><span class="line">        <span class="comment">// other critical sections</span></span><br><span class="line">        <span class="keyword">if</span> (balance &gt;= amt) &#123;</span><br><span class="line">            balance -= amt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-互斥：阻止并发、独占访问">1.3 互斥：阻止并发、独占访问</h3><blockquote><p>既然用互斥 “阻止并发”，那我们为什么还要做并行？</p></blockquote><blockquote><p>状态机视角的互斥</p></blockquote><ul><li>临界区同时发生时，依然满足执行的原子性</li><li>可以把多次状态迁移理解为 “一次大状态迁移”</li></ul><blockquote><p>实现任何共享资源 (内存) 的独占访问</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ATOMIC &#123;</span><br><span class="line">    <span class="comment">// 状态迁移 (语义）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock();</span><br><span class="line"><span class="comment">// 任意代码</span></span><br><span class="line">unlock();</span><br></pre></td></tr></table></figure><blockquote><p>既然是顺序执行，那我们还要并发做什么？</p></blockquote><ul><li>如果你有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">1/k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>的代码是不能并发执行的，那么：</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>T</mi><mi mathvariant="normal">∞</mi></msub><mo>&gt;</mo><mfrac><msub><mi>T</mi><mn>1</mn></msub><mi>k</mi></mfrac></mrow><annotation encoding="application/x-tex">T_∞&gt;\frac{T_1}{k} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><ul><li>并行计算总是能实现的：</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>T</mi><mi>p</mi></msub><mo>&lt;</mo><msub><mi>T</mi><mi mathvariant="normal">∞</mi></msub><mo>+</mo><mfrac><msub><mi>T</mi><mn>1</mn></msub><mi>k</mi></mfrac></mrow><annotation encoding="application/x-tex">T_p &lt; T_∞ + \frac{T_1}{k} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h3 id="1-4-计算是可以并行的">1.4 计算是可以并行的</h3><blockquote><p>经典物理：局部性原理</p></blockquote><ul><li>物体对相邻物体的影响需要时间<ul><li>(即便严格来说不成立，依然是一个很好的近似)</li></ul></li><li>推论：任何物理世界模拟皆可以大规模并行</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>𝑇</mi><mi mathvariant="normal">∞</mi></msub><mo>≪</mo><msub><mi>𝑇</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">𝑇_∞≪𝑇_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≪</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p>Embarrassingly Parallel 的例子</p></blockquote><ul><li>图书馆 v.s. 分布式数据存储</li><li>大脑 v.s. 深度神经网络</li><li>……</li></ul><h3 id="1-5-实现互斥">1.5 实现互斥</h3><blockquote><p>能否使当前程序状态机独占计算机系统？</p></blockquote><ul><li>类比：关掉电脑手机，专注一件事</li><li>单处理器系统中 “其他任何事”：仅有中断</li></ul><blockquote><p>一条指令就可以实现原子性</p></blockquote><ul><li>x86: <code>cli</code> 清除 eflags 中的 IF bit</li><li>RISC-V: 清除 mstatus 的 MIE bit</li><li>AArch64: msr daifset, #3<ul><li>程序死循环 = 计算机系统卡死</li></ul></li></ul><blockquote><p>道高一尺、魔高一丈</p></blockquote><ul><li>处理器有 NMI (Non-Maskable Interrupts)</li><li>可以利用 NMI 实现错误监控<ul><li>设置硬件定时触发</li><li>操作系统定时复位定时器</li><li>触发 timeout，执行 NMI 处理程序<ul><li>例如，重启计算机</li></ul></li></ul></li></ul><h3 id="1-6-关中断不是万能的">1.6 关中断不是万能的</h3><blockquote><p>操作系统可以，但普通程序不行</p></blockquote><ul><li>中断保证了死循环不能把计算机 “卡死”</li><li>操作系统不允许普通程序关中断<ul><li>但如果是操作系统代码，完全可以短暂关闭中断</li></ul></li></ul><blockquote><p>单处理器系统可以，多处理器系统不行</p></blockquote><ul><li>每个处理器有独立的寄存器组</li><li>中断是每个处理器内部状态</li></ul><h2 id="2-使用-load-store-实现互斥">2 使用 load/store 实现互斥</h2><blockquote><p><a href="https://series1.github.io/blog/dekkers-algorithm/">绕口令</a>：A process 𝑃 can enter the critical section if the other does not want to enter, otherwise it may enter only if it is its turn.</p></blockquote><blockquote><p>实现假设</p></blockquote><ul><li>任何时候可以执行一条 load/store 指令</li><li>读写本身是原子的</li></ul><blockquote><p>并发的危险</p></blockquote><ul><li>你很难从字面上判断它到底对不对</li></ul><h3 id="2-1-问题重述">2.1 问题重述</h3><p>举例：上厕所</p><blockquote><p>若希望进入厕所，按顺序执行以下操作：</p></blockquote><ol><li>举起自己的旗子 (store)</li><li>把写有对方名字的字条贴在厕所门上 (store; 覆盖)</li></ol><blockquote><p>然后进入持续的观察模式：</p></blockquote><ol><li>观察对方是否举旗 (load)</li><li>观察厕所门上的名字 (load)<ul><li>对方不举旗或名字是自己，进入厕所，否则继续观察</li></ul></li></ol><blockquote><p>出厕所后，放下自己的旗子</p></blockquote><ul><li>不用管门上的字条</li></ul><p>总结：A手上拿着B的旗子，B手上拿着A的旗子，也就是说最开始A和B都举旗子了，然后A和B就会抢着把对方的旗子贴在门上，然后A和B乱序贴完后就开始观察门上的名字，如果是自己，就进厕所，如果不是自己，就继续观察。（贴的时候闭眼，观察的时候睁眼）</p><p>结论：手快反而会后进入。</p><blockquote><p>进入临界区的情况</p></blockquote><ul><li>如果只有一个人举旗，他就可以直接进入</li><li>如果两个人同时举旗，由厕所门上的标签决定谁进<ul><li>手快 🈶️ (被另一个人的标签覆盖)、手慢 🈚</li></ul></li></ul><blockquote><p>一些具体的细节情况</p></blockquote><ul><li>A 看到 B 没有举旗<ul><li>B 一定不在临界区</li><li>B 可能想进但还没来得及把 “B 正在使用” 贴在门上</li></ul></li><li>A 看到 B 举旗子<ul><li>A 一定已经把旗子举起来了 (!@^#&amp;!%^(&amp;^!@%#</li></ul></li></ul><blockquote><p>自动遍历状态空间的乐趣：快速回答更多问题</p></blockquote><ul><li>如果结束后把门上的字条撕掉，算法还正确吗？<ul><li>在放下旗子之前撕 v.s. 放下旗子之后撕</li></ul></li><li>先贴标签再举旗，算法还正确吗？</li><li>观察模式两个查看操作的顺序影响正确性吗？<ul><li>看对方的旗有没有举起来</li><li>看门上的贴纸是不是自己</li></ul></li><li>是否存在 “两个人谁都无法进入临界区” (liveness)、“对某一方不公平” (fairness) 等行为？<ul><li>都转换成图 (状态空间) 上的遍历问题了！</li></ul></li></ul><h3 id="2-2-Model-Checker和自动化">2.2 Model Checker和自动化</h3><blockquote><p>电脑为什么叫 “电脑”</p></blockquote><pre><code>- 因为它能替代部分人类的思维活动</code></pre><blockquote><p>回忆：每个班上都有一个笔记和草稿纸都工工整整的 Ta</p></blockquote><ul><li>Ta：认认真真完成老师作业<ul><li>工整的笔记可以启发思维，但花费了宝贵的人工</li></ul></li><li>我：烦死了！劳资不干了！玩去了<ul><li>战略：提出好的问题、适当地分解问题</li><li>战术：尽可能使用先进工具替代机械思维活动<ul><li>对于 Peterson 算法：都是一个晚自习时间，model checker 可以回答更多更深刻的问题</li></ul></li></ul></li></ul><blockquote><p>关于学习 (思考)：Tree of Thoughts</p></blockquote><ul><li>有一些别名：“批判性思维”、“第一性原理”……</li><li>有一些实现：AlphaGo……</li></ul><blockquote><p>那个好好学习的、总被老师表扬的 Ta？</p></blockquote><ul><li>听话的学生 → Chain of Thoughts (顺从)</li><li>不听话的学生 → Tree of Thoughts (质疑)</li></ul><h3 id="2-3-实现-Peterson-算法">2.3 实现 Peterson 算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;    <span class="comment">// 举起自己的旗子</span></span><br><span class="line">turn = B; <span class="comment">// 贴上对方的名字</span></span><br><span class="line"><span class="keyword">do</span> &#123;      <span class="comment">// 进入持续观察模式</span></span><br><span class="line">&#125; <span class="keyword">while</span> (b &amp;&amp; turn == B); <span class="comment">// 对方举旗且门上是对方的的名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;    <span class="comment">// 放下自己的旗子</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">1</span>;</span><br><span class="line">turn = A;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">&#125; <span class="keyword">while</span> (a &amp;&amp; turn == A);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><blockquote><p>模型的假设：Atomic load &amp; store</p></blockquote><ul><li>但这个假设在现代多处理器上并不成立</li><li>所以实际上按照模型直接写 Peterson 算法应该是错的？<ul><li>不妨实现了试一试？</li></ul></li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c5-4.2-2.webp" alt="c5-4.2-2.webp"></p><h3 id="2-4-现实中的-Peterson-算法">2.4 现实中的 Peterson 算法</h3><blockquote><p>“实现正确的 Peterson 算法” 是合理需求</p></blockquote><ul><li>编译器应该提供了机制实现</li></ul><blockquote><p>内存屏障 (Memory Barrier)</p></blockquote><ul><li><code>__sync_synchronize()</code> = Compiler Barrier +<ul><li>x86: <code>mfence</code></li><li>ARM: <code>dmb ish</code></li><li>RISC-V: <code>fence rw, rw</code></li></ul></li></ul><blockquote><p>编译器到底做了什么？</p></blockquote><ul><li><a href="https://godbolt.org/">godbolt.org</a>，不用装那些 cross compiler 了<ul><li>你甚至可以看到 compiler barrier 是如何在优化中传递的</li></ul></li></ul><h2 id="3-在多处理器上实现互斥">3 在多处理器上实现互斥</h2><p>继续回到厕所问题</p><blockquote><p>为什么不能就 “等在门口” 呢？</p></blockquote><ul><li>上一个人出来了，我再进去呗！</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> status = ✅;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">retry:</span><br><span class="line">    <span class="keyword">if</span> (status != ✅) &#123;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">    status = ❌;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    status = ✅;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 锁门的时候有人，不进去，不锁门的时候进去，但是这样是不可以的，因为两个线程同时进去的时候，都会观测到 ✅</span></span><br></pre></td></tr></table></figure><blockquote><p>没有跨语句 (指令) 的原子性？</p></blockquote><ul><li>Peterson 算法真是大费周章</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">retry:</span><br><span class="line">    <span class="keyword">if</span> (status != ✅) &#123;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">    status = ❌;</span><br></pre></td></tr></table></figure><blockquote><p>软件不够，硬件来凑</p></blockquote><ul><li>原子指令：一小段时间的 “Stop the World” 执行</li><li>不可打断的 load + 计算 + store<ul><li>x86: Bus Lock; RISC-V: LR/SC (来自 MIPS) + atomic</li></ul></li></ul><p><code>asm volatile(&quot;lock incq %0&quot; : &quot;+m&quot;(sum));  </code></p><p><img src="https://cdn-img-el3.pages.dev/os/c6-3-1.webp" alt="c6-3-1.webp"></p><h3 id="3-1-第一个自旋锁">3.1 第一个自旋锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原子交换操作atomic_xchg</span></span><br><span class="line"><span class="comment">// atomic_xchg就可以stop the world，所以实现了多线程的原子操作</span></span><br><span class="line"><span class="type">int</span> status = ✅;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">retry:</span><br><span class="line">    <span class="type">int</span> got = <span class="type">atomic_xchg</span>(&amp;status, ❌);</span><br><span class="line">    <span class="keyword">if</span> (got != ✅) &#123;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">atomic_xchg</span>(&amp;status, ✅);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有 “带条件写入” 的版本：节约写入内存带宽</p></blockquote><p><em>并发编程 “很难”：想要完全理解并发程序的行为，是非常困难的——我们甚至可以利用一个 “万能” 的调度器去帮助我们求解 NP-完全问题。因此，人类应对这种复杂性的方法就是退回到不并发。通过互斥实现 stop/resume the world，我们就可以使并发程序的执行变得更容易理解——而只要程序中 “能并行” 的部分足够多，串行化一小部分也并不会对性能带来致命的影响。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于对抽象的一点理解</title>
      <link href="/2024/05/29/programming/abstract/"/>
      <url>/2024/05/29/programming/abstract/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是抽象">1 什么是抽象</h2><h3 id="1-1-关于多态">1.1 关于多态</h3><p><em>在面向对象编程中，多态是指一类事物有多种形态。比如A类，A-1和A-2都属于动物类，它们都有A类中公共的方法</em></p><blockquote><p>由于多态的存在，每个子类都可以覆写父类的方法，例如下面的代码中子类1和2都覆写了父类中的某个方法：</p></blockquote><p>在这里，假如我们要设计一款游戏名叫 <strong>Apax</strong> 的枪械游戏。在这款游戏中，我们的武器就是枪械，所以我们来为我们的游戏设计一个 <code>Weapon</code> 类，它代表所有枪械的父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类-武器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">    <span class="comment">// 具有的方法</span></span><br><span class="line">    <span class="comment">// 子弹类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">WeaponAmmo</span><span class="params">()</span> &#123; … &#125;</span><br><span class="line">    <span class="comment">// 击中要害转化倍率</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">WeaponForce</span><span class="params">()</span> &#123; … &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类1-轻型弹药武器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LightAmmo</span> <span class="keyword">extends</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">WeaponAmmo</span><span class="params">()</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类2-霰弹类武器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShotgunAmmo</span> <span class="keyword">extends</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">WeaponAmmo</span><span class="params">()</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-关于抽象">1.2 关于抽象</h3><p>可以看到， <code>WeaponAmmo</code> 方法在子类中是覆写的父类的方法，并且父类也确实具有 <code>WeaponAmmo</code> 方法的实现。<strong>但是</strong>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">    <span class="comment">// 此处并未赋予WeaponAmmo方法任何实现，仅仅只是定义了WeaponAmmo方法的签名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">WeaponAmmo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把一个方法声明为 <code>abstract</code> ，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以， <code>Weapon</code> 类也无法被实例化。编译器会告诉我们，无法编译 <code>Weapon</code> 类，因为它包含抽象方法。必须把 <code>Weapon</code> 类本身也声明为 <code>abstract</code> ，才能正确编译它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">WeaponAmmo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个 <code>class</code> 定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用 <code>abstract</code> 修饰。</p><p>因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。</p><p>使用 <code>abstract</code> 修饰的类就是抽象类。我们无法实例化一个抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Weapon</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weapon</span>(); <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><blockquote><p>正确的方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义了一个使用轻型弹药的武器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weapon</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weapon</span>();</span><br><span class="line">        w.WeaponAmmo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">WeaponAmmo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LightAmmo</span> <span class="keyword">extends</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">WeaponAmmo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用轻型弹药&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们定义了抽象类 <code>Weapon</code> ，以及具体的 <code>LightAmmo</code> 、 <code>ShotgunAmmo</code> 子类的时候，我们可以通过抽象类 <code>Weapon</code> 类型去引用具体的子类的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Weapon</span> <span class="variable">R301</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LightAmmo</span>();</span><br><span class="line"><span class="type">Weapon</span> <span class="variable">Peacekeeper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShotgunAmmo</span>();</span><br></pre></td></tr></table></figure><blockquote><p>这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</p></blockquote><p>面向抽象编程的本质就是：</p><ul><li><p>上层代码只定义规范；</p></li><li><p>不需要子类就可以实现业务逻辑；</p></li><li><p>具体的业务逻辑由不同的子类实现，调用者并不关心。</p></li></ul><h2 id="2-进一步理解抽象">2 进一步理解抽象</h2><p><em>将复杂的概念进行封装与简化</em></p><blockquote><p>抽象减少了信息的负载，否则需要全面详细地记录与处理事物的所有细节（熵减）。抽象的目标是简化看待事物的方式，允许忽略一些不重要的东西。</p></blockquote><ul><li><p>编程的时候，并不需要直接操作比特流，这一切都是编译器提供的功能。</p><ul><li>可以说编译器在编译的时候做了一层抽象。</li></ul></li><li><p>抽象就是隐藏细节，只暴露接口。在使用计算机的usb等接口的时候，我们只需要做连接操作，不需要关心它的具体实现。</p><ul><li>可以说计算机接口在运行的时候做了一层抽象。</li></ul></li></ul><p>在写代码的时候，我们可以在一开始就定义好接口，然后具体实现的时候再去实现。这样可以提高代码可读性且减少代码量与复杂度。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抽象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5. 多处理器编程：从入门到放弃</title>
      <link href="/2024/05/28/OS/class5/"/>
      <url>/2024/05/28/OS/class5/</url>
      
        <content type="html"><![CDATA[<h2 id="1-多处理器编程入门">1 多处理器编程入门</h2><h3 id="1-1-多线程编程模型">1.1 多线程编程模型</h3><blockquote><p>多个共享内存的状态机</p></blockquote><ul><li>C 语言状态机的多个线程<ul><li>共享所有全局变量</li><li>独立的栈帧列表</li></ul></li><li>汇编语言状态机的多个线程<ul><li>共享一个地址空间</li><li>独立的寄存器 (SP 指向不同内存位置)</li></ul></li></ul><blockquote><p>状态迁移</p></blockquote><ul><li>选择任意一个线程执行一步</li></ul><blockquote><p>Mosaic 状态机</p></blockquote><ul><li>“heap” 是共享内存</li><li>sys_sched 主动随机切换线程<ul><li>单处理器系统：中断会引起切换<ul><li>(这就是为什么死循环不能把机器卡死)</li></ul></li><li>多处理器系统：真正同时执行<ul><li>相当于无时不刻在切换</li></ul></li></ul></li></ul><blockquote><p>模拟多线程程序的行为</p></blockquote><ul><li>思考题：我们可以借助共享内存做什么？</li></ul><h3 id="1-2-多处理器编程：入门">1.2 多处理器编程：入门</h3><blockquote><p>简化的线程 API (使用thread.h库就可以直接create)</p></blockquote><ul><li><code>spawn(fn)</code><ul><li>创建一个入口函数是 <code>fn</code> 的线程，并立即开始执行<ul><li><code>void fn(int tid) &#123; ... &#125;</code></li><li>参数 <code>tid</code> 从 1 开始编号</li></ul></li><li>行为：<code>sys_spawn(fn, tid)</code></li></ul></li><li><code>join()</code><ul><li>等待所有运行线程的返回 (也可以不调用)</li><li>行为：<code>while (done != T) sys_sched()</code></li></ul></li></ul><blockquote><p>一个API搞定</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">T_a</span><span class="params">()</span> &#123; <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;a&quot;</span>); &#125; &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">T_b</span><span class="params">()</span> &#123; <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;b&quot;</span>); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    create(T_a);</span><br><span class="line">    create(T_b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实现多处理器的利用</p></blockquote><pre><code>- 操作系统会自动把线程放置在不同的处理器上- CPU 使用率超过了 100%</code></pre><h3 id="1-3-Q-A">1.3 Q&amp;A</h3><blockquote><p><code>T_a</code> 和 <code>T_b</code> 真的共享内存吗？</p></blockquote><ul><li>如何证明/否证这件事？</li></ul><blockquote><p>如何证明线程具有独立堆栈 (以及确定堆栈的范围)？</p></blockquote><ul><li>输出混乱，应该如何处理？</li></ul><blockquote><p>更多的 “好问题” 和解决</p></blockquote><ul><li><p>创建线程使用的是哪个系统调用？<br><code>man pthreads</code></p></li><li><p>能不能用 gdb 调试？</p><ul><li>基本原则：有需求，就能做到 (RTFM)</li></ul></li></ul><h2 id="2-放弃-1-：状态迁移原子性的假设">2 放弃 (1)：状态迁移原子性的假设</h2><p>当我们谈 “放弃” 时，放弃的并非并发编程，而是要舍弃一些我们之前对单线程顺序程序的理解。这些理解在我们长期的编程中，多多少少成为了肌肉记忆，这也是并发编程打破这些理解带来麻烦的原因。我们努力试图理解并发程序和顺序程序的本质区别，从而更好地应对并发带来的编程挑战。</p><h3 id="2-1-反思：状态机模型的隐含假设">2.1 反思：状态机模型的隐含假设</h3><blockquote><p>“世界上只有一个状态机”</p></blockquote><ul><li>没有其他任何人能 “干涉” 程序的状态</li><li>课堂上常用的简化方法<ul><li>假设一段程序执行没有系统调用</li><li>可以直接简化为一个原子的状态迁移 “计算”</li></ul></li></ul><h3 id="2-2-放弃-1-反思：状态机模型的隐含假设">2.2 放弃 (1)反思：状态机模型的隐含假设</h3><blockquote><p>共享内存推翻了 “原子性” 假设</p></blockquote><ul><li>任何时候，load 读到的值都可能是别的线程写入的</li><li>我们习以为常的简化会漏掉并发程序可能的行为<ul><li>如果你觉得你可能会犯错误，那别人也一定会的</li></ul></li></ul><blockquote><p>一些我们见到过的例子</p></blockquote><ul><li>线程的交错执行 <code>ABABAABB</code></li><li>消失的 1: <code>A2B2A3A5B5B6</code></li><li>潘多拉的魔盒已经打开……</li></ul><h3 id="2-3-并发Bugs">2.3 并发Bugs</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> balance = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">T_alipay_withdraw</span><span class="params">(<span class="type">int</span> amt)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (balance &gt;= amt) &#123;</span><br><span class="line">        balance -= amt;</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> FAIL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>两个线程并发支付 ¥100 会发生什么 (代码： <code>alipay.c</code> )</p></blockquote><p>当把usleep(1)取消注释后，程序执行将会无法合理计算，因为两个线程的执行顺序是随机的。</p><ul><li>账户里会多出用不完的钱！</li><li>历史事件：Mt. Gox Hack 损失 650, 000 BTC</li></ul><blockquote><p>计算 1+1+1+…+1 (sum.c)</p></blockquote><ul><li>共计 2n 个 1，分 2 个线程计算</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100000000</span></span><br><span class="line"><span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">T_sum</span><span class="params">()</span> &#123; <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) sum++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    create(T_sum);</span><br><span class="line">    create(T_sum);</span><br><span class="line">    join();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %ld\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>会得到怎样的结果？<br>基本上得不到同样的sum</li></ul><blockquote><p>正确实现并发 1 + 1 比想象中困难得多</p></blockquote><ul><li>1960s，大家争先在共享内存上实现原子性 (互斥)</li><li>但几乎所有的实现都是错的<ul><li>直到<a href="https://en.wikipedia.org/wiki/Dekker%27s_algorithm">Dekker’s Algorithm</a>的算法出现，还只能保证两个线程的互斥</li></ul></li></ul><blockquote><p>感到脊背发凉？</p></blockquote><ul><li>printf 还能在多线程程序里调用吗？<ul><li>当然可以，但会乱序执行</li></ul></li></ul><h3 id="2-4-失去“原子执行”的终极后果">2.4 失去“原子执行”的终极后果</h3><blockquote><p>并发执行三个 T_sum，sum 的最小值是多少？</p></blockquote><ul><li>初始时 sum = 0; 假设单行语句的执行是原子的</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">T_sum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t = load(sum);</span><br><span class="line">        t += <span class="number">1</span>;</span><br><span class="line">        store(sum, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>GPT-4: 细微改变问题会导致各种错误回答<ul><li>Claude 3 Opus 也不行，大模型没戏</li><li><a href="https://epubs.siam.org/doi/10.1137/S0097539794279614">Trace recovery is NP-Complete.</a></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sum_model</span></span><br><span class="line">mosaic -C sum.py | collect</span><br></pre></td></tr></table></figure><blockquote><p>Model Checker: sum = 2</p></blockquote><ul><li>是的，不是 1<ul><li>(因为有 <code>i</code> 的循环)</li></ul></li><li>也不是 3<ul><li>虽然 sum = 3 是很容易想到的</li></ul></li><li>无论有多少 <code>T_sum</code>，都可以 sum = 2</li></ul><blockquote><p>GPT-4 的 “直觉” 哪怕对最 “简单” 的并发程序都不起效</p></blockquote><h3 id="2-5-“数学视角”的价值">2.5 “数学视角”的价值</h3><blockquote><p>对于并发，讲概念是不够的</p></blockquote><ul><li>事实可能不是你想的那样</li></ul><blockquote><p>甚至讲代码都是不够的</p></blockquote><ul><li>代码需要非常精巧的 workload 才能跑出那个 corner case</li></ul><blockquote><p>证明才是解决问题的方法</p></blockquote><p>证明：∀ 线程调度方法，程序满足 XXX 性质。</p><ul><li>我们现在甚至还没有趁手的并发程序证明工具！</li><li>对于课堂的例子，model checker 倒也够用了</li></ul><h2 id="3-放弃-2-：程序顺序执行的假设">3 放弃 (2)：程序顺序执行的假设</h2><h3 id="3-1-状态机模型的隐含假设">3.1 状态机模型的隐含假设</h3><blockquote><p>“世界上只有一个状态机”</p></blockquote><ul><li>没有其他任何人能 “干涉” 程序的状态</li><li>课堂上常用的简化方法<ul><li>假设一段程序执行没有系统调用</li><li>可以直接简化为一个原子的状态迁移 “计算”</li></ul></li></ul><blockquote><p>编译器也做了同样的假设</p></blockquote><ul><li>编译器会试图优化状态迁移，改变执行流</li></ul><h3 id="3-2-放弃程序按顺序执行的假设">3.2 放弃程序按顺序执行的假设</h3><blockquote><p>共享内存推翻了编译器的假设</p></blockquote><ul><li>但编译器依然会按照顺序执行优化代码</li><li>否则几乎任何涉及共享内存的代码都变得 “不可优化”</li></ul><blockquote><p>程序的行为在并发编程下变得更难理解了</p></blockquote><ul><li>“顺序程序” 变得一点也不 “顺序” 了</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100000000</span></span><br><span class="line"><span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">T_sum</span><span class="params">()</span> &#123; <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) sum++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    create(T_sum);</span><br><span class="line">    create(T_sum);</span><br><span class="line">    join();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %ld\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果添加编译优化？</p></blockquote><ul><li><code>-O1</code>: 100000000</li><li><code>-O2</code>: 200000000</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!flag);</span><br></pre></td></tr></table></figure><blockquote><p>“等另一个线程举起旗子，我再继续”？</p></blockquote><ul><li>如果这是个顺序程序，编译器可以做什么优化？<ul><li>(这甚至也是一个常见的并发 bug 模式)</li><li>“Ad hoc synchronization considered harmful”</li></ul></li></ul><blockquote><p>方法 1：插入 “不可优化” 代码</p></blockquote><ul><li>asm volatile (“” ::: “memory”);<ul><li>告诉编译器其他线程可能写入内存</li></ul></li></ul><blockquote><p>方法 2：标记变量 load/store 为不可优化</p></blockquote><ul><li>使用 volatile 修饰变量可以做到</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">volatile</span> flag;</span><br><span class="line"><span class="keyword">while</span> (!flag);</span><br></pre></td></tr></table></figure><blockquote><p>以上都不是《操作系统》课推荐的方法</p></blockquote><ul><li>“一把大锁保平安” 加锁 ✔</li></ul><h2 id="4-放弃-3-：存在全局指令执行顺序的假设">4 放弃 (3)：存在全局指令执行顺序的假设</h2><h3 id="4-1-状态机模型的隐含假设">4.1 状态机模型的隐含假设</h3><blockquote><p>状态迁移</p></blockquote><ul><li>选择一个线程，执行一条指令</li><li>“顺序一致性” (sequential consistency)</li></ul><blockquote><p>单处理器多线程符合这个假设</p></blockquote><ul><li>处理器会保证指令 “看起来” 顺序完成</li><li>处理器也是编译器 (oops… 感觉不好的事情要发生了)<ul><li>预取状态机执行的若干步，然后像编译器一样优化</li><li>Load(x); Store(y)</li><li>𝑥≠𝑦 → 两条指令执行的先后顺序就无所谓</li><li>Load cache miss → store 可以直接执行</li></ul></li></ul><h3 id="4-2-放弃全局顺序存在的假设">4.2 放弃全局顺序存在的假设</h3><blockquote><p>共享内存推翻了 “统一上帝视角” 的存在性</p></blockquote><ul><li>就像相对论中，时间顺序的相对性<ul><li>𝐴 和 𝐵 没有因果关系，例子：Load(x) v.s. Store(y)</li><li>两个观测者可以分别看到 𝐴→𝐵 或 𝐵→𝐴</li><li>观测的相对性使全局世界的行为 “极难理解”</li></ul></li></ul><blockquote><p>不同处理器可能看到不同的共享内存</p></blockquote><ul><li>“一个共享内存” 只是个简化的幻觉</li><li>Reading: <a href="https://research.swtch.com/mm">Memory Models</a> by Russ Cox</li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c5-4.2-1.webp" alt="c5-4.2-1.webp"></p><p>实际上：</p><p><img src="https://cdn-img-el3.pages.dev/os/c5-4.2-2.webp" alt="c5-4.2-2.webp"></p><h3 id="4-3-“相对论效应”带来的后果">4.3 “相对论效应”带来的后果</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//men-model.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">T1</span><span class="params">()</span> &#123;</span><br><span class="line">  x = <span class="number">1</span>; <span class="type">int</span> t = y; <span class="comment">// Store(x); Load(y)</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">T2</span><span class="params">()</span> &#123;</span><br><span class="line">  y = <span class="number">1</span>; <span class="type">int</span> t = x; <span class="comment">// Store(y); Load(x)</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Model Checker: 01 10 11</p></blockquote><ul><li>实际：00 (???) 未被观测到</li></ul><blockquote><p>CPU 设计者面临了难题</p></blockquote><ul><li>更强的内存模型 = 更糟糕的性能，但更容易编程</li><li>x86：市面 “最强” 内存模型 (类比 ARM/RISC-V)</li></ul><blockquote><p>因此，在 ARM 上模拟 x86 是个世界性的难题</p></blockquote><p><em>在简化多线程的模型中，并发程序就是 “状态机的集合”，每一步选一个状态机执行一步。然而，真实的系统却因为 “编译器” 的无处不在，使共享内存并发的行为十分复杂。</em></p><p><em>不幸的是，人类本质上是物理世界 (宏观时间) 中的 “sequential creature”，因此我们在编程时，我们的直觉也只习惯于单线程的顺序/选择/循环结构，真实多处理器上的并发编程是非常具有挑战性的 “底层技术”。在后续的课程中，我们将会提出若干并发控制技术，使得我们可以在需要的时候避免并发的发生，使并发程序退回到顺序程序，从而使我们能够理解和控制并发。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4. 数学视角的操作系统</title>
      <link href="/2024/05/27/OS/class4/"/>
      <url>/2024/05/27/OS/class4/</url>
      
        <content type="html"><![CDATA[<h2 id="1-程序正确性证明">1 程序正确性证明</h2><blockquote><p>数千年来，数学的“严格性”都是由人类保证的</p></blockquote><h3 id="1-1-程序的本质">1.1 程序的本质</h3><blockquote><p>程序是一种 “数学严格” 的对象</p></blockquote><ul><li><p>Everything is a state machine</p><ul><li>程序 = 初始状态 + 迁移函数</li><li>在这个视角下，程序和数学对象已经无限接近了</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f(s) = s&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8019em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></p></li><li><p>我们经常写出 “似是而非” 的代码</p></li><li><p>类似于细节有错但可以修正的数学证明</p><ul><li><code>for (int j = 0; j &lt; n; i++)</code></li><li>(有时候也会疏忽，导致设计全错)</li></ul></li></ul><blockquote><p>为什么会有程序？</p></blockquote><ul><li>是因为我们有无情的执行指令的机器 (计算机)</li><li>只有程序才配得上它</li></ul><blockquote><p>程序天生是 “人类” 的，也是 “反人类” 的</p></blockquote><ul><li>人类的一面：程序连接了人类世界需求<ul><li>程序写的一切都能在现实生活观测到</li><li>我们并不是在实现 “uniform-random” 的 𝑓</li></ul></li><li>反人类的一面：程序会在机器上执行<ul><li>初学者对 “机器严格” 普遍不太适应</li><li>部分原因是对程序的行为没有 100% 的掌控</li><li>使用秘技：debug来观察程序的行为</li></ul></li></ul><h3 id="1-2-当我们谈论数学的时候，我们想谈论什么？">1.2 当我们谈论数学的时候，我们想谈论什么？</h3><blockquote><p>证明程序正确性！</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AlipayAccount</span>:</span><br><span class="line">    b: <span class="built_in">int</span> = <span class="number">0</span>  <span class="comment"># Balance</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">...</span>): ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">...</span>): ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transfer</span>(<span class="params">...</span>): ...</span><br></pre></td></tr></table></figure><blockquote><p>针对这段python代码，我们可以用数学的语言提出程序的规约</p></blockquote><ul><li>例如：任意时刻 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi mathvariant="normal">.</mi><mi>b</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a.b≥0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal">a</span><span class="mord">.</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></li><li>有没有可能真正 “证明” 它呢？<br>任意状态中b都大于0</li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c4-1.2-1.webp" alt="证明方式"></p><h3 id="1-3-程序正确性证明的两种方法">1.3 程序正确性证明的两种方法</h3><blockquote><p>暴力枚举-启发</p></blockquote><ul><li>写一个 driver code，运行所有可能的函数调用序列，proof assistant 帮助我们检查<ul><li>PL/SE 已经研究生成 driver code 几十年了</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>t</mi><mo stretchy="false">(</mo><mi>b</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">assert(b≥0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">sser</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></li></ul></li><li>如果机器和 driver 都没有 bug，程序就是对的</li></ul><blockquote><p>写出证明-启发</p></blockquote><ul><li>我们可以多写<code>assert</code>断言来避免出错</li><li>For all 𝑓 - reachable states, b≥0 holds.</li><li>为 𝑓 写一份数学证明就行了<ul><li>就像你在上数学课时做的习题一样</li></ul></li></ul><p>没错，计算机科学和数学的发展速度可能超过大家的想象——我们有被 “证明正确” 的 编译器、操作系统内核；可以阅读科普文章：</p><p><em>Formal verification doesn’t result in perfect code; it simply narrows the possibility for errors and vulnerabilities to creep in, ” Parno says. “What makes the technique so attractive is that you push the uncertainty or scope of problems down to smaller and smaller windows.</em></p><p><em>同时，proof assistant 也是人工智能时代堪称完美的辅助工具：如果我们要信任 AI 产生的结果，就让它们给出一个 proof assistant 认可的证明吧！</em></p><h2 id="2-为操作系统建模">2 为操作系统建模</h2><h3 id="2-1-操作系统的两个视角">2.1 操作系统的两个视角</h3><blockquote><p>应用视角 (自顶向下)</p></blockquote><ul><li>操作系统 = 对象 + API<ul><li>应用通过 <code>syscall</code> 访问操作系统</li></ul></li></ul><blockquote><p>机器视角 (自底向上)</p></blockquote><ul><li>操作系统 = C 程序<ul><li>运行在计算机硬件上的一个普通程序</li></ul></li></ul><h3 id="2-2-为操作系统建模">2.2 为操作系统建模</h3><blockquote><p>操作系统 = 状态机的管理者（状态机的容器）</p></blockquote><ul><li>当然，它自己也是状态机，有自己的状态</li></ul><blockquote><p>有了一个有趣的想法……</p></blockquote><ul><li>能不能我们自己定义 “状态机”<ul><li>用我们喜欢的语言、喜欢的方式</li><li>不要受限于 C、汇编……</li></ul></li><li>自己模拟状态机的执行<ul><li>形成一个 “玩具操作系统”</li></ul></li></ul><blockquote><p>简化的操作系统模型</p></blockquote><ul><li>用更方便的编程语言描述状态机<ul><li>依然是程序</li><li>依旧是 “数学严格” 的对象</li></ul></li><li>但用更简单的方法实现操作系统<ul><li>管理状态机</li><li>执行系统调用</li></ul></li></ul><h3 id="2-3-表示状态机">2.3 表示状态机</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">StateMachine</span>():</span><br><span class="line">    b = sys_read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        sys_write(<span class="string">&#x27;I got a zero.&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sys_write(<span class="string">&#x27;I got a one.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    sys_spawn(StateMachine)</span><br></pre></td></tr></table></figure><blockquote><p>系统调用</p></blockquote><ul><li>read(): 返回随机的 0 或 1</li><li>write(s): 向 buffer 输出字符串 <code>s</code></li><li>spawn(f): 创建一个可运行的状态机 <code>f</code></li></ul><blockquote><p>操作系统中的对象</p></blockquote><ul><li>状态机 (进程)<ul><li>Python 代码</li><li>初始时，仅有一个状态机 (main)</li><li>允许执行计算或 read, write, spawn 系统调用</li></ul></li><li>一个进程间共享的 buffer (“设备”)</li></ul><blockquote><p>因为 spawn 的存在，操作系统中有多个状态机 (进程)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以拿到一个python模拟的状态机</span></span><br><span class="line">wget -r -np -nH --cut-dirs=2 -R <span class="string">&quot;index.html*&quot;</span> <span class="string">&quot;https://jyywiki.cn/os-demos/introduction/os-model/&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#链接中的proc.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Process</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        sys_write(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    sys_spawn(Process, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    sys_spawn(Process, <span class="string">&#x27;B&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>操作系统会 “雨露均沾” 地运行它们</li><li>但 buffer 是所有状态机共享的<ul><li>于是有了并发……</li><li>操作系统是最早的实用并发程序</li></ul></li></ul><h2 id="3-数学视角的操作系统">3 数学视角的操作系统</h2><blockquote><p>状态</p></blockquote><ul><li>多个 “应用程序” 状态机<ul><li>当然，可以是模型</li></ul></li></ul><blockquote><p>初始状态</p></blockquote><ul><li>仅有一个 “main” 状态机<ul><li>这个状态机处于初始状态</li></ul></li></ul><blockquote><p>迁移</p></blockquote><ul><li>选择一个状态机执行一步<ul><li>就像我们在操作系统模型上看到的那样</li></ul></li></ul><h3 id="3-1-计算机系统中的不确定性">3.1 计算机系统中的不确定性</h3><blockquote><p>ps: 算法定义：一个有穷的指令集，这些指令为解决某一特定任务规定了一个运算序列 （就是一个描述集，就是一个指令集，就是一个序列集）</p></blockquote><blockquote><p>调度：状态机的选择不确定（并发：反人类直觉的一个过程）</p></blockquote><ul><li><code>current = random.choice(self.procs)</code></li><li>操作系统每次可以随机选择一个状态机执行一步</li></ul><blockquote><p>I/O：系统外的输入不确定</p></blockquote><ul><li>read 返回的结果也有两种可能性</li><li><code>t = sys_read()</code> 后，可能 t=0 或 t=1</li></ul><blockquote><p>推论：我们得到了状态图</p></blockquote><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑢</mi><mo>→</mo><mi>𝑣</mi><mo>⇔</mo><mi>𝑢</mi></mrow><annotation encoding="application/x-tex">𝑢→𝑣⇔𝑢</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> 可以通过一步迁移到达 𝑣</li><li>当然，我们只关心<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">s_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>可达的状态</li></ul><blockquote><p>Breadth-first search（广度优先算法）可以构建 “状态图”</p></blockquote><p><img src="https://cdn-img-el3.pages.dev/os/maze.webp" alt="maze.webp"></p><h3 id="3-2-蛮力法-Brute-force">3.2 蛮力法(Brute-force)</h3><blockquote><p>想要证明程序的性质？</p></blockquote><ul><li>只要稍微 “修改” 一下模拟器的实现就行了</li></ul><blockquote><p>构建状态图，检查程序正确性</p></blockquote><ul><li>read()：创建两个状态，分别是 𝑟=0和 𝑟=1</li><li>调度：为每个进程 𝑝 创建一个状态，对应选择 𝑝 执行</li><li>程序正确：不存在从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">s_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>可达的 “坏状态”<ul><li>例如：最终 buffer 中 A 和 B 的数量相同</li><li>“模型检查器”；Turing Award Lecture</li></ul></li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c4-3.2-1.webp" alt="c4-3.2-1.webp"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下面是我们绘制一个 “Hello World” 状态空间的例子。Hello 会调用一个有趣的系统调用 fork，它的行为是复制状态机的当前状态：</span></span><br><span class="line">wget -r -np -nH --cut-dirs=2 -R &quot;index.html*&quot; &quot;https://jyywiki.cn/os-demos/mosaic/mosaic/&quot;</span><br></pre></td></tr></table></figure><p><em>程序就是状态机；状态机可以用程序表示。因此：</em></p><ul><li>我们可以用更 “简单” 的方式 (例如 Python) 描述状态机、建模操作系统上的应用，并且实现操作系统的可执行模型。</li><li>一旦把操作系统、应用程序当做 “数学对象” 处理，那么我们图论、数理逻辑中的工具就能被应用于处理程序——例如，可以用图遍历 “暴力枚举” 的方法证明程序的正确性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-绪论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.应用视角的操作系统</title>
      <link href="/2024/05/25/OS/class2/"/>
      <url>/2024/05/25/OS/class2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-操作系统上的最小应用程序">1. 操作系统上的最小应用程序</h2><h3 id="要想理解-“操作系统”，就要理解什么是-“程序”">要想理解 “操作系统”，就要理解什么是 “程序”</h3><ul><li><strong>一个Hello World示例</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>实际上，这个Hello World并不小</strong></p><ul><li><p>当我们使用objdump工具查看这个Hello World后可以发现：</p><ul><li><code>--verbose</code>可以查看所有编译选项 (真不少)<ul><li>printf 变成了 puts@plt</li></ul></li></ul></li><li><p><code>-Wl,--verbose</code>可以查看所有链接选项 (真不少)</p><ul><li>原来链接了那么多东西</li><li>还解释了 end 符号的由来</li></ul></li><li><p><code>-static</code> 会链接 libc (大量的代码)</p></li></ul></li><li><p><strong>Hello World的最小实现</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line"></span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">  movq $SYS_write, %rax   # write(</span><br><span class="line">  movq $1,         %rdi   #   fd=1,</span><br><span class="line">  movq $st,        %rsi   #   buf=st,</span><br><span class="line">  movq $(ed - st), %rdx   #   count=ed-st</span><br><span class="line">  syscall                 # );</span><br><span class="line"></span><br><span class="line">  movq $SYS_exit,  %rax   # exit(</span><br><span class="line">  movq $1,         %rdi   #   status=1</span><br><span class="line">  syscall                 # );</span><br><span class="line"></span><br><span class="line">st:</span><br><span class="line">  .ascii &quot;\033[01;31mHello, OS World\033[0m\n&quot;</span><br><span class="line">ed:</span><br></pre></td></tr></table></figure><p>下面我们在shell中编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc minimal.S -c &amp;&amp; ld minimal.o</span><br><span class="line">./a.out</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Hello, OS World</span></span><br></pre></td></tr></table></figure><p>这就是一个minimal. S</p><ul><li><strong>什么是程序：</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CPUState</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> regs[<span class="number">32</span>], csrs[CSR_COUNT];</span><br><span class="line">    <span class="type">uint8_t</span> *mem;</span><br><span class="line">    <span class="type">uint32_t</span> mem_offset, mem_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>处理器：无情的、执行指令的状态机</strong><ul><li>从M[PC] 取出一条指令</li><li>执行它</li><li>循环往复</li></ul></li></ul><h3 id="解决程序异常退出">解决程序异常退出</h3><ul><li><p><strong>程序自己是不能 “停下来” 的</strong></p><ul><li>指令集里没有一条关闭计算机的指令，那么操作系统是如何在关闭所有软件后，切断计算机的电源的？</li></ul></li><li><p><strong>只能借助操作系统</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $SYS_exit,  %rax   # exit(</span><br><span class="line">movq $1,         %rdi   #   status=1</span><br><span class="line">syscall                 # );</span><br></pre></td></tr></table></figure><ul><li>把 “系统调用” 的参数放到寄存器中</li><li>执行 syscall，操作系统接管程序<br>操作系统可以任意改变程序状态 (甚至终止程序)</li></ul><h3 id="所有二进制程序-状态机">所有二进制程序 = 状态机</h3><ul><li><strong>状态</strong><ul><li>gdb 内可见的内存和寄存器</li></ul></li><li><strong>初始状态</strong><ul><li>由 ABI 规定 (例如有一个合法的 %rsp)</li></ul></li><li><strong>状态迁移</strong><ul><li>执行一条指令<ul><li>我们花了一整个《计算机系统基础》解释这件事</li><li>gdb 可以单步观察状态机的执行</li></ul></li><li><strong>syscall</strong> 指令: 将状态机 “完全交给” 操作系统</li></ul></li></ul><h2 id="2-操作系统上的应用程序">2. 操作系统上的应用程序</h2><ul><li><p><strong>应用程序和minimal. S 一样，都是状态机</strong></p><ul><li>任何程序 = minimal. S =  状态机<ul><li>总是从被操作系统加载开始<ul><li>通过另一个进程执行 execve 设置为初始状态</li></ul></li><li>经历状态机执行 (计算 + syscalls)<ul><li>进程管理：fork, execve, exit, …</li><li>文件/设备管理：open, close, read, write, …</li><li>存储管理：mmap, brk, …</li></ul></li><li>最终调用 _exit (exit_group) 退出</li></ul></li></ul></li><li><p><strong>可执行文件是操作系统中的对象</strong></p><ul><li>与 minimal 的二进制文件没有本质区别</li><li>我们甚至可以像文本一样直接编辑可执行文件</li></ul></li><li><p><strong>一切应用程序的实现：</strong></p><ul><li>应用程序 = 计算 + 操作系统 API<ul><li>窗口管理器<ul><li>能直接管理屏幕设备 (read/write/mmap)<ul><li>能画一个点，理论上就能画任何东西</li></ul></li><li>能够和其他进程通信 (send, recv)</li></ul></li><li>任务管理器<ul><li>能访问操作系统提供的进程对象 (M1 - pstree)</li></ul></li><li>杀毒软件<ul><li>文件静态扫描 (read)、主动防御 (ptrace)</li></ul></li></ul></li></ul></li><li><p><strong>操作系统的职责：提供令应用程序舒适的抽象 (对象 + API)</strong></p></li></ul><h2 id="3-编译器与编译优化">3. 编译器与编译优化</h2><h3 id="3-1-什么是编译器">3.1 什么是编译器</h3><ul><li>编译器的输入<ul><li>高级语言 ( C ) 代码 = 状态机</li></ul></li><li>编译器的输出<ul><li>汇编代码 (指令序列) = 状态机</li></ul></li><li>编译器 = 状态机之间的翻译器</li></ul><h3 id="3-2-为什么c被称为高级汇编语言">3.2 为什么c被称为高级汇编语言</h3><ul><li>存在 C 代码到指令集的直接对应关系<ul><li>状态机和迁移都可以 “直译”</li><li>于是计算机系统里多了一个抽象层 (“一生二、二生三、三生万物”)</li></ul></li><li>更 “高级” 的语言就很难了<ul><li>C++ virtual void foo();</li><li>Python [1, 2, 3, *rest]</li><li>Javascript await fetch(…)</li></ul></li></ul><p><em>Everything (高级语言代码、机器代码) 都是状态机；而编译器实现了两种状态机之间的翻译。无论何种状态机，在没有操作系统时，它们只能做纯粹的计算，甚至都不能把结果传递到程序之外——而程序与操作系统沟通的唯一桥梁是系统调用 (例如 x86-64 的 syscall 指令)。如此重要的桥梁，操作系统中自然也有工具：strace 可以查看程序运行过程中的系统调用序列。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-绪论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.硬件视角的操作系统</title>
      <link href="/2024/05/25/OS/class3/"/>
      <url>/2024/05/25/OS/class3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-计算机系统的状态机模型">1 计算机系统的状态机模型</h2><h3 id="1-1-一切皆为状态机">1.1 一切皆为状态机</h3><ul><li>C 代码 = 状态机<ul><li>SimpleC &amp; GDB (TUI source)</li></ul></li><li>汇编代码 = 状态机<ul><li>GDB (TUI assembly)</li></ul></li><li>处理器 = 状态机<ul><li>mini-rv32ima; ICS PA</li></ul></li><li>数字电路 = 状态机<ul><li>Logisim</li></ul></li></ul><h3 id="1-2-计算机系统的状态机模型">1.2 计算机系统的状态机模型</h3><ul><li>状态<ul><li>内存、寄存器的数值</li></ul></li><li>初始状态<ul><li>由系统设计者规定 (CPU Reset)</li></ul></li><li>状态迁移<ul><li>从 PC 取指令执行</li></ul></li></ul><p>基本准确；但我们可以做一些补充</p><h4 id="1-2-1-计算机系统：状态">1.2.1 计算机系统：状态</h4><ul><li>寄存器、内存</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CPUState</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> regs[<span class="number">32</span>], csrs[CSR_COUNT];</span><br><span class="line">    <span class="type">uint8_t</span> *mem;</span><br><span class="line">    <span class="type">uint32_t</span> mem_offset, mem_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>还有外部世界的态</li><li>设备上的寄存器 (memory-mapped I/O 可以访问)</li><li>Interrupt/Reset Line</li><li><strong>客观存在，但计算机系统不能直接访问</strong><ul><li>类比：进程只能通过 syscall 访问进程外的信息</li></ul></li></ul><h4 id="1-2-2-计算机系统：初始状态">1.2.2 计算机系统：初始状态</h4><blockquote><p>CPU Reset</p></blockquote><ul><li>Intel 的工程师已经规定好，x86 处理器复位：<ul><li><code>EIP = 0x0000fff0</code></li><li><code>CR0 = 0x60000010</code><ul><li>处理器处于 16-bit 模式</li></ul></li></ul></li><li>RISC-V：百花齐放，百家争鸣<ul><li>初始 PC 无规定；寄存器除了 x0 全部 undefined</li><li>少数 CSR 有规定 (例如 interrupt disabled)<ul><li>设计原则：省电路</li><li>软件能做的，硬件绝对不管</li></ul></li></ul></li></ul><h4 id="1-2-3-计算机系统：状态迁移">1.2.3 计算机系统：状态迁移</h4><p><strong>执行指令</strong></p><ul><li>如果有多个处理器？<ul><li>可以想象成 “每次选一个处理器执行一条指令”</li></ul></li></ul><p><strong>响应中断</strong></p><ul><li>if (intr) goto vec;</li></ul><p><strong>输入输出</strong></p><ul><li>与 “计算机系统外” 交换数据</li><li>类似于程序：不使用 syscall 就等于死循环</li></ul><h2 id="2-固件：接管计算机系统的第一个程序">2 固件：接管计算机系统的第一个程序</h2><h3 id="2-1-计算机系统-状态机">2.1 计算机系统 = 状态机</h3><p><strong>程序员如何控制计算机系统？</strong></p><ul><li>仅有 RESET 状态是不够的</li><li>答案：计算机系统会和 System Programmers 达成约定</li></ul><h3 id="2-2-Firmware">2.2 Firmware</h3><p><strong>“固件”</strong></p><ul><li>厂商 “固定” 在计算机系统里的代码<ul><li>早期：固件是 ROM</li><li>想升级？换芯片！</li></ul></li></ul><p><strong>Firmware 的功能</strong></p><ul><li>运行程序前的计算机系统配置<ul><li>CPU 电压、内存时序、接口开关……</li><li>(这些配置要生效可能需要重启计算机)</li></ul></li><li>不严格地说，<strong>加载操作系统</strong><ul><li>QEMU：可以绕过 Firmware 直接加载操作系统 (RTFM)</li></ul></li></ul><p><em>Firmware：配置计算机系统</em><br><img src="https://cdn-img-el3.pages.dev/os/bios-1.webp" alt="bios-1"></p><p><em>Firmware：加载存储设备上的引导程序</em><br><img src="https://cdn-img-el3.pages.dev/os/bios-2.webp" alt="bios-2"></p><p><strong>Firmware：就是一段代码</strong></p><ul><li>一个小 “操作系统”<ul><li>CPU Reset 后初始化硬件；对接操作系统 Boot Loader</li></ul></li><li>Legacy BIOS (Basic I/O System)<ul><li>IBM PC 所有设备/BIOS 中断是有 specification 的<ul><li>16-bit DOS 时代 BIOS 常驻内存，提供 I/O 等功能</li></ul></li><li>成就了百花齐放的 “兼容机” 时代<ul><li>AMI 和 Phoenix BIOS, 等都活到了今天！</li></ul></li></ul></li><li>UEFI (Unified Extensible Firmware Interface)<ul><li>提供更丰富的支持 (例如设备驱动程序)：指纹锁、山寨网卡上的 PXE 网络启动、USB 蓝牙转接器连接的蓝牙键盘……</li></ul></li></ul><p><em>计算机系统是严格的数学对象：没有魔法；计算机系统的一切行为都是可观测、可理解的。</em></p><ul><li><em>处理器是无情的执行指令的机器。</em></li><li><em>处理器会规定好 Reset 后的行为。</em></li><li><em>Reset 后 Firmware 开始运行，再加载操作系统。</em></li><li><em>厂商逐渐形成了达成共识的 Firmware Specification (IBM PC “兼容机”、UEFI、……)。</em></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-绪论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. 操作系统概述</title>
      <link href="/2024/05/24/OS/class1/"/>
      <url>/2024/05/24/OS/class1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>课程来源:b站-绿导师原谅你了<a href="https://space.bilibili.com/202224425/channel/collectiondetail?sid=2237004&amp;spm_id_from=333.788.0.0">“操作系统：设计与实现”(蒋炎岩)</a></p></blockquote><h2 id="教材"><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">教材</a></h2><h2 id="1-为什么要学操作系统">1. 为什么要学操作系统</h2><h3 id="1-1-为什么要学xxx">1.1 为什么要学xxx</h3><ul><li>理解这门学科为了解决什么样的问题</li><li>重走一遍前人的发现历程</li><li>最终为了做到应用、创新、革命</li><li>了解到这门学科能做什么，不能做什么，知道这门技术的边界在哪里</li></ul><h2 id="2-什么是操作系统">2. 什么是操作系统</h2><blockquote><p>Operating System: A body of software, in fact, that is responsible for making it easy to run programs (even allowing you to seemingly run many at the same time), allowing programs to share memory, enabling programs to interact with devices, and other fun stuff like that. (OSTEP)</p></blockquote><h3 id="2-1-什么是操作系统">2.1 什么是操作系统</h3><p>简单的说，操作系统就是管理软/硬件资源、为程序提供服务的程序。</p><p><img src="https://cdn-img-el3.pages.dev/os/os-1-1.webp" alt="os-1-1"></p><ul><li>操作系统如何从一开始变成现在这样的？</li><li>三个重要的线索<br>硬件 (计算机)、软件 (程序)、操作系统 (管理硬件和软件的软件)</li></ul><h3 id="2-2前导知识">2.2前导知识</h3><ul><li>高级语言代码 → 指令序列 → 二进制文件 → 处理器执行<ul><li>前导课程目标：能将需求实现；掌握工具使用；阅读汇编指令</li></ul></li></ul><h3 id="3-3-理解操作系统">3.3 理解操作系统</h3><ul><li>操作系统他是在计算机硬件软件发展历史之间出现的一个产物。</li></ul><blockquote><h3 id="1940s">1940s</h3></blockquote><ul><li>在没有操作系统、甚至连编程语言都没有的时候，人们还在画流程图、写机制代码、戳纸袋，这个阶段，能把程序跑起来就很了不起了。</li></ul><blockquote><h3 id="1950s-1960s">1950s-1960s</h3></blockquote><ul><li><p>这个阶段，硬件改进了，逻辑门-存储-I/O 的基本格局没有变。</p><ul><li>晶体管、磁芯内存、丰富的 I/O 设备</li><li>I/O 设备的速度严重低于处理器的速度，中断机制出现 (1953)</li></ul></li><li><p>更复杂的通用的数值计算</p><ul><li>高级语言和 API 诞生 (Fortran, 1957)：一行代码，一张卡片80 行的规范沿用至今</li></ul></li></ul><p><img src="https://cdn-img-el3.pages.dev/os/os-1-2.webp" alt="os-1-2"></p><ul><li><p>Fortran 已经 “足够好用”</p><ul><li>迎来了自然科学、工程机械、军事……对计算机的需求暴涨</li></ul></li><li><p>库函数 + 管理程序排队运行的调度代码</p><ul><li>写程序 (戳纸带)、跑程序都是非常费事的</li><li>计算机非常贵<ul><li>$50,000−$1,000,000</li><li>通常一个学校只有一台</li></ul></li></ul></li><li><p>算力成为服务，操作系统概念形成</p><ul><li>多用户轮流共享计算机，operator 负责操作程序切换</li><li>Operating systems (操作系统/作業系統)<ul><li>(今天算力又成为服务了-<em>人工智能</em>)</li></ul></li></ul></li><li><p>CTSS (Compatible Time-Sharing System)</p></li></ul><blockquote><h3 id="1960s-1970s">1960s-1970s</h3></blockquote><ul><li><p>集成电路、总线出现</p></li><li><p>更多的高级语言和编译器出现</p></li><li><p>个人电脑登上历史舞台</p></li><li><p>能载入多个程序到内存且调度它们的管理程序</p><ul><li>为防止程序之间形成干扰，操作系统自然地将共享资源 (如设备) 以 API 形式管理起来<ul><li>有了进程 (process) 的概念</li><li>进程在执行 I/O 时，可以将 CPU 让给另一个进程<ul><li>在多个地址空间隔离的程序之间切换</li><li>虚拟存储使一个程序出 bug 不会 crash 整个系统</li></ul></li></ul></li></ul></li><li><p>操作系统中自然地增加进程管理 API</p></li></ul><blockquote><h3 id="1970s">1970s+</h3></blockquote><ul><li>分时系统走向成熟，UNIX 诞生并走向完善，奠定了现代操作系统的形态</li></ul><h2 id="3-如何学操作系统">3. 如何学操作系统</h2><blockquote><p><strong>试着去成为一个有 CS 梦想的人</strong></p></blockquote><p>是一个合格的操作系统用户</p><ul><li>会 STFW/RTFM/ATFAI 自己动手解决问题，进而，不怕使用任何命令行工具vim, tmux, grep, gcc, binutils, …</li><li>不怕 (或者爱上) 写代码<ul><li>能管理一定规模 (数千行) 的代码</li><li>在出 bug 时默念 “机器永远是对的、我肯定能调出来的”<ul><li>然后开始用正确的工具/方法调试</li></ul></li></ul></li></ul><p><em>操作系统是软件和硬件之间的桥梁；因此我们 “找到” 一些合适的软件、一些相对简单的硬件，理解操作系统就会变得容易。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-绪论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2024/05/23/2024-5/2024-5-23/"/>
      <url>/2024/05/23/2024-5/2024-5-23/</url>
      
        <content type="html"><![CDATA[<blockquote><h2 id="测试">测试</h2></blockquote><p>​这篇测试文章将会是我的第一篇文章，立下flag，今后我将会记录我的一些：</p><ul><li>学习笔记</li><li>遇到并解决的问题</li><li>随笔</li></ul>]]></content>
      
      
      <categories>
          
          <category> 第一篇文档分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第一篇文档标签 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
