<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>6. 并发控制：互斥 (1)</title>
      <link href="/2024/05/29/OS/class6/"/>
      <url>/2024/05/29/OS/class6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-阻止并发-并行-的发生">1 阻止并发 (并行) 的发生</h2><h3 id="1-1-并发困难的原因">1.1 并发困难的原因</h3><blockquote><p>人类是 “sequential creatures[有序生物]”</p></blockquote><ul><li>人类具备 𝐴→…→𝐵 简化为 𝐴→𝐵 的直觉本能<ul><li>并且据此开发了编译器 (处理器也是编译器)</li><li><strong>多处理器和并发执行推翻了顺序执行的基本假设！</strong></li></ul></li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c5-4.2-2.webp" alt="c5-4.2-2.webp"></p><h3 id="1-2-互斥">1.2 互斥</h3><blockquote><p>人类是 (绝不轻言放弃的) sequential creatures</p></blockquote><ul><li>互斥 (互相排斥)：阻止并发，问题不就解决了？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ATOMIC &#123; sum++; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">T_alipay_withdraw</span><span class="params">(<span class="type">int</span> amt)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    ATOMIC &#123;</span><br><span class="line">        <span class="comment">// No concurrency with</span></span><br><span class="line">        <span class="comment">// other critical sections</span></span><br><span class="line">        <span class="keyword">if</span> (balance &gt;= amt) &#123;</span><br><span class="line">            balance -= amt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-互斥：阻止并发、独占访问">1.3 互斥：阻止并发、独占访问</h3><blockquote><p>既然用互斥 “阻止并发”，那我们为什么还要做并行？</p></blockquote><blockquote><p>状态机视角的互斥</p></blockquote><ul><li>临界区同时发生时，依然满足执行的原子性</li><li>可以把多次状态迁移理解为 “一次大状态迁移”</li></ul><blockquote><p>实现任何共享资源 (内存) 的独占访问</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ATOMIC &#123;</span><br><span class="line">    <span class="comment">// 状态迁移 (语义）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock();</span><br><span class="line"><span class="comment">// 任意代码</span></span><br><span class="line">unlock();</span><br></pre></td></tr></table></figure><blockquote><p>既然是顺序执行，那我们还要并发做什么？</p></blockquote><ul><li>如果你有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">1/k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>的代码是不能并发执行的，那么：</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>T</mi><mi mathvariant="normal">∞</mi></msub><mo>&gt;</mo><mfrac><msub><mi>T</mi><mn>1</mn></msub><mi>k</mi></mfrac></mrow><annotation encoding="application/x-tex">T_∞&gt;\frac{T_1}{k} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><ul><li>并行计算总是能实现的：</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>T</mi><mi>p</mi></msub><mo>&lt;</mo><msub><mi>T</mi><mi mathvariant="normal">∞</mi></msub><mo>+</mo><mfrac><msub><mi>T</mi><mn>1</mn></msub><mi>k</mi></mfrac></mrow><annotation encoding="application/x-tex">T_p &lt; T_∞ + \frac{T_1}{k} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h3 id="1-4-计算是可以并行的">1.4 计算是可以并行的</h3><blockquote><p>经典物理：局部性原理</p></blockquote><ul><li>物体对相邻物体的影响需要时间<ul><li>(即便严格来说不成立，依然是一个很好的近似)</li></ul></li><li>推论：任何物理世界模拟皆可以大规模并行</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>𝑇</mi><mi mathvariant="normal">∞</mi></msub><mo>≪</mo><msub><mi>𝑇</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">𝑇_∞≪𝑇_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≪</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p>Embarrassingly Parallel 的例子</p></blockquote><ul><li>图书馆 v.s. 分布式数据存储</li><li>大脑 v.s. 深度神经网络</li><li>……</li></ul><h3 id="1-5-实现互斥">1.5 实现互斥</h3><blockquote><p>能否使当前程序状态机独占计算机系统？</p></blockquote><ul><li>类比：关掉电脑手机，专注一件事</li><li>单处理器系统中 “其他任何事”：仅有中断</li></ul><blockquote><p>一条指令就可以实现原子性</p></blockquote><ul><li>x86: <code>cli</code> 清除 eflags 中的 IF bit</li><li>RISC-V: 清除 mstatus 的 MIE bit</li><li>AArch64: msr daifset, #3<ul><li>程序死循环 = 计算机系统卡死</li></ul></li></ul><blockquote><p>道高一尺、魔高一丈</p></blockquote><ul><li>处理器有 NMI (Non-Maskable Interrupts)</li><li>可以利用 NMI 实现错误监控<ul><li>设置硬件定时触发</li><li>操作系统定时复位定时器</li><li>触发 timeout，执行 NMI 处理程序<ul><li>例如，重启计算机</li></ul></li></ul></li></ul><h3 id="1-6-关中断不是万能的">1.6 关中断不是万能的</h3><blockquote><p>操作系统可以，但普通程序不行</p></blockquote><ul><li>中断保证了死循环不能把计算机 “卡死”</li><li>操作系统不允许普通程序关中断<ul><li>但如果是操作系统代码，完全可以短暂关闭中断</li></ul></li></ul><blockquote><p>单处理器系统可以，多处理器系统不行</p></blockquote><ul><li>每个处理器有独立的寄存器组</li><li>中断是每个处理器内部状态</li></ul><h2 id="2-使用-load-store-实现互斥">2 使用 load/store 实现互斥</h2><blockquote><p><a href="https://series1.github.io/blog/dekkers-algorithm/">绕口令</a>：A process 𝑃 can enter the critical section if the other does not want to enter, otherwise it may enter only if it is its turn.</p></blockquote><blockquote><p>实现假设</p></blockquote><ul><li>任何时候可以执行一条 load/store 指令</li><li>读写本身是原子的</li></ul><blockquote><p>并发的危险</p></blockquote><ul><li>你很难从字面上判断它到底对不对</li></ul><h3 id="2-1-问题重述">2.1 问题重述</h3><p>举例：上厕所</p><blockquote><p>若希望进入厕所，按顺序执行以下操作：</p></blockquote><ol><li>举起自己的旗子 (store)</li><li>把写有对方名字的字条贴在厕所门上 (store; 覆盖)</li></ol><blockquote><p>然后进入持续的观察模式：</p></blockquote><ol><li>观察对方是否举旗 (load)</li><li>观察厕所门上的名字 (load)<ul><li>对方不举旗或名字是自己，进入厕所，否则继续观察</li></ul></li></ol><blockquote><p>出厕所后，放下自己的旗子</p></blockquote><ul><li>不用管门上的字条</li></ul><blockquote><p>进入临界区的情况</p></blockquote><ul><li>如果只有一个人举旗，他就可以直接进入</li><li>如果两个人同时举旗，由厕所门上的标签决定谁进<ul><li>手快 🈶️ (被另一个人的标签覆盖)、手慢 🈚</li></ul></li></ul><blockquote><p>一些具体的细节情况</p></blockquote><ul><li>A 看到 B 没有举旗<ul><li>B 一定不在临界区</li><li>B 可能想进但还没来得及把 “B 正在使用” 贴在门上</li></ul></li><li>A 看到 B 举旗子<ul><li>A 一定已经把旗子举起来了 (!@^#&amp;!%^(&amp;^!@%#</li></ul></li></ul><blockquote><p>自动遍历状态空间的乐趣：快速回答更多问题</p></blockquote><ul><li>如果结束后把门上的字条撕掉，算法还正确吗？<ul><li>在放下旗子之前撕 v.s. 放下旗子之后撕</li></ul></li><li>先贴标签再举旗，算法还正确吗？</li><li>观察模式两个查看操作的顺序影响正确性吗？<ul><li>看对方的旗有没有举起来</li><li>看门上的贴纸是不是自己</li></ul></li><li>是否存在 “两个人谁都无法进入临界区” (liveness)、“对某一方不公平” (fairness) 等行为？<ul><li>都转换成图 (状态空间) 上的遍历问题了！</li></ul></li></ul><h3 id="2-2-Model-Checker和自动化">2.2 Model Checker和自动化</h3><blockquote><p>电脑为什么叫 “电脑”</p></blockquote><pre><code>- 因为它能替代部分人类的思维活动</code></pre><blockquote><p>回忆：每个班上都有一个笔记和草稿纸都工工整整的 Ta</p></blockquote><ul><li>Ta：认认真真完成老师作业<ul><li>工整的笔记可以启发思维，但花费了宝贵的人工</li></ul></li><li>我：烦死了！劳资不干了！玩去了<ul><li>战略：提出好的问题、适当地分解问题</li><li>战术：尽可能使用先进工具替代机械思维活动<ul><li>对于 Peterson 算法：都是一个晚自习时间，model checker 可以回答更多更深刻的问题</li></ul></li></ul></li></ul><blockquote><p>关于学习 (思考)：Tree of Thoughts</p></blockquote><ul><li>有一些别名：“批判性思维”、“第一性原理”……</li><li>有一些实现：AlphaGo……</li></ul><blockquote><p>那个好好学习的、总被老师表扬的 Ta？</p></blockquote><ul><li>听话的学生 → Chain of Thoughts (顺从)</li><li>不听话的学生 → Tree of Thoughts (质疑)</li></ul><h3 id="2-3-实现-Peterson-算法">2.3 实现 Peterson 算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;    <span class="comment">// 举起自己的旗子</span></span><br><span class="line">turn = B; <span class="comment">// 贴上对方的名字</span></span><br><span class="line"><span class="keyword">do</span> &#123;      <span class="comment">// 进入持续观察模式</span></span><br><span class="line">&#125; <span class="keyword">while</span> (b &amp;&amp; turn == B); <span class="comment">// 对方举旗且门上是对方的的名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;    <span class="comment">// 放下自己的旗子</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">1</span>;</span><br><span class="line">turn = A;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">&#125; <span class="keyword">while</span> (a &amp;&amp; turn == A);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><blockquote><p>模型的假设：Atomic load &amp; store</p></blockquote><ul><li>但这个假设在现代多处理器上并不成立</li><li>所以实际上按照模型直接写 Peterson 算法应该是错的？<ul><li>不妨实现了试一试？</li></ul></li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c5-4.2-2.webp" alt="c5-4.2-2.webp"></p><h3 id="2-4-现实中的-Peterson-算法">2.4 现实中的 Peterson 算法</h3><blockquote><p>“实现正确的 Peterson 算法” 是合理需求</p></blockquote><ul><li>编译器应该提供了机制实现</li></ul><blockquote><p>内存屏障 (Memory Barrier)</p></blockquote><ul><li><code>__sync_synchronize()</code> = Compiler Barrier +<ul><li>x86: <code>mfence</code></li><li>ARM: <code>dmb ish</code></li><li>RISC-V: <code>fence rw, rw</code></li></ul></li></ul><blockquote><p>编译器到底做了什么？</p></blockquote><ul><li><a href="https://godbolt.org/">godbolt.org</a>，不用装那些 cross compiler 了<ul><li>你甚至可以看到 compiler barrier 是如何在优化中传递的</li></ul></li></ul><h2 id="3-在多处理器上实现互斥">3 在多处理器上实现互斥</h2><p>继续回到厕所问题</p><blockquote><p>为什么不能就 “等在门口” 呢？</p></blockquote><ul><li>上一个人出来了，我再进去呗！</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> status = ✅;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">retry:</span><br><span class="line">    <span class="keyword">if</span> (status != ✅) &#123;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">    status = ❌;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    status = ✅;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>没有跨语句 (指令) 的原子性？</p></blockquote><ul><li>Peterson 算法真是大费周章</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">retry:</span><br><span class="line">    <span class="keyword">if</span> (status != ✅) &#123;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">    status = ❌;</span><br></pre></td></tr></table></figure><blockquote><p>软件不够，硬件来凑</p></blockquote><ul><li>原子指令：一小段时间的 “Stop the World” 执行</li><li>不可打断的 load + 计算 + store<ul><li>x86: Bus Lock; RISC-V: LR/SC (来自 MIPS) + atomic</li></ul></li></ul><p><code>asm volatile(&quot;lock incq %0&quot; : &quot;+m&quot;(sum));  </code></p><p><img src="https://cdn-img-el3.pages.dev/os/c6-3-1.webp" alt="c6-3-1.webp"></p><h3 id="3-1-第一个自旋锁">3.1 第一个自旋锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> status = ✅;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">retry:</span><br><span class="line">    <span class="type">int</span> got = <span class="type">atomic_xchg</span>(&amp;status, ❌);</span><br><span class="line">    <span class="keyword">if</span> (got != ✅) &#123;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">atomic_xchg</span>(&amp;status, ✅);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有 “带条件写入” 的版本：节约写入内存带宽</p></blockquote><ul><li>Test-And-Set (TAS), Compare-And-Swap (CAS), COMPXCHG (Compare-And-Exchange)</li></ul><p><em>并发编程 “很难”：想要完全理解并发程序的行为，是非常困难的——我们甚至可以利用一个 “万能” 的调度器去帮助我们求解 NP-完全问题。因此，人类应对这种复杂性的方法就是退回到不并发。通过互斥实现 stop/resume the world，我们就可以使并发程序的执行变得更容易理解——而只要程序中 “能并行” 的部分足够多，串行化一小部分也并不会对性能带来致命的影响。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于对抽象的理解</title>
      <link href="/2024/05/29/programming/abstract/"/>
      <url>/2024/05/29/programming/abstract/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是抽象">1 什么是抽象</h2><h3 id="1-1-关于多态">1.1 关于多态</h3><p><em>在面向对象编程中，多态是指一类事物有多种形态。比如A类，A-1和A-2都属于动物类，它们都有A类中公共的方法</em></p><blockquote><p>由于多态的存在，每个子类都可以覆写父类的方法，例如下面的代码中子类1和2都覆写了父类中的某个方法：</p></blockquote><p>在这里，假如我们要设计一款游戏名叫 <strong>Apax</strong> 的枪械游戏。在这款游戏中，我们的武器就是枪械，所以我们来为我们的游戏设计一个 <code>Weapon</code> 类，它是一个抽象类，代表所有枪械的父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类-武器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">    <span class="comment">// 具有的方法</span></span><br><span class="line">    <span class="comment">// 子弹类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">WeaponAmmo</span><span class="params">()</span> &#123; … &#125;</span><br><span class="line">    <span class="comment">// 击中要害转化倍率</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">WeaponForce</span><span class="params">()</span> &#123; … &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类1-轻型弹药武器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LightAmmo</span> <span class="keyword">extends</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">WeaponAmmo</span><span class="params">()</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类2-霰弹类武器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShotgunAmmo</span> <span class="keyword">extends</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">WeaponAmmo</span><span class="params">()</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-关于抽象">1.2 关于抽象</h3><p>可以看到， <code>WeaponAmmo</code> 方法在子类中是覆写的父类的方法，并且父类也确实具有 <code>WeaponAmmo</code> 方法的实现。<strong>但是</strong>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">    <span class="comment">// 此处并未赋予WeaponAmmo方法任何实现，仅仅只是定义了WeaponAmmo方法的签名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">WeaponAmmo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把一个方法声明为 <code>abstract</code> ，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以， <code>Weapon</code> 类也无法被实例化。编译器会告诉我们，无法编译 <code>Weapon</code> 类，因为它包含抽象方法。必须把 <code>Weapon</code> 类本身也声明为 <code>abstract</code> ，才能正确编译它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">WeaponAmmo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个 <code>class</code> 定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用 <code>abstract</code> 修饰。</p><p>因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。</p><p>使用 <code>abstract</code> 修饰的类就是抽象类。我们无法实例化一个抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Weapon</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weapon</span>(); <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><blockquote><p>正确的方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义了一个使用轻型弹药的武器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weapon</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weapon</span>();</span><br><span class="line">        w.WeaponAmmo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">WeaponAmmo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LightAmmo</span> <span class="keyword">extends</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">WeaponAmmo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用轻型弹药&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们定义了抽象类 <code>Weapon</code> ，以及具体的 <code>LightAmmo</code> 、 <code>ShotgunAmmo</code> 子类的时候，我们可以通过抽象类 <code>Weapon</code> 类型去引用具体的子类的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Weapon</span> <span class="variable">R301</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LightAmmo</span>();</span><br><span class="line"><span class="type">Weapon</span> <span class="variable">Peacekeeper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShotgunAmmo</span>();</span><br></pre></td></tr></table></figure><blockquote><p>这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</p></blockquote><p>面向抽象编程的本质就是：</p><ul><li><p>上层代码只定义规范；</p></li><li><p>不需要子类就可以实现业务逻辑；</p></li><li><p>具体的业务逻辑由不同的子类实现，调用者并不关心。</p></li></ul><h2 id="2-进一步理解抽象">2 进一步理解抽象</h2><p><strong>…</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抽象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5. 多处理器编程：从入门到放弃</title>
      <link href="/2024/05/28/OS/class5/"/>
      <url>/2024/05/28/OS/class5/</url>
      
        <content type="html"><![CDATA[<h2 id="1-多处理器编程入门">1 多处理器编程入门</h2><h3 id="1-1-多线程编程模型">1.1 多线程编程模型</h3><blockquote><p>多个共享内存的状态机</p></blockquote><ul><li>C 语言状态机的多个线程<ul><li>共享所有全局变量</li><li>独立的栈帧列表</li></ul></li><li>汇编语言状态机的多个线程<ul><li>共享一个地址空间</li><li>独立的寄存器 (SP 指向不同内存位置)</li></ul></li></ul><blockquote><p>状态迁移</p></blockquote><ul><li>选择任意一个线程执行一步</li></ul><blockquote><p>Mosaic 状态机</p></blockquote><ul><li>“heap” 是共享内存</li><li>sys_sched 主动随机切换线程<ul><li>单处理器系统：中断会引起切换<ul><li>(这就是为什么死循环不能把机器卡死)</li></ul></li><li>多处理器系统：真正同时执行<ul><li>相当于无时不刻在切换</li></ul></li></ul></li></ul><blockquote><p>模拟多线程程序的行为</p></blockquote><ul><li>思考题：我们可以借助共享内存做什么？</li></ul><h3 id="1-2-多处理器编程：入门">1.2 多处理器编程：入门</h3><blockquote><p>简化的线程 API (使用thread.h库就可以直接create)</p></blockquote><ul><li><code>spawn(fn)</code><ul><li>创建一个入口函数是 <code>fn</code> 的线程，并立即开始执行<ul><li><code>void fn(int tid) &#123; ... &#125;</code></li><li>参数 <code>tid</code> 从 1 开始编号</li></ul></li><li>行为：<code>sys_spawn(fn, tid)</code></li></ul></li><li><code>join()</code><ul><li>等待所有运行线程的返回 (也可以不调用)</li><li>行为：<code>while (done != T) sys_sched()</code></li></ul></li></ul><blockquote><p>一个API搞定</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">T_a</span><span class="params">()</span> &#123; <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;a&quot;</span>); &#125; &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">T_b</span><span class="params">()</span> &#123; <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;b&quot;</span>); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    create(T_a);</span><br><span class="line">    create(T_b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实现多处理器的利用</p></blockquote><pre><code>- 操作系统会自动把线程放置在不同的处理器上- CPU 使用率超过了 100%</code></pre><h3 id="1-3-Q-A">1.3 Q&amp;A</h3><blockquote><p><code>T_a</code> 和 <code>T_b</code> 真的共享内存吗？</p></blockquote><ul><li>如何证明/否证这件事？</li></ul><blockquote><p>如何证明线程具有独立堆栈 (以及确定堆栈的范围)？</p></blockquote><ul><li>输出混乱，应该如何处理？</li></ul><blockquote><p>更多的 “好问题” 和解决</p></blockquote><ul><li><p>创建线程使用的是哪个系统调用？<br><code>man pthreads</code></p></li><li><p>能不能用 gdb 调试？</p><ul><li>基本原则：有需求，就能做到 (RTFM)</li></ul></li></ul><h2 id="2-放弃-1-：状态迁移原子性的假设">2 放弃 (1)：状态迁移原子性的假设</h2><p>当我们谈 “放弃” 时，放弃的并非并发编程，而是要舍弃一些我们之前对单线程顺序程序的理解。这些理解在我们长期的编程中，多多少少成为了肌肉记忆，这也是并发编程打破这些理解带来麻烦的原因。我们努力试图理解并发程序和顺序程序的本质区别，从而更好地应对并发带来的编程挑战。</p><h3 id="2-1-反思：状态机模型的隐含假设">2.1 反思：状态机模型的隐含假设</h3><blockquote><p>“世界上只有一个状态机”</p></blockquote><ul><li>没有其他任何人能 “干涉” 程序的状态</li><li>课堂上常用的简化方法<ul><li>假设一段程序执行没有系统调用</li><li>可以直接简化为一个原子的状态迁移 “计算”</li></ul></li></ul><h3 id="2-2-放弃-1-反思：状态机模型的隐含假设">2.2 放弃 (1)反思：状态机模型的隐含假设</h3><blockquote><p>共享内存推翻了 “原子性” 假设</p></blockquote><ul><li>任何时候，load 读到的值都可能是别的线程写入的</li><li>我们习以为常的简化会漏掉并发程序可能的行为<ul><li>如果你觉得你可能会犯错误，那别人也一定会的</li></ul></li></ul><blockquote><p>一些我们见到过的例子</p></blockquote><ul><li>线程的交错执行 <code>ABABAABB</code></li><li>消失的 1: <code>A2B2A3A5B5B6</code></li><li>潘多拉的魔盒已经打开……</li></ul><h3 id="2-3-并发Bugs">2.3 并发Bugs</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> balance = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">T_alipay_withdraw</span><span class="params">(<span class="type">int</span> amt)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (balance &gt;= amt) &#123;</span><br><span class="line">        balance -= amt;</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> FAIL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>两个线程并发支付 ¥100 会发生什么 (代码： <code>alipay.c</code> )</p></blockquote><p>当把usleep(1)取消注释后，程序执行将会无法合理计算，因为两个线程的执行顺序是随机的。</p><ul><li>账户里会多出用不完的钱！</li><li>历史事件：Mt. Gox Hack 损失 650, 000 BTC</li></ul><blockquote><p>计算 1+1+1+…+1 (sum.c)</p></blockquote><ul><li>共计 2n 个 1，分 2 个线程计算</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100000000</span></span><br><span class="line"><span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">T_sum</span><span class="params">()</span> &#123; <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) sum++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    create(T_sum);</span><br><span class="line">    create(T_sum);</span><br><span class="line">    join();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %ld\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>会得到怎样的结果？<br>基本上得不到同样的sum</li></ul><blockquote><p>正确实现并发 1 + 1 比想象中困难得多</p></blockquote><ul><li>1960s，大家争先在共享内存上实现原子性 (互斥)</li><li>但几乎所有的实现都是错的<ul><li>直到<a href="https://en.wikipedia.org/wiki/Dekker%27s_algorithm">Dekker’s Algorithm</a>的算法出现，还只能保证两个线程的互斥</li></ul></li></ul><blockquote><p>感到脊背发凉？</p></blockquote><ul><li>printf 还能在多线程程序里调用吗？<ul><li>当然可以，但会乱序执行</li></ul></li></ul><h3 id="2-4-失去“原子执行”的终极后果">2.4 失去“原子执行”的终极后果</h3><blockquote><p>并发执行三个 T_sum，sum 的最小值是多少？</p></blockquote><ul><li>初始时 sum = 0; 假设单行语句的执行是原子的</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">T_sum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t = load(sum);</span><br><span class="line">        t += <span class="number">1</span>;</span><br><span class="line">        store(sum, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>GPT-4: 细微改变问题会导致各种错误回答<ul><li>Claude 3 Opus 也不行，大模型没戏</li><li><a href="https://epubs.siam.org/doi/10.1137/S0097539794279614">Trace recovery is NP-Complete.</a></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sum_model</span></span><br><span class="line">mosaic -C sum.py | collect</span><br></pre></td></tr></table></figure><blockquote><p>Model Checker: sum = 2</p></blockquote><ul><li>是的，不是 1<ul><li>(因为有 <code>i</code> 的循环)</li></ul></li><li>也不是 3<ul><li>虽然 sum = 3 是很容易想到的</li></ul></li><li>无论有多少 <code>T_sum</code>，都可以 sum = 2</li></ul><blockquote><p>GPT-4 的 “直觉” 哪怕对最 “简单” 的并发程序都不起效</p></blockquote><h3 id="2-5-“数学视角”的价值">2.5 “数学视角”的价值</h3><blockquote><p>对于并发，讲概念是不够的</p></blockquote><ul><li>事实可能不是你想的那样</li></ul><blockquote><p>甚至讲代码都是不够的</p></blockquote><ul><li>代码需要非常精巧的 workload 才能跑出那个 corner case</li></ul><blockquote><p>证明才是解决问题的方法</p></blockquote><p>证明：∀ 线程调度方法，程序满足 XXX 性质。</p><ul><li>我们现在甚至还没有趁手的并发程序证明工具！</li><li>对于课堂的例子，model checker 倒也够用了</li></ul><h2 id="3-放弃-2-：程序顺序执行的假设">3 放弃 (2)：程序顺序执行的假设</h2><h3 id="3-1-状态机模型的隐含假设">3.1 状态机模型的隐含假设</h3><blockquote><p>“世界上只有一个状态机”</p></blockquote><ul><li>没有其他任何人能 “干涉” 程序的状态</li><li>课堂上常用的简化方法<ul><li>假设一段程序执行没有系统调用</li><li>可以直接简化为一个原子的状态迁移 “计算”</li></ul></li></ul><blockquote><p>编译器也做了同样的假设</p></blockquote><ul><li>编译器会试图优化状态迁移，改变执行流</li></ul><h3 id="3-2-放弃程序按顺序执行的假设">3.2 放弃程序按顺序执行的假设</h3><blockquote><p>共享内存推翻了编译器的假设</p></blockquote><ul><li>但编译器依然会按照顺序执行优化代码</li><li>否则几乎任何涉及共享内存的代码都变得 “不可优化”</li></ul><blockquote><p>程序的行为在并发编程下变得更难理解了</p></blockquote><ul><li>“顺序程序” 变得一点也不 “顺序” 了</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100000000</span></span><br><span class="line"><span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">T_sum</span><span class="params">()</span> &#123; <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) sum++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    create(T_sum);</span><br><span class="line">    create(T_sum);</span><br><span class="line">    join();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %ld\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果添加编译优化？</p></blockquote><ul><li><code>-O1</code>: 100000000</li><li><code>-O2</code>: 200000000</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!flag);</span><br></pre></td></tr></table></figure><blockquote><p>“等另一个线程举起旗子，我再继续”？</p></blockquote><ul><li>如果这是个顺序程序，编译器可以做什么优化？<ul><li>(这甚至也是一个常见的并发 bug 模式)</li><li>“Ad hoc synchronization considered harmful”</li></ul></li></ul><blockquote><p>方法 1：插入 “不可优化” 代码</p></blockquote><ul><li>asm volatile (“” ::: “memory”);<ul><li>告诉编译器其他线程可能写入内存</li></ul></li></ul><blockquote><p>方法 2：标记变量 load/store 为不可优化</p></blockquote><ul><li>使用 volatile 修饰变量可以做到</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">volatile</span> flag;</span><br><span class="line"><span class="keyword">while</span> (!flag);</span><br></pre></td></tr></table></figure><blockquote><p>以上都不是《操作系统》课推荐的方法</p></blockquote><ul><li>“一把大锁保平安” 加锁 ✔</li></ul><h2 id="4-放弃-3-：存在全局指令执行顺序的假设">4 放弃 (3)：存在全局指令执行顺序的假设</h2><h3 id="4-1-状态机模型的隐含假设">4.1 状态机模型的隐含假设</h3><blockquote><p>状态迁移</p></blockquote><ul><li>选择一个线程，执行一条指令</li><li>“顺序一致性” (sequential consistency)</li></ul><blockquote><p>单处理器多线程符合这个假设</p></blockquote><ul><li>处理器会保证指令 “看起来” 顺序完成</li><li>处理器也是编译器 (oops… 感觉不好的事情要发生了)<ul><li>预取状态机执行的若干步，然后像编译器一样优化</li><li>Load(x); Store(y)</li><li>𝑥≠𝑦 → 两条指令执行的先后顺序就无所谓</li><li>Load cache miss → store 可以直接执行</li></ul></li></ul><h3 id="4-2-放弃全局顺序存在的假设">4.2 放弃全局顺序存在的假设</h3><blockquote><p>共享内存推翻了 “统一上帝视角” 的存在性</p></blockquote><ul><li>就像相对论中，时间顺序的相对性<ul><li>𝐴 和 𝐵 没有因果关系，例子：Load(x) v.s. Store(y)</li><li>两个观测者可以分别看到 𝐴→𝐵 或 𝐵→𝐴</li><li>观测的相对性使全局世界的行为 “极难理解”</li></ul></li></ul><blockquote><p>不同处理器可能看到不同的共享内存</p></blockquote><ul><li>“一个共享内存” 只是个简化的幻觉</li><li>Reading: <a href="https://research.swtch.com/mm">Memory Models</a> by Russ Cox</li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c5-4.2-1.webp" alt="c5-4.2-1.webp"></p><p>实际上：</p><p><img src="https://cdn-img-el3.pages.dev/os/c5-4.2-2.webp" alt="c5-4.2-2.webp"></p><h3 id="4-3-“相对论效应”带来的后果">4.3 “相对论效应”带来的后果</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//men-model.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">T1</span><span class="params">()</span> &#123;</span><br><span class="line">  x = <span class="number">1</span>; <span class="type">int</span> t = y; <span class="comment">// Store(x); Load(y)</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">T2</span><span class="params">()</span> &#123;</span><br><span class="line">  y = <span class="number">1</span>; <span class="type">int</span> t = x; <span class="comment">// Store(y); Load(x)</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Model Checker: 01 10 11</p></blockquote><ul><li>实际：00 (???) 未被观测到</li></ul><blockquote><p>CPU 设计者面临了难题</p></blockquote><ul><li>更强的内存模型 = 更糟糕的性能，但更容易编程</li><li>x86：市面 “最强” 内存模型 (类比 ARM/RISC-V)</li></ul><blockquote><p>因此，在 ARM 上模拟 x86 是个世界性的难题</p></blockquote><p><em>在简化多线程的模型中，并发程序就是 “状态机的集合”，每一步选一个状态机执行一步。然而，真实的系统却因为 “编译器” 的无处不在，使共享内存并发的行为十分复杂。</em></p><p><em>不幸的是，人类本质上是物理世界 (宏观时间) 中的 “sequential creature”，因此我们在编程时，我们的直觉也只习惯于单线程的顺序/选择/循环结构，真实多处理器上的并发编程是非常具有挑战性的 “底层技术”。在后续的课程中，我们将会提出若干并发控制技术，使得我们可以在需要的时候避免并发的发生，使并发程序退回到顺序程序，从而使我们能够理解和控制并发。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4. 数学视角的操作系统</title>
      <link href="/2024/05/27/OS/class4/"/>
      <url>/2024/05/27/OS/class4/</url>
      
        <content type="html"><![CDATA[<h2 id="1-程序正确性证明">1 程序正确性证明</h2><blockquote><p>数千年来，数学的“严格性”都是由人类保证的</p></blockquote><h3 id="1-1-程序的本质">1.1 程序的本质</h3><blockquote><p>程序是一种 “数学严格” 的对象</p></blockquote><ul><li><p>Everything is a state machine</p><ul><li>程序 = 初始状态 + 迁移函数</li><li>在这个视角下，程序和数学对象已经无限接近了</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f(s) = s&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8019em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></p></li><li><p>我们经常写出 “似是而非” 的代码</p></li><li><p>类似于细节有错但可以修正的数学证明</p><ul><li><code>for (int j = 0; j &lt; n; i++)</code></li><li>(有时候也会疏忽，导致设计全错)</li></ul></li></ul><blockquote><p>为什么会有程序？</p></blockquote><ul><li>是因为我们有无情的执行指令的机器 (计算机)</li><li>只有程序才配得上它</li></ul><blockquote><p>程序天生是 “人类” 的，也是 “反人类” 的</p></blockquote><ul><li>人类的一面：程序连接了人类世界需求<ul><li>程序写的一切都能在现实生活观测到</li><li>我们并不是在实现 “uniform-random” 的 𝑓</li></ul></li><li>反人类的一面：程序会在机器上执行<ul><li>初学者对 “机器严格” 普遍不太适应</li><li>部分原因是对程序的行为没有 100% 的掌控</li><li>使用秘技：debug来观察程序的行为</li></ul></li></ul><h3 id="1-2-当我们谈论数学的时候，我们想谈论什么？">1.2 当我们谈论数学的时候，我们想谈论什么？</h3><blockquote><p>证明程序正确性！</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AlipayAccount</span>:</span><br><span class="line">    b: <span class="built_in">int</span> = <span class="number">0</span>  <span class="comment"># Balance</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">...</span>): ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">...</span>): ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transfer</span>(<span class="params">...</span>): ...</span><br></pre></td></tr></table></figure><blockquote><p>针对这段python代码，我们可以用数学的语言提出程序的规约</p></blockquote><ul><li>例如：任意时刻 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi mathvariant="normal">.</mi><mi>b</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a.b≥0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal">a</span><span class="mord">.</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></li><li>有没有可能真正 “证明” 它呢？<br>任意状态中b都大于0</li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c4-1.2-1.webp" alt="证明方式"></p><h3 id="1-3-程序正确性证明的两种方法">1.3 程序正确性证明的两种方法</h3><blockquote><p>暴力枚举-启发</p></blockquote><ul><li>写一个 driver code，运行所有可能的函数调用序列，proof assistant 帮助我们检查<ul><li>PL/SE 已经研究生成 driver code 几十年了</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>t</mi><mo stretchy="false">(</mo><mi>b</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">assert(b≥0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">sser</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></li></ul></li><li>如果机器和 driver 都没有 bug，程序就是对的</li></ul><blockquote><p>写出证明-启发</p></blockquote><ul><li>我们可以多写<code>assert</code>断言来避免出错</li><li>For all 𝑓 - reachable states, b≥0 holds.</li><li>为 𝑓 写一份数学证明就行了<ul><li>就像你在上数学课时做的习题一样</li></ul></li></ul><p>没错，计算机科学和数学的发展速度可能超过大家的想象——我们有被 “证明正确” 的 编译器、操作系统内核；可以阅读科普文章：</p><p><em>Formal verification doesn’t result in perfect code; it simply narrows the possibility for errors and vulnerabilities to creep in, ” Parno says. “What makes the technique so attractive is that you push the uncertainty or scope of problems down to smaller and smaller windows.</em></p><p><em>同时，proof assistant 也是人工智能时代堪称完美的辅助工具：如果我们要信任 AI 产生的结果，就让它们给出一个 proof assistant 认可的证明吧！</em></p><h2 id="2-为操作系统建模">2 为操作系统建模</h2><h3 id="2-1-操作系统的两个视角">2.1 操作系统的两个视角</h3><blockquote><p>应用视角 (自顶向下)</p></blockquote><ul><li>操作系统 = 对象 + API<ul><li>应用通过 <code>syscall</code> 访问操作系统</li></ul></li></ul><blockquote><p>机器视角 (自底向上)</p></blockquote><ul><li>操作系统 = C 程序<ul><li>运行在计算机硬件上的一个普通程序</li></ul></li></ul><h3 id="2-2-为操作系统建模">2.2 为操作系统建模</h3><blockquote><p>操作系统 = 状态机的管理者（状态机的容器）</p></blockquote><ul><li>当然，它自己也是状态机，有自己的状态</li></ul><blockquote><p>有了一个有趣的想法……</p></blockquote><ul><li>能不能我们自己定义 “状态机”<ul><li>用我们喜欢的语言、喜欢的方式</li><li>不要受限于 C、汇编……</li></ul></li><li>自己模拟状态机的执行<ul><li>形成一个 “玩具操作系统”</li></ul></li></ul><blockquote><p>简化的操作系统模型</p></blockquote><ul><li>用更方便的编程语言描述状态机<ul><li>依然是程序</li><li>依旧是 “数学严格” 的对象</li></ul></li><li>但用更简单的方法实现操作系统<ul><li>管理状态机</li><li>执行系统调用</li></ul></li></ul><h3 id="2-3-表示状态机">2.3 表示状态机</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">StateMachine</span>():</span><br><span class="line">    b = sys_read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        sys_write(<span class="string">&#x27;I got a zero.&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sys_write(<span class="string">&#x27;I got a one.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    sys_spawn(StateMachine)</span><br></pre></td></tr></table></figure><blockquote><p>系统调用</p></blockquote><ul><li>read(): 返回随机的 0 或 1</li><li>write(s): 向 buffer 输出字符串 <code>s</code></li><li>spawn(f): 创建一个可运行的状态机 <code>f</code></li></ul><blockquote><p>操作系统中的对象</p></blockquote><ul><li>状态机 (进程)<ul><li>Python 代码</li><li>初始时，仅有一个状态机 (main)</li><li>允许执行计算或 read, write, spawn 系统调用</li></ul></li><li>一个进程间共享的 buffer (“设备”)</li></ul><blockquote><p>因为 spawn 的存在，操作系统中有多个状态机 (进程)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以拿到一个python模拟的状态机</span></span><br><span class="line">wget -r -np -nH --cut-dirs=2 -R <span class="string">&quot;index.html*&quot;</span> <span class="string">&quot;https://jyywiki.cn/os-demos/introduction/os-model/&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#链接中的proc.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Process</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        sys_write(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    sys_spawn(Process, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    sys_spawn(Process, <span class="string">&#x27;B&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>操作系统会 “雨露均沾” 地运行它们</li><li>但 buffer 是所有状态机共享的<ul><li>于是有了并发……</li><li>操作系统是最早的实用并发程序</li></ul></li></ul><h2 id="3-数学视角的操作系统">3 数学视角的操作系统</h2><blockquote><p>状态</p></blockquote><ul><li>多个 “应用程序” 状态机<ul><li>当然，可以是模型</li></ul></li></ul><blockquote><p>初始状态</p></blockquote><ul><li>仅有一个 “main” 状态机<ul><li>这个状态机处于初始状态</li></ul></li></ul><blockquote><p>迁移</p></blockquote><ul><li>选择一个状态机执行一步<ul><li>就像我们在操作系统模型上看到的那样</li></ul></li></ul><h3 id="3-1-计算机系统中的不确定性">3.1 计算机系统中的不确定性</h3><blockquote><p>ps: 算法定义：一个有穷的指令集，这些指令为解决某一特定任务规定了一个运算序列 （就是一个描述集，就是一个指令集，就是一个序列集）</p></blockquote><blockquote><p>调度：状态机的选择不确定（并发：反人类直觉的一个过程）</p></blockquote><ul><li><code>current = random.choice(self.procs)</code></li><li>操作系统每次可以随机选择一个状态机执行一步</li></ul><blockquote><p>I/O：系统外的输入不确定</p></blockquote><ul><li>read 返回的结果也有两种可能性</li><li><code>t = sys_read()</code> 后，可能 t=0 或 t=1</li></ul><blockquote><p>推论：我们得到了状态图</p></blockquote><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑢</mi><mo>→</mo><mi>𝑣</mi><mo>⇔</mo><mi>𝑢</mi></mrow><annotation encoding="application/x-tex">𝑢→𝑣⇔𝑢</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> 可以通过一步迁移到达 𝑣</li><li>当然，我们只关心<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">s_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>可达的状态</li></ul><blockquote><p>Breadth-first search（广度优先算法）可以构建 “状态图”</p></blockquote><p><img src="https://cdn-img-el3.pages.dev/os/maze.webp" alt="maze.webp"></p><h3 id="3-2-蛮力法-Brute-force">3.2 蛮力法(Brute-force)</h3><blockquote><p>想要证明程序的性质？</p></blockquote><ul><li>只要稍微 “修改” 一下模拟器的实现就行了</li></ul><blockquote><p>构建状态图，检查程序正确性</p></blockquote><ul><li>read()：创建两个状态，分别是 𝑟=0和 𝑟=1</li><li>调度：为每个进程 𝑝 创建一个状态，对应选择 𝑝 执行</li><li>程序正确：不存在从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">s_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>可达的 “坏状态”<ul><li>例如：最终 buffer 中 A 和 B 的数量相同</li><li>“模型检查器”；Turing Award Lecture</li></ul></li></ul><p><img src="https://cdn-img-el3.pages.dev/os/c4-3.2-1.webp" alt="c4-3.2-1.webp"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下面是我们绘制一个 “Hello World” 状态空间的例子。Hello 会调用一个有趣的系统调用 fork，它的行为是复制状态机的当前状态：</span></span><br><span class="line">wget -r -np -nH --cut-dirs=2 -R &quot;index.html*&quot; &quot;https://jyywiki.cn/os-demos/mosaic/mosaic/&quot;</span><br></pre></td></tr></table></figure><p><em>程序就是状态机；状态机可以用程序表示。因此：</em></p><ul><li>我们可以用更 “简单” 的方式 (例如 Python) 描述状态机、建模操作系统上的应用，并且实现操作系统的可执行模型。</li><li>一旦把操作系统、应用程序当做 “数学对象” 处理，那么我们图论、数理逻辑中的工具就能被应用于处理程序——例如，可以用图遍历 “暴力枚举” 的方法证明程序的正确性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-绪论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.应用视角的操作系统</title>
      <link href="/2024/05/25/OS/class2/"/>
      <url>/2024/05/25/OS/class2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-操作系统上的最小应用程序">1. 操作系统上的最小应用程序</h2><h3 id="要想理解-“操作系统”，就要理解什么是-“程序”">要想理解 “操作系统”，就要理解什么是 “程序”</h3><ul><li><strong>一个Hello World示例</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>实际上，这个Hello World并不小</strong></p><ul><li><p>当我们使用objdump工具查看这个Hello World后可以发现：</p><ul><li><code>--verbose</code>可以查看所有编译选项 (真不少)<ul><li>printf 变成了 puts@plt</li></ul></li></ul></li><li><p><code>-Wl,--verbose</code>可以查看所有链接选项 (真不少)</p><ul><li>原来链接了那么多东西</li><li>还解释了 end 符号的由来</li></ul></li><li><p><code>-static</code> 会链接 libc (大量的代码)</p></li></ul></li><li><p><strong>Hello World的最小实现</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line"></span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">  movq $SYS_write, %rax   # write(</span><br><span class="line">  movq $1,         %rdi   #   fd=1,</span><br><span class="line">  movq $st,        %rsi   #   buf=st,</span><br><span class="line">  movq $(ed - st), %rdx   #   count=ed-st</span><br><span class="line">  syscall                 # );</span><br><span class="line"></span><br><span class="line">  movq $SYS_exit,  %rax   # exit(</span><br><span class="line">  movq $1,         %rdi   #   status=1</span><br><span class="line">  syscall                 # );</span><br><span class="line"></span><br><span class="line">st:</span><br><span class="line">  .ascii &quot;\033[01;31mHello, OS World\033[0m\n&quot;</span><br><span class="line">ed:</span><br></pre></td></tr></table></figure><p>下面我们在shell中编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc minimal.S -c &amp;&amp; ld minimal.o</span><br><span class="line">./a.out</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Hello, OS World</span></span><br></pre></td></tr></table></figure><p>这就是一个minimal. S</p><ul><li><strong>什么是程序：</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CPUState</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> regs[<span class="number">32</span>], csrs[CSR_COUNT];</span><br><span class="line">    <span class="type">uint8_t</span> *mem;</span><br><span class="line">    <span class="type">uint32_t</span> mem_offset, mem_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>处理器：无情的、执行指令的状态机</strong><ul><li>从M[PC] 取出一条指令</li><li>执行它</li><li>循环往复</li></ul></li></ul><h3 id="解决程序异常退出">解决程序异常退出</h3><ul><li><p><strong>程序自己是不能 “停下来” 的</strong></p><ul><li>指令集里没有一条关闭计算机的指令，那么操作系统是如何在关闭所有软件后，切断计算机的电源的？</li></ul></li><li><p><strong>只能借助操作系统</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $SYS_exit,  %rax   # exit(</span><br><span class="line">movq $1,         %rdi   #   status=1</span><br><span class="line">syscall                 # );</span><br></pre></td></tr></table></figure><ul><li>把 “系统调用” 的参数放到寄存器中</li><li>执行 syscall，操作系统接管程序<br>操作系统可以任意改变程序状态 (甚至终止程序)</li></ul><h3 id="所有二进制程序-状态机">所有二进制程序 = 状态机</h3><ul><li><strong>状态</strong><ul><li>gdb 内可见的内存和寄存器</li></ul></li><li><strong>初始状态</strong><ul><li>由 ABI 规定 (例如有一个合法的 %rsp)</li></ul></li><li><strong>状态迁移</strong><ul><li>执行一条指令<ul><li>我们花了一整个《计算机系统基础》解释这件事</li><li>gdb 可以单步观察状态机的执行</li></ul></li><li><strong>syscall</strong> 指令: 将状态机 “完全交给” 操作系统</li></ul></li></ul><h2 id="2-操作系统上的应用程序">2. 操作系统上的应用程序</h2><ul><li><p><strong>应用程序和minimal. S 一样，都是状态机</strong></p><ul><li>任何程序 = minimal. S =  状态机<ul><li>总是从被操作系统加载开始<ul><li>通过另一个进程执行 execve 设置为初始状态</li></ul></li><li>经历状态机执行 (计算 + syscalls)<ul><li>进程管理：fork, execve, exit, …</li><li>文件/设备管理：open, close, read, write, …</li><li>存储管理：mmap, brk, …</li></ul></li><li>最终调用 _exit (exit_group) 退出</li></ul></li></ul></li><li><p><strong>可执行文件是操作系统中的对象</strong></p><ul><li>与 minimal 的二进制文件没有本质区别</li><li>我们甚至可以像文本一样直接编辑可执行文件</li></ul></li><li><p><strong>一切应用程序的实现：</strong></p><ul><li>应用程序 = 计算 + 操作系统 API<ul><li>窗口管理器<ul><li>能直接管理屏幕设备 (read/write/mmap)<ul><li>能画一个点，理论上就能画任何东西</li></ul></li><li>能够和其他进程通信 (send, recv)</li></ul></li><li>任务管理器<ul><li>能访问操作系统提供的进程对象 (M1 - pstree)</li></ul></li><li>杀毒软件<ul><li>文件静态扫描 (read)、主动防御 (ptrace)</li></ul></li></ul></li></ul></li><li><p><strong>操作系统的职责：提供令应用程序舒适的抽象 (对象 + API)</strong></p></li></ul><h2 id="3-编译器与编译优化">3. 编译器与编译优化</h2><h3 id="3-1-什么是编译器">3.1 什么是编译器</h3><ul><li>编译器的输入<ul><li>高级语言 ( C ) 代码 = 状态机</li></ul></li><li>编译器的输出<ul><li>汇编代码 (指令序列) = 状态机</li></ul></li><li>编译器 = 状态机之间的翻译器</li></ul><h3 id="3-2-为什么c被称为高级汇编语言">3.2 为什么c被称为高级汇编语言</h3><ul><li>存在 C 代码到指令集的直接对应关系<ul><li>状态机和迁移都可以 “直译”</li><li>于是计算机系统里多了一个抽象层 (“一生二、二生三、三生万物”)</li></ul></li><li>更 “高级” 的语言就很难了<ul><li>C++ virtual void foo();</li><li>Python [1, 2, 3, *rest]</li><li>Javascript await fetch(…)</li></ul></li></ul><p><em>Everything (高级语言代码、机器代码) 都是状态机；而编译器实现了两种状态机之间的翻译。无论何种状态机，在没有操作系统时，它们只能做纯粹的计算，甚至都不能把结果传递到程序之外——而程序与操作系统沟通的唯一桥梁是系统调用 (例如 x86-64 的 syscall 指令)。如此重要的桥梁，操作系统中自然也有工具：strace 可以查看程序运行过程中的系统调用序列。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-绪论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.硬件视角的操作系统</title>
      <link href="/2024/05/25/OS/class3/"/>
      <url>/2024/05/25/OS/class3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-计算机系统的状态机模型">1 计算机系统的状态机模型</h2><h3 id="1-1-一切皆为状态机">1.1 一切皆为状态机</h3><ul><li>C 代码 = 状态机<ul><li>SimpleC &amp; GDB (TUI source)</li></ul></li><li>汇编代码 = 状态机<ul><li>GDB (TUI assembly)</li></ul></li><li>处理器 = 状态机<ul><li>mini-rv32ima; ICS PA</li></ul></li><li>数字电路 = 状态机<ul><li>Logisim</li></ul></li></ul><h3 id="1-2-计算机系统的状态机模型">1.2 计算机系统的状态机模型</h3><ul><li>状态<ul><li>内存、寄存器的数值</li></ul></li><li>初始状态<ul><li>由系统设计者规定 (CPU Reset)</li></ul></li><li>状态迁移<ul><li>从 PC 取指令执行</li></ul></li></ul><p>基本准确；但我们可以做一些补充</p><h4 id="1-2-1-计算机系统：状态">1.2.1 计算机系统：状态</h4><ul><li>寄存器、内存</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CPUState</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> regs[<span class="number">32</span>], csrs[CSR_COUNT];</span><br><span class="line">    <span class="type">uint8_t</span> *mem;</span><br><span class="line">    <span class="type">uint32_t</span> mem_offset, mem_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>还有外部世界的态</li><li>设备上的寄存器 (memory-mapped I/O 可以访问)</li><li>Interrupt/Reset Line</li><li><strong>客观存在，但计算机系统不能直接访问</strong><ul><li>类比：进程只能通过 syscall 访问进程外的信息</li></ul></li></ul><h4 id="1-2-2-计算机系统：初始状态">1.2.2 计算机系统：初始状态</h4><blockquote><p>CPU Reset</p></blockquote><ul><li>Intel 的工程师已经规定好，x86 处理器复位：<ul><li><code>EIP = 0x0000fff0</code></li><li><code>CR0 = 0x60000010</code><ul><li>处理器处于 16-bit 模式</li></ul></li></ul></li><li>RISC-V：百花齐放，百家争鸣<ul><li>初始 PC 无规定；寄存器除了 x0 全部 undefined</li><li>少数 CSR 有规定 (例如 interrupt disabled)<ul><li>设计原则：省电路</li><li>软件能做的，硬件绝对不管</li></ul></li></ul></li></ul><h4 id="1-2-3-计算机系统：状态迁移">1.2.3 计算机系统：状态迁移</h4><p><strong>执行指令</strong></p><ul><li>如果有多个处理器？<ul><li>可以想象成 “每次选一个处理器执行一条指令”</li></ul></li></ul><p><strong>响应中断</strong></p><ul><li>if (intr) goto vec;</li></ul><p><strong>输入输出</strong></p><ul><li>与 “计算机系统外” 交换数据</li><li>类似于程序：不使用 syscall 就等于死循环</li></ul><h2 id="2-固件：接管计算机系统的第一个程序">2 固件：接管计算机系统的第一个程序</h2><h3 id="2-1-计算机系统-状态机">2.1 计算机系统 = 状态机</h3><p><strong>程序员如何控制计算机系统？</strong></p><ul><li>仅有 RESET 状态是不够的</li><li>答案：计算机系统会和 System Programmers 达成约定</li></ul><h3 id="2-2-Firmware">2.2 Firmware</h3><p><strong>“固件”</strong></p><ul><li>厂商 “固定” 在计算机系统里的代码<ul><li>早期：固件是 ROM</li><li>想升级？换芯片！</li></ul></li></ul><p><strong>Firmware 的功能</strong></p><ul><li>运行程序前的计算机系统配置<ul><li>CPU 电压、内存时序、接口开关……</li><li>(这些配置要生效可能需要重启计算机)</li></ul></li><li>不严格地说，<strong>加载操作系统</strong><ul><li>QEMU：可以绕过 Firmware 直接加载操作系统 (RTFM)</li></ul></li></ul><p><em>Firmware：配置计算机系统</em><br><img src="https://cdn-img-el3.pages.dev/os/bios-1.webp" alt="bios-1"></p><p><em>Firmware：加载存储设备上的引导程序</em><br><img src="https://cdn-img-el3.pages.dev/os/bios-2.webp" alt="bios-2"></p><p><strong>Firmware：就是一段代码</strong></p><ul><li>一个小 “操作系统”<ul><li>CPU Reset 后初始化硬件；对接操作系统 Boot Loader</li></ul></li><li>Legacy BIOS (Basic I/O System)<ul><li>IBM PC 所有设备/BIOS 中断是有 specification 的<ul><li>16-bit DOS 时代 BIOS 常驻内存，提供 I/O 等功能</li></ul></li><li>成就了百花齐放的 “兼容机” 时代<ul><li>AMI 和 Phoenix BIOS, 等都活到了今天！</li></ul></li></ul></li><li>UEFI (Unified Extensible Firmware Interface)<ul><li>提供更丰富的支持 (例如设备驱动程序)：指纹锁、山寨网卡上的 PXE 网络启动、USB 蓝牙转接器连接的蓝牙键盘……</li></ul></li></ul><p><em>计算机系统是严格的数学对象：没有魔法；计算机系统的一切行为都是可观测、可理解的。</em></p><ul><li><em>处理器是无情的执行指令的机器。</em></li><li><em>处理器会规定好 Reset 后的行为。</em></li><li><em>Reset 后 Firmware 开始运行，再加载操作系统。</em></li><li><em>厂商逐渐形成了达成共识的 Firmware Specification (IBM PC “兼容机”、UEFI、……)。</em></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-绪论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.操作系统概述</title>
      <link href="/2024/05/24/OS/class1/"/>
      <url>/2024/05/24/OS/class1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>课程来源:b站-绿导师原谅你了<a href="https://space.bilibili.com/202224425/channel/collectiondetail?sid=2237004&amp;spm_id_from=333.788.0.0">“操作系统：设计与实现”(蒋炎岩)</a></p></blockquote><h2 id="1-为什么要学操作系统">1. 为什么要学操作系统</h2><h3 id="1-1-为什么要学xxx">1.1 为什么要学xxx</h3><ul><li>理解这门学科为了解决什么样的问题</li><li>重走一遍前人的发现历程</li><li>最终为了做到应用、创新、革命</li><li>了解到这门学科能做什么，不能做什么，知道这门技术的边界在哪里</li></ul><h2 id="2-什么是操作系统">2. 什么是操作系统</h2><blockquote><p>Operating System: A body of software, in fact, that is responsible for making it easy to run programs (even allowing you to seemingly run many at the same time), allowing programs to share memory, enabling programs to interact with devices, and other fun stuff like that. (OSTEP)</p></blockquote><h3 id="2-1-什么是操作系统">2.1 什么是操作系统</h3><p>简单的说，操作系统就是管理软/硬件资源、为程序提供服务的程序。</p><p><img src="https://cdn-img-el3.pages.dev/os/os-1-1.webp" alt="os-1-1"></p><ul><li>操作系统如何从一开始变成现在这样的？</li><li>三个重要的线索<br>硬件 (计算机)、软件 (程序)、操作系统 (管理硬件和软件的软件)</li></ul><h3 id="2-2前导知识">2.2前导知识</h3><ul><li>高级语言代码 → 指令序列 → 二进制文件 → 处理器执行<ul><li>前导课程目标：能将需求实现；掌握工具使用；阅读汇编指令</li></ul></li></ul><h3 id="3-3-理解操作系统">3.3 理解操作系统</h3><ul><li>操作系统他是在计算机硬件软件发展历史之间出现的一个产物。</li></ul><blockquote><h3 id="1940s">1940s</h3></blockquote><ul><li>在没有操作系统、甚至连编程语言都没有的时候，人们还在画流程图、写机制代码、戳纸袋，这个阶段，能把程序跑起来就很了不起了。</li></ul><blockquote><h3 id="1950s-1960s">1950s-1960s</h3></blockquote><ul><li><p>这个阶段，硬件改进了，逻辑门-存储-I/O 的基本格局没有变。</p><ul><li>晶体管、磁芯内存、丰富的 I/O 设备</li><li>I/O 设备的速度严重低于处理器的速度，中断机制出现 (1953)</li></ul></li><li><p>更复杂的通用的数值计算</p><ul><li>高级语言和 API 诞生 (Fortran, 1957)：一行代码，一张卡片80 行的规范沿用至今</li></ul></li></ul><p><img src="https://cdn-img-el3.pages.dev/os/os-1-2.webp" alt="os-1-2"></p><ul><li><p>Fortran 已经 “足够好用”</p><ul><li>迎来了自然科学、工程机械、军事……对计算机的需求暴涨</li></ul></li><li><p>库函数 + 管理程序排队运行的调度代码</p><ul><li>写程序 (戳纸带)、跑程序都是非常费事的</li><li>计算机非常贵<ul><li>$50,000−$1,000,000</li><li>通常一个学校只有一台</li></ul></li></ul></li><li><p>算力成为服务，操作系统概念形成</p><ul><li>多用户轮流共享计算机，operator 负责操作程序切换</li><li>Operating systems (操作系统/作業系統)<ul><li>(今天算力又成为服务了-<em>人工智能</em>)</li></ul></li></ul></li><li><p>CTSS (Compatible Time-Sharing System)</p></li></ul><blockquote><h3 id="1960s-1970s">1960s-1970s</h3></blockquote><ul><li><p>集成电路、总线出现</p></li><li><p>更多的高级语言和编译器出现</p></li><li><p>个人电脑登上历史舞台</p></li><li><p>能载入多个程序到内存且调度它们的管理程序</p><ul><li>为防止程序之间形成干扰，操作系统自然地将共享资源 (如设备) 以 API 形式管理起来<ul><li>有了进程 (process) 的概念</li><li>进程在执行 I/O 时，可以将 CPU 让给另一个进程<ul><li>在多个地址空间隔离的程序之间切换</li><li>虚拟存储使一个程序出 bug 不会 crash 整个系统</li></ul></li></ul></li></ul></li><li><p>操作系统中自然地增加进程管理 API</p></li></ul><blockquote><h3 id="1970s">1970s+</h3></blockquote><ul><li>分时系统走向成熟，UNIX 诞生并走向完善，奠定了现代操作系统的形态</li></ul><h2 id="3-如何学操作系统">3. 如何学操作系统</h2><blockquote><p><strong>试着去成为一个有 CS 梦想的人</strong></p></blockquote><p>是一个合格的操作系统用户</p><ul><li>会 STFW/RTFM/ATFAI 自己动手解决问题，进而，不怕使用任何命令行工具vim, tmux, grep, gcc, binutils, …</li><li>不怕 (或者爱上) 写代码<ul><li>能管理一定规模 (数千行) 的代码</li><li>在出 bug 时默念 “机器永远是对的、我肯定能调出来的”<ul><li>然后开始用正确的工具/方法调试</li></ul></li></ul></li></ul><p><em>操作系统是软件和硬件之间的桥梁；因此我们 “找到” 一些合适的软件、一些相对简单的硬件，理解操作系统就会变得容易。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统-绪论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2024/05/23/2024-5/2024-5-23/"/>
      <url>/2024/05/23/2024-5/2024-5-23/</url>
      
        <content type="html"><![CDATA[<blockquote><h2 id="测试">测试</h2></blockquote><p>​这篇测试文章将会是我的第一篇文章，立下flag，今后我将会记录我的一些：</p><ul><li>学习笔记</li><li>遇到并解决的问题</li><li>随笔</li></ul>]]></content>
      
      
      <categories>
          
          <category> 第一篇文档分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第一篇文档标签 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
