<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>应用视角的操作系统</title>
      <link href="/2024/05/25/OS/class2/"/>
      <url>/2024/05/25/OS/class2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-操作系统上的最小应用程序">1. 操作系统上的最小应用程序</h2><h3 id="要想理解-“操作系统”，就要理解什么是-“程序”">要想理解 “操作系统”，就要理解什么是 “程序”</h3><ul><li><strong>一个Hello World示例</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>实际上，这个Hello World并不小</strong></p><ul><li><p>当我们使用objdump工具查看这个Hello World后可以发现：</p><ul><li><code>--verbose</code>可以查看所有编译选项 (真不少)<ul><li>printf 变成了 puts@plt</li></ul></li></ul></li><li><p><code>-Wl,--verbose</code>可以查看所有链接选项 (真不少)</p><ul><li>原来链接了那么多东西</li><li>还解释了 end 符号的由来</li></ul></li><li><p><code>-static</code> 会链接 libc (大量的代码)</p></li></ul></li><li><p><strong>Hello World的最小实现</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line"></span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">  movq $SYS_write, %rax   # write(</span><br><span class="line">  movq $1,         %rdi   #   fd=1,</span><br><span class="line">  movq $st,        %rsi   #   buf=st,</span><br><span class="line">  movq $(ed - st), %rdx   #   count=ed-st</span><br><span class="line">  syscall                 # );</span><br><span class="line"></span><br><span class="line">  movq $SYS_exit,  %rax   # exit(</span><br><span class="line">  movq $1,         %rdi   #   status=1</span><br><span class="line">  syscall                 # );</span><br><span class="line"></span><br><span class="line">st:</span><br><span class="line">  .ascii &quot;\033[01;31mHello, OS World\033[0m\n&quot;</span><br><span class="line">ed:</span><br></pre></td></tr></table></figure><p>下面我们在shell中编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc minimal.S -c &amp;&amp; ld minimal.o</span><br><span class="line">./a.out</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Hello, OS World</span></span><br></pre></td></tr></table></figure><p>这就是一个minimal. S</p><ul><li><strong>什么是程序：</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CPUState</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> regs[<span class="number">32</span>], csrs[CSR_COUNT];</span><br><span class="line">    <span class="type">uint8_t</span> *mem;</span><br><span class="line">    <span class="type">uint32_t</span> mem_offset, mem_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>处理器：无情的、执行指令的状态机</strong><ul><li>从M[PC] 取出一条指令</li><li>执行它</li><li>循环往复</li></ul></li></ul><h3 id="解决程序异常退出">解决程序异常退出</h3><ul><li><p><strong>程序自己是不能 “停下来” 的</strong></p><ul><li>指令集里没有一条关闭计算机的指令，那么操作系统是如何在关闭所有软件后，切断计算机的电源的？</li></ul></li><li><p><strong>只能借助操作系统</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $SYS_exit,  %rax   # exit(</span><br><span class="line">movq $1,         %rdi   #   status=1</span><br><span class="line">syscall                 # );</span><br></pre></td></tr></table></figure><ul><li>把 “系统调用” 的参数放到寄存器中</li><li>执行 syscall，操作系统接管程序<br>操作系统可以任意改变程序状态 (甚至终止程序)</li></ul><h3 id="所有二进制程序-状态机">所有二进制程序 = 状态机</h3><ul><li><strong>状态</strong><ul><li>gdb 内可见的内存和寄存器</li></ul></li><li><strong>初始状态</strong><ul><li>由 ABI 规定 (例如有一个合法的 %rsp)</li></ul></li><li><strong>状态迁移</strong><ul><li>执行一条指令<ul><li>我们花了一整个《计算机系统基础》解释这件事</li><li>gdb 可以单步观察状态机的执行</li></ul></li><li><strong>syscall</strong> 指令: 将状态机 “完全交给” 操作系统</li></ul></li></ul><h2 id="2-操作系统上的应用程序">2. 操作系统上的应用程序</h2><ul><li><p><strong>应用程序和minimal. S 一样，都是状态机</strong></p><ul><li>任何程序 = minimal. S =  状态机<ul><li>总是从被操作系统加载开始<ul><li>通过另一个进程执行 execve 设置为初始状态</li></ul></li><li>经历状态机执行 (计算 + syscalls)<ul><li>进程管理：fork, execve, exit, …</li><li>文件/设备管理：open, close, read, write, …</li><li>存储管理：mmap, brk, …</li></ul></li><li>最终调用 _exit (exit_group) 退出</li></ul></li></ul></li><li><p><strong>可执行文件是操作系统中的对象</strong></p><ul><li>与 minimal 的二进制文件没有本质区别</li><li>我们甚至可以像文本一样直接编辑可执行文件</li></ul></li><li><p><strong>一切应用程序的实现：</strong></p><ul><li>应用程序 = 计算 + 操作系统 API<ul><li>窗口管理器<ul><li>能直接管理屏幕设备 (read/write/mmap)<ul><li>能画一个点，理论上就能画任何东西</li></ul></li><li>能够和其他进程通信 (send, recv)</li></ul></li><li>任务管理器<ul><li>能访问操作系统提供的进程对象 (M1 - pstree)</li></ul></li><li>杀毒软件<ul><li>文件静态扫描 (read)、主动防御 (ptrace)</li></ul></li></ul></li></ul></li><li><p><strong>操作系统的职责：提供令应用程序舒适的抽象 (对象 + API)</strong></p></li></ul><h2 id="3-编译器与编译优化">3. 编译器与编译优化</h2><h3 id="3-1-什么是编译器">3.1 什么是编译器</h3><ul><li>编译器的输入<ul><li>高级语言 © 代码 = 状态机</li></ul></li><li>编译器的输出<ul><li>汇编代码 (指令序列) = 状态机</li></ul></li><li>编译器 = 状态机之间的翻译器</li></ul><h3 id="3-2-为什么c被称为高级汇编语言">3.2 为什么c被称为高级汇编语言</h3><ul><li>存在 C 代码到指令集的直接对应关系<ul><li>状态机和迁移都可以 “直译”</li><li>于是计算机系统里多了一个抽象层 (“一生二、二生三、三生万物”)</li></ul></li><li>更 “高级” 的语言就很难了<ul><li>C++ virtual void foo();</li><li>Python [1, 2, 3, *rest]</li><li>Javascript await fetch(…)</li></ul></li></ul><p><em>Everything (高级语言代码、机器代码) 都是状态机；而编译器实现了两种状态机之间的翻译。无论何种状态机，在没有操作系统时，它们只能做纯粹的计算，甚至都不能把结果传递到程序之外——而程序与操作系统沟通的唯一桥梁是系统调用 (例如 x86-64 的 syscall 指令)。如此重要的桥梁，操作系统中自然也有工具：strace 可以查看程序运行过程中的系统调用序列。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统概述</title>
      <link href="/2024/05/24/OS/class1/"/>
      <url>/2024/05/24/OS/class1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>课程来源:b站-绿导师原谅你了<a href="https://space.bilibili.com/202224425/channel/collectiondetail?sid=2237004&amp;spm_id_from=333.788.0.0">“操作系统：设计与实现”(蒋炎岩)</a></p></blockquote><h2 id="1-为什么要学操作系统">1. 为什么要学操作系统</h2><h3 id="1-1-为什么要学xxx">1.1 为什么要学xxx</h3><ul><li>理解这门学科为了解决什么样的问题</li><li>重走一遍前人的发现历程</li><li>最终为了做到应用、创新、革命</li><li>了解到这门学科能做什么，不能做什么，知道这门技术的边界在哪里</li></ul><h2 id="2-什么是操作系统">2. 什么是操作系统</h2><blockquote><p>Operating System: A body of software, in fact, that is responsible for making it easy to run programs (even allowing you to seemingly run many at the same time), allowing programs to share memory, enabling programs to interact with devices, and other fun stuff like that. (OSTEP)</p></blockquote><h3 id="2-1-什么是操作系统">2.1 什么是操作系统</h3><p>简单的说，操作系统就是管理软/硬件资源、为程序提供服务的程序。</p><p><img src="https://cdn-img-el3.pages.dev/os/os-1-1.webp" alt="os-1-1"></p><ul><li>操作系统如何从一开始变成现在这样的？</li><li>三个重要的线索<br>硬件 (计算机)、软件 (程序)、操作系统 (管理硬件和软件的软件)</li></ul><h3 id="2-2前导知识">2.2前导知识</h3><ul><li>高级语言代码 → 指令序列 → 二进制文件 → 处理器执行<ul><li>前导课程目标：能将需求实现；掌握工具使用；阅读汇编指令</li></ul></li></ul><h3 id="3-3-理解操作系统">3.3 理解操作系统</h3><ul><li>操作系统他是在计算机硬件软件发展历史之间出现的一个产物。</li></ul><blockquote><h3 id="1940s">1940s</h3></blockquote><ul><li>在没有操作系统、甚至连编程语言都没有的时候，人们还在画流程图、写机制代码、戳纸袋，这个阶段，能把程序跑起来就很了不起了。</li></ul><blockquote><h3 id="1950s-1960s">1950s-1960s</h3></blockquote><ul><li><p>这个阶段，硬件改进了，逻辑门-存储-I/O 的基本格局没有变。</p><ul><li>晶体管、磁芯内存、丰富的 I/O 设备</li><li>I/O 设备的速度严重低于处理器的速度，中断机制出现 (1953)</li></ul></li><li><p>更复杂的通用的数值计算</p><ul><li>高级语言和 API 诞生 (Fortran, 1957)：一行代码，一张卡片80 行的规范沿用至今</li></ul></li></ul><p><img src="https://cdn-img-el3.pages.dev/os/os-1-2.webp" alt="os-1-2"></p><ul><li><p>Fortran 已经 “足够好用”</p><ul><li>迎来了自然科学、工程机械、军事……对计算机的需求暴涨</li></ul></li><li><p>库函数 + 管理程序排队运行的调度代码</p><ul><li>写程序 (戳纸带)、跑程序都是非常费事的</li><li>计算机非常贵<ul><li>$50,000−$1,000,000</li><li>通常一个学校只有一台</li></ul></li></ul></li><li><p>算力成为服务，操作系统概念形成</p><ul><li>多用户轮流共享计算机，operator 负责操作程序切换</li><li>Operating systems (操作系统/作業系統)<ul><li>(今天算力又成为服务了-<em>人工智能</em>)</li></ul></li></ul></li><li><p>CTSS (Compatible Time-Sharing System)</p></li></ul><blockquote><h3 id="1960s-1970s">1960s-1970s</h3></blockquote><ul><li><p>集成电路、总线出现</p></li><li><p>更多的高级语言和编译器出现</p></li><li><p>个人电脑登上历史舞台</p></li><li><p>能载入多个程序到内存且调度它们的管理程序</p><ul><li>为防止程序之间形成干扰，操作系统自然地将共享资源 (如设备) 以 API 形式管理起来<ul><li>有了进程 (process) 的概念</li><li>进程在执行 I/O 时，可以将 CPU 让给另一个进程<ul><li>在多个地址空间隔离的程序之间切换</li><li>虚拟存储使一个程序出 bug 不会 crash 整个系统</li></ul></li></ul></li></ul></li><li><p>操作系统中自然地增加进程管理 API</p></li></ul><blockquote><h3 id="1970s">1970s+</h3></blockquote><ul><li>分时系统走向成熟，UNIX 诞生并走向完善，奠定了现代操作系统的形态</li></ul><h2 id="3-如何学操作系统">3. 如何学操作系统</h2><blockquote><p><strong>试着去成为一个有 CS 梦想的人</strong></p></blockquote><p>是一个合格的操作系统用户</p><ul><li>会 STFW/RTFM/ATFAI 自己动手解决问题，进而，不怕使用任何命令行工具vim, tmux, grep, gcc, binutils, …</li><li>不怕 (或者爱上) 写代码<ul><li>能管理一定规模 (数千行) 的代码</li><li>在出 bug 时默念 “机器永远是对的、我肯定能调出来的”<ul><li>然后开始用正确的工具/方法调试</li></ul></li></ul></li></ul><p><em>操作系统是软件和硬件之间的桥梁；因此我们 “找到” 一些合适的软件、一些相对简单的硬件，理解操作系统就会变得容易。</em></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2024/05/23/2024-5/2024-5-23/"/>
      <url>/2024/05/23/2024-5/2024-5-23/</url>
      
        <content type="html"><![CDATA[<blockquote><h2 id="测试">测试</h2></blockquote><p>​这篇测试文章将会是我的第一篇文章，立下flag，今后我将会记录我的一些：</p><ul><li>学习笔记</li><li>遇到并解决的问题</li><li>随笔</li></ul>]]></content>
      
      
      <categories>
          
          <category> 第一篇文档分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第一篇文档标签 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
